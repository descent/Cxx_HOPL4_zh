# 10. 2020 年的 C++

本節我們來查看一下在二十一世紀的第二個十年裡, C++ 如何被使用, 以及用來做什麼: 

- [§10.1](#101-c-用來做什麼): C++ 用來做什麼? 
- [§10.2](#102-c-社區): C++ 社區
- [§10.3](#103-教育和研究): 教育和科研
- [§10.4](#104-工具): 工具
- [§10.5](#105-編程風格): 編程風格
- [§10.6](#106-編碼指南): 核心指南

C++ 的使用領域絶大部分與 2006 年相同 ([§2.3](02.md#23-c-的-2006)) 。雖然有一些新的領域, 但在大多數情況下, 我們看到的 C++ 還是在相同或類似的領域中被更加廣泛和深入地使用。C++ 沒有突然成為一種面向 Web 應用開發的語言, 雖然即使在那種場景下仍有人用 C++ [Obiltschnig et al. 2005]。對於大多數程式員來說, C++ 依然是某種隱沒在後台的東西, 穩定、可靠、可移植、高性能。最終使用者是看不見 C++ 的。

編程風格則有更加巨大的變化。比起 C++98, C++11 是門好得多的語言。它更易於使用, 表達能力更強, 性能還更高。2020 年發佈的 C++20 則在 C++11 的基礎上做出了類似程度的改進。

## 10.1 C++ 用來做什麼? 

大致而言, C++ 可謂無處不在、無所不用。但是, 大象無形, 大多數 C++ 的使用並不可見, 被深深隱藏在重要系統的基礎設施內部。

C++ 被用在哪裡, 是如何被使用的, 沒人能夠完整瞭解。2015 年, 捷克公司 JetBrains 委託進行了一項研究 [Kazakova 2015], 結果顯示在北美、歐洲、中東以及亞太地區 C++ 被大量使用, 在南美也有一些使用。“在南美的一些使用”就有 40 萬開發者, 而 C++ 開發者的總人數則達到了 440 萬。使用 C++ 的行業有 (按順序) 金融、銀行、遊戲、前台、電信、電子、投資銀行、營銷、製造和零售。所有跡象表明, 自 2015 年以來, C++ 的使用者數量和使用領域一直在穩步增長。

在這裡, 我將對 2006 到 2020 年期間內 C++ 的應用領域給出一個可能有些個人化的、印象派的、非常不完整的概覽: 

- **工業界**: 電信 (例如 AT&amp;T、愛立信、華為和西門子) 、移動設備 (基本上是所有, 信號處理、屏幕渲染、對性能或可移植性有重大要求的應用) 、微電子 (例如 AMD、英特爾、Mentor Graphics 和英偉達) 、金融 (例如摩根士丹利和文藝復興) 、遊戲 (几乎所有) 、圖形和動畫 (例如 Maya、迪士尼和 SideFx) 、區塊鏈實現 (例如 Ripple) 、資料庫 (例如 SAP、Mongo、MySQL 和 Oracle) 、雲 (例如谷歌、微軟、IBM 和 Amazon) 、人工智能和機器學習 (例如 TensorFlow 庫) 、運營支援 (例如 Maersk 和 AT&amp;T) 。
- **科學**: 航空航天 (例如 Space X、火星漫遊者、獵戶座載人飛行器、詹姆斯·韋伯太空望遠鏡) 、高能物理 (例如 CERN 歐洲核子研究中心、SLAC 國家加速器實驗室、費米實驗室) 、生物學 (遺傳學、基因組測序) 、超大規模計算。
- **教學**: 全球大多數工程院校。
- **軟體開發**: TensorFlow、工具、庫、編譯器、Emscripten (從 C++ 生成 asm.js 和 WebAssembly) 、運行期程式碼生成、LLVM (許多新語言的後台支柱, 也大量用於工具構建中) 、XML 和 JSON 解析器、異構計算 (例如 SYCL [Khronos Group 2014–2020] 和 HPX [Stellar Group 2014–2020]) 。
- **Web 基礎設施**: 瀏覽器 (Chrome、Edge、FireFox 和 Safari) 、JavaScript 引擎 (V8 和 SpiderMonkey) 、Java 虛擬機 (HotSpot 和 J9) 、谷歌和類似組織 (搜索、map-reduce 和檔案系統) 。
- **主要 Web 應用**: 阿里巴巴、Amadeus (機票) 、Amazon、蘋果、Facebook、PayPal、騰訊 (微信) 、Yandex。
- **工程應用**: 達索 (CAD/CAM) 、洛克希德·馬丁 (飛機) 。
- **汽車**: 輔助駕駛 [ADAS Wikipedia 2020; Mobileye 2020; NVIDIA 2020]、軟體架構 [Autosar 2020; Autosar Wikipedia 2020]、機器視覺 [OpenCV 2020; OpenCV Wikipedia 2020]、寶馬、通用、梅賽德斯、特斯拉、豐田、沃爾沃、大眾、Waymo (谷歌自動駕駛汽車) 。
- **嵌入式系統**: 智能手錶和健康監控器 (例如佳明) 、相機和視頻設備 (例如奧林巴斯和佳能) 、導航輔助設備 (例如 TomTom) 、咖啡機 (例如 Nespresso) 、農場動物監控器 (例如 Big Dutchman) 、生產綫溫度控制 (例如嘉士伯) 。
- **安全**: 卡巴斯基、美國國家安全局、賽門鐵克。
- **醫療和生物學**: 醫學監測和成像 (例如西門子、通用電氣、東芝和飛利浦) 、斷層掃瞄 (例如 CT) 、基因組分析、生物訊息學、放射腫瘤學 (例如 Elekta 和 Varian) 。

雖然這只是冰山一角, 但它展示了 C++ 使用的廣度和深度。大多數 C++ 的使用對其 (間接) 使用者不可見。某些對 C++ 的使用早于 2006 年, 但也有很多是之後才開始的。沒有一個主要現代系統只用單一語言寫就, 但是 C++ 在所有這裡提到的應用場合中發揮了重要作用。

我們常常忘記那些平凡的卻在我們的生活中起着重要作用的應用。沒錯, C++ 可以幫助運行美國國家航空航天局的深空網路, 但也可以在人們日常熟悉的小設備中運行, 例如咖啡機、立體聲揚聲器和洗碗機。讓我驚訝的是, C++ 竟然也被應用於運轉現代養豬場的先進系統中。

## 10.2 C++ 社區

與 2006 年相比, 2020 年的 C++ 社區更加壯大, 不斷蓬勃發展、積極向上、富有成效, 並且急切地想看到未來的進一步改進。

與大多數編程語言社區相比, C++ 社區一向是出奇地無組織和分散。這個問題早已有之, 因為我就沒有建立組織的才能。當時我的僱主 AT&amp;T 貝爾實驗室並不想建立一個 C++ 社區, 但是似乎其他所有人都非常感興趣, 並且願意花錢來建立他們的使用者群。最終的結果是, 許多公司, 例如蘋果、Borland、GNU、IBM、微軟和 Zortech 都建立了以其客戶為中心的 C++ 社區, 但是卻沒有總體的 C++ 社區, 社區沒有中心。有雜誌, 讀的人不多 (相對於 C++ 社區的規模) 。雖然有會議, 但它們傾向于被一般的“物件導向”的會議或“軟體開發”的會議所吸收或者就演變成了那些一般性會議。沒有總體的 C++ 使用者組。

如今, 世界上有數十個本地、國家和國際 C++ 使用者組, 這些使用者組之間也經常進行一些合作。除此之外, 還有數十個 C++ 會議, 每個會議都有數百人參加: 

- **C++ 基金會**——成立於 2014 年, 是一家非盈利性組織, 旨在推廣 ISO C++ (而不是任何特定供應商的 C++) , 它主辦 CppCon 年度會議。
- **Boost**——成立於 1999 年, 它是一組經過同行評審的庫、以及建造使用它們的社區。Boost 舉行年度會議。
- **Meeting C++**——成立於 2012 年, 是一個非常活躍的使用者團體網路, 定期舉行會議 (最初在德國活躍) 。在不同地方有數十個 Meeting C++ 的會議和聚會。
- **ACCU**——成立於 1984 年, 最初作為 C 使用者組而建立, 是所有現存 C++ 組織中的爺爺輩了; 它出版兩本雜誌, 並舉行年度會議 (主要在英國活躍) 。
- **isocpp.org**——C++ 基金會的網站, 其中包含與 C++ 有關的新聞, 標準化進程相關的訊息, 以及有用的連結。
- **cppreference.com**——出色的在綫參考資料; 它甚至有一個歷史部分! 
- **會議**——CppCon、ACCU、Meeting++、C++ Now (以前稱為 BoostCon) 、Qt、NDC、std::cpp 的會議, 以及在波蘭、俄羅斯、中國、以色列和其他地方的一些會議。此外, 很多通用軟體會議上也在越來越多的安排 C++ 專題。
- **博客**——有許多, 播客也是。
- **視頻**——視頻已成為有關 C++ 的最新進展的主要訊息來源。主要的 C++ 會議通常會錄製演講視頻並將其發佈以供免費訪問 (例如 CppCon、C++Now 和 Meeting++) 。視頻採訪已變得很流行。最多最受歡迎的託管網站是 YouTube, 但不幸的是, YouTube 在有些擁有大型 C++ 開發者群體的國家 (例如中國) 被封了。
- **GitHub**——使共享程式碼和組織聯合項目開發變得更加容易。

跟某些語言和供應商的集中組織相比, 這還差得很遠。但是, 這些 C++ 社區和組織富有活力, 彼此保持聯繫, 並且比在 2006 年的時候活躍得多。此外, 一些企業的使用者組和會議也仍然活躍。

## 10.3 教育和研究

從 2006 年不太理想的狀態 ([§2.3](02.md#23-c-的-2006)) 到現在, C++ 的教育是否得到了改善? 也許吧, 但是對於 C++ 來說, 教育仍然不是強項, 大多數教育還都集中在為業內人士提供訊息和培訓上。在大多數國家/地區, 很多大學畢業生對 C++ 語言及使用它的關鍵技術只能算一知半解。對於 C++ 社區來說, 這是一個嚴重的問題。因為, 對於一門語言來說, 如果沒有熱情洋溢的程式員們源源不斷、前赴後繼地精通其關鍵設計和實現技術, 那它是無法在工業規模上取得成功的。假如更多使用 C++ 的開發者知道如何更好地使用它, 那他們就能做太多太多的事來改進軟體! 如果畢業生帶著更準確的 C++ 視角進入工作崗位, 那麼太多太多的事情會變得容易得多! 

C++ 教學所面臨的一個問題是教育機構經常將編程視為低級技能, 而不是基礎課目。好的軟體對我們的文明至關重要。為了把控軟體, 我們需要像對待數學和物理學一樣, 嚴肅認真地對待關鍵系統的軟體開發。那種削足適履的方式對於教育和軟體開發是行不通的。一個學期的教學也遠遠不夠。我們永遠都不會期望在教了短短幾個月英語之後, 學生就會懂得欣賞莎士比亞。同樣, 瞭解語言的基本機制與精通內行所使用的慣用法和技巧之間是有差距的。就像任何主要的現代編程語言一樣, 教授 C++ 也需要根據學生的背景和需求相應地調整教學方法。即使教育機構意識到了這些問題並願意做出一些彌補, 奈何學生已經課滿為患, 教師也很難保持不跟工業實踐脫節。SG20 (教育) 正試圖總結教授和使用現代 C++ 的方法來提供一些幫助。SG15 (工具) 則可能提供更多支援教學的工具, 從而越來越多地發揮重要作用。

從 C++11 開始, 我們對此有了越來越多的認識。例如, Kate Gregory 製作了一些很棒的視頻, 介紹了如何教授 C++ [Gregory 2015, 2017, 2018]。最近的一些書籍認識到在支援教育方面, 不同的受眾存在不同的需求, 並試圖迎頭解決這些問題: 

- 《C++ 程式設計原理與實踐》 (*Programming: Principles and Practice Using C++*) [Stroustrup 2008a]——這是一本針對剛入門的大學生和自學人士的教科書。
- 《C++ 語言導學》 (*A Tour of C++*) [Stroustrup 2014d, 2018f]——針對經驗豐富的程式員的簡短概述 (200 頁) 。
- 《發現現代 C++》 (*Discovering Modern C++*) [Gottschling 2015]——這是一本專門為數學背景較強的學生準備的書。

我也寫了一些半學術性質的論文 (*Software Development for Infrastructure* [Stroustrup 2012] 和 *What should we teach software developers? Why?* [Stroustrup 2010b]) , 並在 CppCon 2017 開幕式上作了關於 C++ 教育的主題演講 (*Learning and Teaching Modern C++* [Stroustrup 2017c]) 。

自 2014 年左右以來, 視頻和在綫課程的使用急劇增加。這對 C++ 的教學來說很有幫助, 因為這樣就不需要一個中心組織或大量資金的支援。

以下列出了從 2006 到 2020 年間, 與 C++ 語言相關的學術研究成果: 

- **概念**: 泛型編程 [Dehnert and Stepanov 2000]、C++0x 概念 [Gregor et al. 2006]、使用模式 [Dos Reis and Stroustrup 2006]、庫設計 [Sutton and Stroustrup 2011]。
- **理論與形式化體系**: 繼承模型 [Wasserrab et al. 2006]、模板和重載 [Dos Reis and Stroustrup 2005a]、模板語義 [Siek and Taha 2006]、對象佈局 [Ramananandro et al. 2011]、構造和析構 [Ramananandro et al. 2012]、用於程式碼處理的表示形式 [Dos Reis and Stroustrup 2009, 2011]、資源模型 [Stroustrup et al. 2015]。
- **動態查找**: 快速動態類型轉換 [Gibbs and Stroustrup 2006]、模式匹配 [Solodkyyet et al. 2012]、多重方法 [Pirkelbauer et al. 2010]。
- **靜態分析**: 可靠的表示法 [Yang et al. 2012]、實踐經驗 [Bessey 2010]。
- **性能**: 程式碼膨脹 [Bourdev and Järvi 2006, 2011]、異常實現 [Renwicket et al. 2019]。
- **語言比較**: 泛型編程 [Garcia et al. 2007]。
- **並發和並行編程**: 記憶體模型 [Batty et al. 2013, 2012, 2011]、HPX (一個適用於任何規模的並行和分散式應用程式的通用 C++ 運行時系統 [Kaiser et al. 2009Sept]) 、STAPL (自適應泛型並行 C++ 庫 [Zandifar et al. 2014]) 、TBB (英特爾的任務並行庫 [Reinders 2007]) 。
- **協程**: 資料庫優化 [Jonathan et al. 2018; Psaropoulos et al. 2017]。
- **軟體工程**: 程式碼的組織和優化 [Garcia and Stroustrup 2015]、常數表達式求值 [Dos Reis and Stroustrup 2010]

看起來還有更多的關於 C++ 的學術研究機會, 關於語言的特性和技巧 (例如, 異常處理、編譯期編程和資源管理) , 以及其使用的有效性 (例如, 靜態分析或基于真實世界程式碼和經驗的研究) 。

C++ 社區中最活躍的成員中很少有人會考慮撰寫學術論文, 寫書似乎更受歡迎 (例如, [Čukić 2018; Gottschling 2015; Meyers 2014; Stepanov and McJones 2009; Vandevoorde et al. 2018; Williams 2018]) 。

## 10.4 工具

與其他語言相比, 在 1990 年代初期到中期, C++ 在用於工業用途的工具和編程環境方面做得相當不錯。例如, 圖形使用者界面和整合軟體開發環境都率先應用於 C++。後來, 開發和投資的重點轉移到專屬語言, 例如 Java (Sun) 、C# (微軟) 和 Objective-C (蘋果) 以及更簡單的語言, 例如 C (GNU) 。

在我看來, 有兩個主要原因: 

- 資金: 組織傾向于使用他們可以控制的語言和工具, 從而提供比競爭對手更大的差異化優勢。從這個角度來看, C++ 由正式的標準委員會控制、強調所有人的利益, 這反倒成了一個缺點——某種公地悲劇的變體。
- macro 和文本定義: C++ 沒有一個簡單, 可廣泛使用的內部表示形式來簡化基于原始碼的工具構建, 並且大量使用macro 必然導致程式員看到的跟編譯器所分析的有所不同。和 C 一樣, C++ 是根據字元序列來定義的, 而非根據直接表示抽象且更易於操作的構造來定義。我與 Gabriel Dos Reis 一起定義了這樣一個表示形式 [Dos Reis and Stroustrup 2009, 2011], 但事實證明 C++ 社區中面向字元的傳統難以克服。當初建造時沒有意識到的規範化結構, 想通過翻新加上去就難了。

因此, 在 2006–2020 年期間, 與其他語言相比, C++ 被支援工具方面的問題嚴重困擾。但是, 隨着以下這些工具的湧現, 這種情況得到了稍許改善: 

- 工業級的整合軟體開發環境: 例如微軟的 Visual Studio [Microsoft 2020; VStudio Wikipedia 2020] 和 JetBrains 的 CLion [CLion Wikipedia 2020; JetBrains 2020]。這些環境不僅支援編輯和除錯, 還支援各種形式的分析和簡單的程式碼轉換。
- 在綫編譯器: 例如 Compiler Explorer [Godbolt 2016] 和 Wandbox [Wandbox 2016–2020]。這些系統允許從任何瀏覽器中編譯 C++ 程式, 有時甚至可以執行。它們可用於實驗, 檢查程式碼質量, 還有比較不同的編譯器及編譯器和庫的不同版本。
- GUI 庫和工具: 例如 Qt [Qt 1991–2020]、GTKmm [GTKmm 2005–2020] 和 wxWidgets [wxWidgets 1992–2020]。不幸的是, Qt 依賴于元對象協議 (meta-object protocol, 縮寫為 MOP) , 因此 Qt 程式還不是標準的 ISO C++ 應用。靜態反射 ([§9.6.2](09.md#962-靜態反射)) 使我們最終能夠解決這個問題。C++ 社區的問題不是沒有好的 GUI 庫, 而是太多了, 因此會有選擇困難。
- 分析器: 例如 Coverity [Coverity 2002–2020], Visual Studio 的 C++ Core Guidelines 分析器 ([§10.6](#106-編碼指南)) 和 Clang Tidy [Clang Tidy 2007–2020]。
- 編譯器工具支援: 例如 LLVM 編譯器後端基礎設施, 可簡化程式碼生成和程式碼分析 [LLVM 2003–2020]。除了 C++ 本身, 這為許多新語言提供了福利。
- 構建系統: 例如 build2 [Build2 2014–2020] 和 CMake [CMake 2000–2020], 以及 GNUmake[GNUmake 2006–2020]。同樣, 在沒有標準的情況下, 選擇會有困難。
- 包管理器: 例如 Conan [Conan 2016–2020] 和 vcpkg [vcpkg 2016–2020]。
- 運行時環境: 例如 WebAssembly: 將 ISO C++ 編譯為位元組碼以在瀏覽器中部署的系統 [WebAssembly 2017–2020]。
- 運行時編譯、JIT 和連結: 例如 Cling [Cling 2014–2020; Naumann 2012; Naumann et al. 2010] 和 RC++ [RC++ 2010–2020]。

上面列出的只是一些範例。像往常一樣, C++ 使用者面臨的問題是可選方案的數量眾多, 例如: [RC++ 2010–2020] 列出了 26 個用於在編譯時生成程式碼的系統, 並且有數十個程式包管理器。因此, 我們需要的是某種形式的標準化。

截至 2020 年, 工具仍不是 C++ 的強項, 但我們正在大範圍內取得進展。

## 10.5 編程風格

針對大多數現實問題的最佳解決方案需要組合使用多種技術, 這也是 C++ 演進的主要動力。自然地, 這讓那些聲稱擁有單個簡單最佳解決方案 (“編程範式”) 的人感到不爽, 但是支援多種風格一直是 C++ 的根本優勢。考慮一下“繪製所有形狀”的例子, 這個例子自 Simula 發展早期 (繪圖設備為濕墨繪圖儀) 以來就一直用於說明物件導向編程。用 C++20, 我們可以這樣寫: 

```cpp
void draw_all(range auto& seq)
{
    for (Shape& s : seq)
        s.draw();
}
```

該段程式碼是什麼編程範式? 

- 顯然, 它是物件導向編程: 使用了虛函數和類層次結構。
- 顯然是泛型編程: 使用了模板 (通過使用 `range` 概念進行參數化, 我們得到一個模板) 。
- 顯然, 這是普通的命令式編程: 使用了 `for` 循環, 並按照常規 `f(x)` 語法定義了一個將要被呼叫的函數。

對這個例子我可以進一步展開: `Shape` 通常具有可變狀態; 我可以使用 lambda 表達式, 也可以呼叫 C 函數; 我可以用 `Drawable` 的概念對參數進行更多約束。對於各種“更好”的定義, 適當的技術組合比我能想到的任何一種單一範式所能提供的解決方案更好。

C++ 支援多種編程風格 (如您堅持, 也可以稱為“範式”) , 其背後的想法並不是要讓我們選擇一種最喜歡的樣式進行編程, 而是可以將多種風格組合使用, 以表達比單一風格更好的解決方案。

### 10.5.1 泛型編程

在 2006 年, 許多 C++ 程式碼仍然是物件導向的風格和 C 風格編程的混合體。自然而然的, 到 2020 年仍然有很多類似這樣的程式碼。但是, 隨着 C++98 的到來, STL 風格的泛型編程 (通常稱為 GP) 變得廣為人知, 並且使用者程式碼也逐漸開始使用 GP, 而不只是簡單地使用標準程式庫。C++11 中對 GP 的更好支援為在生產程式碼中更廣泛的使用 GP 提供了極大的便利。但是, C++17 中缺少概念 ([§6](06.md#6-概念)) , 這仍然阻礙了 C++ 中泛型編程的使用。

基本上, 所有專家都閲讀過 Alex Stepanov 的《編程原本》 (*Elements of Programming*, 通常稱為 *EoP*) [Stepanov and McJones 2009], 並受到其影響。

基于模板的泛型編程是 C++ 標準程式庫的支柱: 容器、範圍 ([§9.3.5](09.md#935-範圍)) 、演演算法、iostream、檔案系統 ([§8.6](08.md#86-檔案系統)) 、隨機數 ([§4.6](04.md#46-c11標準程式庫組件)) 、綫程 ([§4.1.2](04.md#412-綫程和鎖))  ([§9.4](09.md#94-並發)) 、鎖 ([§4.1.2](04.md#412-綫程和鎖))  ([§8.4](08.md#84-並發)) 、時間 ([§4.6](04.md#46-c11標準程式庫組件))  ([§9.3.6](09.md#936-日期和時區)) 、字元串、正則表達式 ([§4.6](04.md#46-c11標準程式庫組件)) 和格式化 ([§9.3.7](09.md#937-格式化)) 。

### 10.5.2 元編程

C++ 中的元編程出自泛型編程, 因為兩者都依賴于模板。它的起源可以追溯到 C++ 模板的早期, 當時人們發現模板是圖靈完備的 [Vandevoorde and Josuttis 2002; Veldhuizen 2003], 並以某種有用的形式提供編譯期純函數式編程。

模板元編程 (通常稱為 TMP) 往往非常醜。有時, 這種醜陋通過使用macro 來掩蓋, 從而造成了其他問題。TMP 几乎無處不在, 這也證明了它確實有用。例如, 如果沒有元編程, 就無法實現 C++14 標準程式庫。許多技巧和實驗在 2006 年前就有了, 但是 C++11 具有更好的編譯器、變參模板 ([§4.3.2](04.md#432-變參模板)) 和 lambda 表達式 ([§4.3.1](04.md#431-lambda-表達式)) , 這些推動了 TMP 成為主流用法。C++ 標準程式庫還增加了更多元編程的支援, 比如: 編譯期選擇模板 `conditional`, 允許程式碼依賴于類型屬性的類型特徵 (type trait) 如“能否安全地按位複製類型 X? ” ([§4.5.1](04.md#451-實現技巧)) , 還有 `enable_if` ([§4.5.1](04.md#451-實現技巧)) 。舉例來說: 

```cpp
conditional<(sizeof(int)<4),double,int>::type x; // 如果 int 小, 就用 double
```

計算類型以精確地反映需求, 這可以說是 TMP 的本質。我們還可以計算值: 

```cpp
template <unsigned n>
struct fac {
    enum { val = n * fac<n-1>::val };
};

template <>
struct fac<0> {   // 0 的特化: fac<0> 為 1
    enum { val = 1 };
};

constexpr int fac7 = fac<7>::val;  // 5040
```

注意, 模板特化在其中起着關鍵作用, 這一點在大多數 TMP 中是必不可少的。它已用於計算複雜得多的數值, 也可以表示控制流 (例如, 在編譯期計算決策表, 進行循環展開, 等等) 。在 C++98 [Stroustrup 2007] 中, 模板特化是一個很大程度上沒有得到足夠重視的特性。

在設計精巧的庫中以及在現實世界的程式碼中, 諸如 `enable_if` 之類的原語已成為數百甚至數千行的程式的基礎。TMP 的早期範例包含一個完整的編譯期 Lisp 解釋器 [Czarnecki and Eisenecker 2000]。此類程式碼極難除錯, 而維護它們更是可怕的差事。我見識過這樣的情形, 幾百行基于 TMP 的程式碼 (不得不承認非常聰明) , 在一台 30G 記憶體的計算機上編譯需要好幾分鐘的時間, 由於記憶體不足而導致最終編譯失敗。即使是簡單的錯誤, 編譯器的錯誤訊息也可以達到幾千行。然而, TMP 仍被廣泛使用。理智的程式員發現, 儘管 TMP 有着各種問題, 仍比起其他方案要好。我見過 TMP 生成的程式碼比我認為一個合格的人類程式員會手寫的組合語言程式碼要更好。

因此, 問題變成了如何更好地滿足這種需求。當人們開始把像 `fac<>` 這樣的程式碼視為正常時, 我為此而感到擔心。這不是表達普通數值演演算法的好方法。概念 ([§6](06.md#6-概念)) 和編譯期求值函數 (`constexpr` ([§4.2.7](04.md#427-constexpr-函數)) ) 可以大大簡化元編程。舉例來說: 

```cpp
constexpr int fac(int n)
{
    int r = 1;
    while (n>1) r*=n--;
    return r;
};

constexpr int fac7 = fac(7);  // 5040
```

這個例子說明, 當我們需要一個值時, 函數是最佳的計算方式, 即使——尤其——在編譯期。傳統**模板**元編程最好只保留用於計算新的類型和控制結構。

Jaakko Järvi 的 Boost.Lambda [Järvi and Powell 2002; Järvi et al. 2003a] 是 TMP 的早期使用案例, 它幫助說服了人們 lambda 表達式是有用的, 並且他們需要直接的語言支援。

Boost 元編程庫 Boost.MPL [Gurtovoy and Abrahams 2002–2020] 展示了傳統 TMP 的最好和最壞的方面。更現代的庫 Boost.Hana [Boost Hana 2015–2020] 使用 `constexpr` 函數。WG21 的 SG7 ([§3.2](03.md#32-組織)) 試圖開發一種更好的標準元編程系統, 其中還包括編譯期反射 ([§9.6.2](09.md#962-靜態反射)) 。

## 10.6 編碼指南

我對 C++ 語言的最終目標是: 

- 使用和學習上都要比 C 或當前的 C++ 容易得多
- 完全類型安全——沒有隱式類型違規, 沒有懸空指標
- 完全資源安全——沒有泄漏, 不需要垃圾收集器
- 為其構建工具要相對簡單——不要有macro 
- 跟當前 C++ 一樣快或更快——零開銷原則
- 性能可預測——適用於嵌入式系統
- 表達力不亞於當前的 C++——很好地處理硬體

這和《C++ 語言的設計和演化》[Stroustrup 1994] 及更早版本中闡述的設計目標並沒有太多不同。顯然, 這是一項艱巨的任務, 並且與較舊的 C 和 C++ 的多數用法不兼容。

最早, 在 C++ 還是“帶類的 C”的時候, 人們就建議創建語言的安全子集, 並使用編譯器開關來強制執行這種安全性。但是, 由於許多原因中的某一個原因, 這些建議失敗了: 

- 沒有足夠的人在“安全”的定義上達成一致。
- 不安全特性 (對每種“不安全”的定義來說) 是構建基本安全抽象的基礎。
- 安全子集的表達能力不足。
- 安全子集效率低下。

第二個原因意味着, 你不能僅僅通過禁止不安全的功能來定義一個安全的 C++。“通過限制以達到完美”這個方法, 對於編程語言的設計來說, 在極其有限的場合下才能發揮作用。你需要考慮那些一般來說不安全但有安全用途的特性的使用場景和特徵。此外, 該標準不能放棄向後兼容 ([§1.1](01.md#11-年表)) , 所以我們需要一種不同的方法。

從一開始, C++ 就採用了不同的哲學 [Stroustrup 1994]: 

> 讓良好的編程成為可能比防止錯誤更重要。

這意味着我們需要“良好使用”的指南, 而不是語言規則。但是, 為了在工業規模上有用, 指南必須可以通過工具強制執行。例如, 從 C 和 C++ 的早期開始, 我們就知道懸空指標存在的問題。例如: 

```cpp
int* p = new int[]{7,9,11,13};
// ...
delete[] p;    // 刪除 p 指向的陣列
               // 現在 p 沒有指向有效對象, 處于“懸空”狀態
// ...
*p = 7;        // 多半會發生災難
```

雖然許多程式員已經開發出防止指標懸空的技術。但是, 在大多數大型程式庫中, 懸空指標仍然是一個主要問題, 安全性問題比過去更加關鍵。一些懸空的指標可以作為安全漏洞被利用。

### 10.6.1 一般方法

在 2004 年, 我幫助制定了一套用於飛行控制軟體 [Lockheed Martin Corporation 2005] 的編碼指南, 這套指南接近於我對安全性、靈活性和性能的構想。2014 年, 我開始編寫一套編碼指南, 以解決這一問題, 並在更廣泛的範圍內應用。這一方面是為了回應對用好 C++11 的實用指南的強烈需求, 另外一方面是有人認為的好的 C++11 讓我看著害怕。與人們交談後, 我很快發現了一個明顯的事實: 我並不是唯一沿著這樣的路線思考和工作的人。因此, 一些經驗豐富的 C++ 程式員、工具製作者和庫構建者齊心協力, 與來自 C++ 社區的眾多參與者一起啟動了 **C++ 核心指南**項目 [Stroustrup and Sutter 2014–2020]。該項目是開源的 (MIT 許可證) , 貢獻者列表可以在 GitHub 上找到。早期, 來自摩根士丹利 (主要是我) 、微軟 (主要是 Herb Sutter、Gabriel Dos Reis 和 Neil Macintosh) 、Red Hat (主要是 Jonathan Wakely) 、CERN、Facebook 和谷歌的貢獻者都做出了突出貢獻。

核心指南絶不是唯一的 C++ 編碼指南項目, 但卻是最突出、最雄心勃勃的。它們的目標明確而清晰, 那就是顯著提升 C++ 程式碼的質量。例如, 早在 Bjarne Stroustrup、Herb Sutter 和 Gabriel Dos Reis 的論文中 [Stroustrup et al. 2015] 就闡明了關於完全類型和資源安全的理想和基礎模型。

為了實現這些雄心勃勃的目標, 我們採用了一種“鷄尾酒式”的混合方法: 

- **規則**: 一套龐大的規則集, 意圖在 C++ 裡實現使用上的類型安全和資源安全, 推薦那些已知的有效實踐, 並禁止已知的錯誤和低效的來源。
- **基礎庫**: 一組庫組件, 使程式員可以有效的編寫低層次程式, 而無需使用已知的容易出錯的功能, 並且從總體上為編程提供更高層次的基礎。大多陣列件來自標準程式庫, 其中一些來自以 ISO 標準 C++ 編寫的小型指南支援庫 (Guidelines Support Library, GSL) 。
- **靜態分析**: 檢測違規行為、並強制執行指南關鍵部分的工具。

這些方法中的每一種都有很長的歷史, 但是每一項都無法單獨在工業規模上解決這些問題。例如, 我是靜態分析的忠實擁護者, 但是如果程式員使用動態連結的方式在一個單獨編譯的程式中編寫任意複雜的程式碼, 那麼我最感興趣的分析演演算法 (例如, 消除懸空指標) 是不能求解成功的。這裡的“不能”是指“一般說來, 理論上是不可能的”, 以及“對於工業規模的程式而言在計算上過于昂貴”。

基本方式不是簡單的限制, 而是我稱之為“超集的子集”或 SELL 的方法 [Stroustrup 2005]: 

- 首先, 通過庫功能對語言進行擴展, 從而為正確的使用語言奠定堅實的基礎。
- 然後, 通過刪除不安全、易出錯及開銷過高的功能來設置子集。

對於庫, 我們主要依賴標準程式庫的各個部分, 例如 `variant` ([§8.3](08.md#83-variantoptional-和-any)) 和 `vector`。小型**指南支援庫** (GSL) 提供了類型安全的訪問支援, 例如 `span` 可以提供在給定類型的連續元素序列上的帶範圍檢查的訪問 ([§9.3.8](09.md#938-跨度)) 。我們的想法是通過將 GSL 吸收到 ISO 標準程式庫中, 從而最終也就不需要它了。例如, `span` 已被添加到 C++20 標準程式庫中。當時機成熟時, GSL 中對於契約的微弱支援也應當被合適的契約實現所替代 ([§9.6.1](09.md#961-契約)) 。

### 10.6.2 靜態分析

為了能規模化, 靜態分析完全是局部的 (一次僅一個函數或一個類) 。最難的問題與對象的生命周期有關。RAII 是必不可少的: 我們已經不止一次的看到, 手動資源管理的方法在很多語言中都很容易出錯。此外, 也有很多現存的程式, 以一種有原則的方式使用指標和迭代器。我們必須接受此類使用方式。要使一個程式安全很容易, 我們只需禁止一切不安全的功能。然而, 保持 C++ 的表現力和性能是核心指南的目標之一, 所以我們不能僅僅通過限制來獲得安全。我們的目的是一個更好的 C++, 而不是一個緩慢或被閹割的子集。

通過闡明原則、讓那些優秀的做法更加顯而易見、以及對已知問題進行機械化檢查, 這些指南可以幫助我們把教學的重點放在那些讓 C++ 更有效的方面。這些指南還有助于減輕對語言本身的壓力, 以適應最新的發展趨勢。

對於對象的生命周期, 主要有兩個要求: 

- 切勿指向超出範圍的對象。
- 切勿訪問無效的對象。

考慮以下“基礎模型”論文中的一個例子 [Stroustrup et al. 2015]) : 

```cpp
int glob = 666;
int* f(int* p)
{
    int x = 4;          // 局部變數
    // ...
    return &x;          // 不行, 會指向一個被銷毀的堆疊幀
    // ...
    return &glob ;      // 可以, 指向某個“永遠存在”的對象
    // ...
    return new int{7};  // 可以 (算是可以吧: 不懸空, 
                        //       但是把所有者作為 int* 返回了) 
    // ...
    return p;           // 可以, 來自呼叫者
}
```
指標指向已知會超過函數生命周期的對象 (例如, 作為參數被傳遞到函數中) , 我們可以返回它, 但對於指向局部資源的指標就不行。在遵循該指南的程式中, 我們可以確保作為參數的指標指向某資源或為 `nullptr`。

為避免泄漏, 上面範例中的“裸 `new`”操作應當通過使用資源句柄 (RAII) 或所有權標註來消除。

如果指標所指向的對象已重新分配, 則該指標會變為無效。例如: 

```cpp
vector<int> v = { 1,2,3 };
int* p = &v[2];
v.push_back(4); // v 的元素可能會被重新分配
*p = 5;         // 錯誤: p 可能已失效
int* q = &v[2];
v.clear();      // v 所有的元素都被刪除
*q = 7;         // 錯誤: q 無效
```

無效檢查甚至比檢查簡單的懸空指標還要困難, 因為很難確定哪個函數會移動對象以及是否將其視為失效 (指標 `p` 仍然指向某個東西, 但從概念上講已經指向了完全不同的元素) 。尚不清楚在沒有標註或非本地狀態的情況下, 靜態分析器是否可以完全處理無效檢查。在最初的實現中, 每個將對象作為非 `const` 操作的函數都被假定為會使指標無效, 但這太保守了, 導致了太多的誤報。最初, 關於對象生命周期檢查的詳細規範是由 Herb Sutter [Sutter 2019] 編寫的, 並由他在微軟的同事實現。

範圍檢查和 `nullptr` 檢查是通過庫支援 (GSL) 完成的。然後使用靜態分析來確保庫的使用是一致的。

靜態分析設想最早是由 Neil Macintosh 實現的, 目前已作為微軟 Visual Studio 的一部分進行發佈。有一些檢查規則已經成為了 Clang 和 HSR 的 Cevelop (Eclipse 插件) [Cevelop 2014–2020] 的一部分。一些課程和書籍中都加入了關於這些規則的介紹 (例如 [Stroustrup 2018f]) 。

核心指南是為逐步和有選擇地採用而設計的。因此, 我們看到其中一部分在工業和教育領域被廣泛採用, 但很少被完全採用。要想完全採用, 良好的工具支援必不可少。
