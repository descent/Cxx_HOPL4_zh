# 5. C++14: 完成 C++11

依據大版本和小版本交替發佈的計劃, C++14 [du Toit 2014] 的目標是“完成 C++11” ([§3.2](03.md#32-組織)) ; 也就是說, 接受 2009 年特性凍結後的好的想法, 糾正最初大規模使用 C++11 標準時發現的問題。對這個有限目標而言, C++14 是成功的。

重要的是, 它表明 WG21 可以按時交付標準。反過來, 這也使得實現者能夠按時交付。在 2014 年年底之前, 三個主要的 C++ 實現者 (Clang、GCC 和微軟) 提供了大多數人認為完整的特性。儘管並沒有完美地符合標準, 但人們基本上可以對所有的特性和特性組合進行實驗。要能編譯“用到所有高級特性”的庫, 還需要延後一些時間 (對微軟而言要到 2018 年) , 但對於大多數使用者而言, 對標準的符合程度足以滿足實際使用。標準工作和實現工作已經緊密聯繫在一起。這給社區帶來了很大的不同。

C++14 特性集可以概括為: 

- 二進制字面量, 例如 `0b1001000011110011`
- [§5.1](#51-數字分隔符): 數字分隔符——為了可讀性, 例如 `0b1001'0000'1111'0011`
- [§5.2](#52-變數模板): 變數模板——參數化的常數和變數
- [§5.3](#53-函數返回類型推導): 函數返回類型推導
- [§5.4](#54-泛型-lambda-表達式): 泛型 lambda 表達式
- [§5.5](#55-constexpr-函數中的局部變數): `constexpr` 函數中的局部變數
- 移動捕獲——例如 `[p = move(ptr)] {/* ... */};` 將值移入 lambda 表達式
- 按類型訪問元組, 例如 `x = get<int>(t);`
- 標準程式庫中的使用者定義字面量, 例如: `10i`, `"Hello"s`, `10s`, `3ms`, `55us`, `17ns`

這些特性中的大多數都面臨着兩個問題: “很好, 什麼使你花了這麼長的時間? ”以及“誰需要這個? ”我的印象是, 每個新特性都有着重要的需求作為動機——即使該需求不是通用的。在 `constexpr` 函數中添加局部變數和泛型 lambda 表達式大大改善了人們的程式碼。

重要的是, 從 C++11 升級到 C++14 是相對無痛的, 沒有 ABI 破壞。經歷過從 C++98 到 C++11 這一大而困難的升級的人感到了驚喜: 他們升級可以比預想還快, 花費的精力也更少。

## 5.1 數字分隔符

奇怪的是, 數字分隔符引起了最激烈的爭論。Lawrence Crowl 反覆提出了各種選項的分析 [Crowl 2013]。包括我在內的許多人都主張使用下劃線作為分隔符 (和好幾種其他語言一樣) 。例如: 

```cpp
auto a = 1_234_567;    // 1234567
```

不幸的是, 人們正在使用下劃線作為使用者定義字面量尾碼的一部分: 

```cpp
auto a = 1_234_567_s;  // 1234567 秒
```

這可能會引起歧義。例如, 最後一個下劃線是多餘的分隔符還是尾碼的開始? 令我驚訝的是, 這種潛在的歧義使下劃線對很多人來說變得難以接受。其中一個原因是, 為了免得程式員遇到意想不到的結果, 庫小組為標準程式庫保留了不以下劃線開頭的尾碼。經過長時間的討論, 包括全體委員會 (約 100 人) 的辯論, 我們一致同意使用單引號: 

```cpp
auto a = 1'234'567;    // 1234567 (整數) 
auto b = 1'234'567s;   // 1234567 秒
```

儘管有嚴厲的警告指出使用單引號會破壞無數的工具, 但實際效果似乎不錯。單引號由 David Vandevoorde 提出 [Crowl et al. 2013]。他指出, 在一些國家, 特別是在瑞士的金融符號中, 單引號被當作分隔符來使用。

我的另一個建議, 使用空白字元, 則一直沒有得到認同: 

```cpp
int a = 1 234 567;     // 1234567
int b = 1 234 567 s;   // 1234567 秒
```

許多人認為這個建議是一個與在愚人節發表的老文章 [Stroustrup 1998] 有關的笑話。而實際上, 它反映了一個舊規則, 即相鄰字元串會被連接在一起, 因而 `"abc" "def"` 表示 `"abcdef"`。

## 5.2 變數模板

2012 年, Gabriel Dos Reis 提議擴展模板機制, 在模板類、函數和別名 [Dos Reis 2012] 之外加入模板變數。例如: 

```cpp
template<typename T>
constexpr T pi = T(3.1415926535897932385);

template<typename T>
T circular_area(T r)
{
    return pi<T> * r * r;
}
```

起初, 我覺得這是一種平淡無奇的語言技術上的泛化, 沒有特別重要的意義。然而, 為指定各種精度的常數而採取的變通辦法由來已久, 而且充斥着令人不安的變通和妥協。經過這種簡單的語言泛化, 程式碼可以大幅簡化。特別是, 變數模板作為定義概念的主要方式應運而生 ([§6.3.6](06.md#636-改進)) 。例如: 

```cpp
// 表達式: 
template<typename T>
concept SignedIntegral = Signed<T> && Integral<T>;
```

C++20 標準程式庫提供了一組定義為變數模板的數學常數, 最常見的情況是定義為 `constexpr` [Minkovsky and McFarlane 2019]。例如: 

```cpp
template<typename T> constexpr T pi_v = unspecified;
constexpr double pi = pi_v<double>;
```

## 5.3 函數返回類型推導

C++11 引入了從 lambda 表達式的 return 語句來推導其返回類型的特性。C++14 將該特性擴展到了函數: 

```cpp
template<typename T>
auto size(const T& a) { return a.size(); }
```

這種寫法上的便利對於泛型程式碼中的小函數來說非常重要。但使用者必須很小心, 此類函數不能提供穩定的介面, 因為它的類型現在取決於它的實現, 而且在編譯到使用這個函數的程式碼時, 函數實現必須是可見的。

## 5.4 泛型 lambda 表達式

lambda 表達式是函數對象 ([§4.3.1](04.md#431-lambda-表達式)) , 因此它們顯然可以是模板。有關泛型 (多態) lambda 表達式的問題在 C++11 的工作中已經進行了廣泛討論, 但當時被認為還沒有完全準備好 ([§4.3.1](04.md#431-lambda-表達式)) 。

2012 年, Faisal Vali、Herb Sutter 和 Dave Abrahams 提議了泛型 lambda 表達式 [Vali et al. 2012]。提議的寫法只是從語法中省略了類型: 

```cpp
auto get_size = [](& m){ return m.size(); };
```

委員會中的許多人 (包括我) 都強烈反對, 指出該語法太過特別, 且不能推廣到受約束的泛型 lambda 表達式中。因此, 寫法更改為使用 `auto` 作為標記, 指明有類型需要推導: 

```cpp
auto get_size = [](auto& m){ return m.size(); };
```

這使泛型 lambda 表達式與早在 2002 年就提出的概念提案和泛型函數建議 [Stroustrup 2003; Stroustrup and Dos Reis 2003a,b] 保持一致。

這種將 lambda 表達式語法與語言其他部分所用的語法相結合的方向與一些人的努力背道而馳, 這些人希望為泛型 lambda 表達式提供一種獨特 (超簡潔) 的語法, 類似於其他語言 [Vali et al. 2012]: 

```
C# 3.0 (2007):      x => x * x;
Java 1.8 (~2013):   x -> x * x;
D 2.0 (~2009):      (x) { return x * x; };
```

我認為, 使用 `auto` 而且沒有為 lambda 表達式引入特殊的不與函數共享的記法是正確的。此外, 我認為在 C++14 中引入泛型 lambda 表達式, 而沒有引入概念, 則是個錯誤; 這樣一來, 對受約束和不受約束的 lambda 表達式參數和函數參數的規則和記法就沒有一起考慮。由此產生的語言技術上的不規則 (最終) 在 C++20 中得到了補救 ([§6.4](06.md#64-c20-概念)) 。但是, 我們現在有一代程式員習慣于使用不受約束的泛型 lambda 表達式併為此感到自豪, 而克服這一點將花費大量時間。

從這裡簡短的討論來看, 似乎委員會流程對記法/語法給予了特大號的重視。可能是這樣, 但是語法並非無足輕重。語法是程式員的使用者界面, 與語法有關的爭論通常反映了語義上的分歧, 或者反映了對某一特性的預期用途。記法應反映基礎的語義, 而語法通常偏向于對某種用法 (而非其他用法) 有利。例如, 一個完全通用和囉嗦的記法有利於希望表達細微差別的專家, 而一個為表達簡單情況而優化的記法, 則有利於新手和普通使用者。我通常站在後者這邊, 並且常常贊成兩者同時都提供 ([§4.2](04.md#42-c11簡化使用)) 。

## 5.5 `constexpr` 函數中的局部變數

到 2012 年, 人們不再害怕 `constexpr` 函數, 並開始要求放鬆對其實現的限制。實際上有些人希望能夠在 `constexpr` 函數中執行任何操作。但是, 無論是使用者還是編譯器實現者都還沒有為此做好準備。

經過討論, Richard Smith (谷歌) 提出了一套相對適度的放鬆措施 [Smith 2013]。特別是, 允許使用局部變數和 `for` 循環。例如: 

```cpp
constexpr int min(std::initializer_list<int> xs)
{
  int low = std::numeric_limits<int>::max();
  for (int x : xs)
    if (x < low)
      low = x;
  return low;
}

constexpr int m = min({1,3,2,4});
```

給定一個常數表達式作為參數, 這個 `min()` 函數可以在編譯時進行求值。本地的變數 (此處為 `low` 和 `x`) 僅在編譯器中存在。計算不能對呼叫者的環境產生副作用。Gabriel Dos Reis 和 Bjarne Stroustrup 在原始的 (學術) `constexpr` 論文中指出了這種可能性 [Dos Reis and Stroustrup 2010]。

這种放松簡化了許多 `constexpr` 函數並使許多 C++ 程式員感到高興。他們不滿地發現, 以前在編譯時只能對演演算法的純函數表達式進行求值。特別是, 他們希望使用循環來避免遞迴。就更長期來看, 這釋放出了要在 C++17 和 C++20 ([§9.3.3](09.md#933-編譯期計算支援)) 中進一步放鬆限制的需求。為了說明潛在的編譯期求值的能力, 我已經指出 `constexpr thread` 也是可能的, 儘管我並不急於對此進行提案。
