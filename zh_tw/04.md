# 4. C++11: 感覺像是門新語言

C++11 [Becker 2011] 發佈後, 其實現相對來說很快就出現了。這導致了極大的熱情, 增加了使用, 有大量新人湧入 C++ 世界, 併進行了大量的實驗。C++11 的三個完整或几乎完整的實現在 2013 年面世。我當時的評論被廣泛認為是準確的——**C++11 感覺像是一門新的語言** [Stroustrup 2014d]。為什麼 C++11 在幫助程式員方面做得如此出色? 又是如何做到的? 

C++11 引入了大量令人眼花繚亂的語言特性, 包括: 

- 記憶體模型——一個高效的為現代硬體設計的底層抽象, 作為描述並發的基礎 ([§4.1.1](#411-記憶體模型)) 
- `auto` 和 `decltype`——避免型別名稱的不必要重複 ([§4.2.1](#421-auto-和-decltype)) 
- 範圍 `for`——對範圍的簡單順序遍歷 ([§4.2.2](#422-範圍-for)) 
- 移動語義和右值引用——減少資料拷貝 ([§4.2.3](#423-移動語義)) 
- 統一初始化—— 對所有型別都 (几乎) 完全一致的初始化語法和語義 ([§4.2.5](#425-統一初始化)) 
- `nullptr`——給空指標一個名字 ([§4.2.6](#426-nullptr)) 
- `constexpr` 函數——在編譯期進行求值的函數 ([§4.2.7](#427-constexpr-函數)) 
- 使用者定義字面量——為使用者自定義型別提供字面量支援 ([§4.2.8](#428-使用者定義字面量)) 
- 原始字元串字面量——不需要轉義字元的字面量, 主要用在正則表達式中 ([§4.2.9](#429-原始字元串字面量)) 
- 屬性——將任意訊息同一個名字關聯 ([§4.2.10](#4210-屬性)) 
- lambda 表達式——匿名函數對象 ([§4.3.1](#431-lambda-表達式)) 
- 變參模板——可以處理任意個任意型別的參數的模板 ([§4.3.2](#432-變參模板)) 
- 模板別名——能夠重命名模板併為新名稱綁定一些模板參數 ([§4.3.3](#433-別名)) 
- `noexcept`——確保函數不會拋出異常的方法 ([§4.5.3](#453-noexcept-規約)) 
- `override` 和 `final`——用於管理大型類層次結構的明確語法
- `static_assert`——編譯期斷言
- `long long`——更長的整數型別
- 預設成員初始化器——給資料成員一個預設值, 這個預設值可以被建構子中的初始化所取代
- `enum class`——列舉值帶有作用域的強型別列舉

以下是主要的標準庫組件列表 ([§4.6](#46-c11標準庫組件)) : 

- `unique_ptr` 和 `shared_ptr`——依賴 RAII ([§2.2.1](02.md#221-語言特性)) 的資源管理指標 ([§4.2.4](#424-資源管理指標)) 
- 記憶體模型和 `atomic` 變數 ([§4.1.1](#411-記憶體模型)) 
- `thread`、`mutex`、`condition_variable` 等——為基本的系統層級的並發提供了型別安全、可移植的支援 ([§4.1.2](#412-執行緒和鎖)) 
- `future`、`promise` 和 `packaged_task`, 等——稍稍更高級的並發 ([§4.1.3](#413-期值future)) 
- `tuple`——匿名的簡單復合型別 ([§4.3.4](#434-tuple)) 
- 型別特徵 (type trait) ——型別的可測試屬性, 用於元編程 ([§4.5.1](#451-實現技巧)) 
- 正則表達式匹配 ([§4.6](#46-c11標準庫組件)) 
- 隨機數——帶有許多生成器 (引擎) 和多種分佈 ([§4.6](#46-c11標準庫組件)) 
- 時間——`time_point` 和 `duration` ([§4.6](#46-c11標準庫組件)) 
- `unordered_map` 等——哈希表
- `forward_list`——單向鏈表
- `array`——具有固定常數大小的陣列, 並且會記住自己的大小
- emplace 運算——在容器內直接構建對象, 避免拷貝
- `exception_ptr`——允許在執行緒之間傳遞異常

還有更多, 但這些是最重要的變化。所有這些都在 [Stroustrup 2013] 中進行了描述, 許多訊息可以在網上獲得 (例如 [Cppreference 2011–2020]) 。

這些表面上互不相干的擴展怎麼能組成一個連貫的整體? 這怎麼可能真正地改變我們寫程式碼的方式, 使之變得更好呢? C++11 做到了這一點。在相對較短的時間裡 (算 5 年吧) , 大量的 C++ 程式碼被升級到 C++11 (併進一步升級到 C++14 和 C++17) , 而且 C++ 在會議和博客上的呈現也完全改變了。

這種在語言的“感覺”和使用風格上的巨大變化, 並不是由某位大師級工匠指導的傳統的精心設計過程的結果, 而是海量建議經由一大批不斷變化的個人層層決策過濾後的結果。

在我的 HOPL3 論文 [Stroustrup 2007] 中, 我正確地描述了 C++11 語言的許多特性。值得注意的例外是“概念”, 我會在 ([§6](06.md#6-概念)) 中進行討論。我將不再贅述細節, 而是根據它們所解決的程式員需求來描述功能的“主題”分類。我認為這種看待提案的方式是 C++11 成功的根源: 

- [§4.1](#41-c11並發支援): 支援並發
- [§4.2](#42-c11簡化使用): 簡化使用
- [§4.3](#43-c11改進對泛型編程的支援): 改進對泛型編程的支援
- [§4.4](#44-c11提高靜態型別安全): 增加靜態型別安全
- [§4.5](#45-c11支援對庫的開發): 支援對庫的開發
- [§4.6](#46-c11標準庫組件): 標準庫組件

這些“主題”並不是不相干的。事實上, 我猜想 C++11 之所以成功, 是因為它相互關聯的功能彼此加成, 形成了一張精細的網路, 可以處理真正的需求。每一個主題裡都有我喜歡的特性。我懷疑, 我在寫作 (例如 [Stroustrup 1993, 1994, 2007]) 和演講中明確表述了 C++ 的目標, 也幫助設計保持了合理的重點。對我來說, 衡量每個新特性的一個關鍵指標是它是否使 C++ 更接近它的理想, 例如, 是否通過引入該特性能讓對內建型別和使用者定義型別的支援更加相似 ([§2.1](02.md#21-第一個十年)) 。

縱觀 C++11, 我們可以看到有些改進建議在 2002 年左右就被提出, 有不少庫也出現得很早, 經常是作為 Boost 的一部分 [Boost 1998–2020]。然而, 直到 2013 年才有完整的 C++11 實現。在 2020 年, 一些組織仍在為升級到 C++11 而苦惱, 因為程式碼庫巨大, 程式員不思進取, 教學方式陳舊, 以及編譯器嚴重過時 (尤其是在嵌入式系統領域) 。不過 C++17 的採用速度明顯快于 C++98 和 C++11; 並且, 早在 2018 年, C++20 的一些主要特性就已經投入生產使用。

直到 2018 年, 我仍能看到 C++98 前的編譯器被用於教學。我認為這是對學生的虐待, 剝奪了他們接觸學習我們 20 多年的進展的機會。

對標準委員會、主要編譯器廠商以及大多數 C++ 的積極支援者來說已是遙遠的過去的東西, 對許多人來說, 仍然是現在——甚至是未來。其結果是, 人們對 C++ 到底是什麼仍然感到困惑。只要 C++ 繼續演化, 這種困惑就會持續下去。

## 4.1 C++11: 並發支援

C++11 必須支援並發。這既是顯而易見的, 也是所有主要使用者和平台供應商的共同需求。C++ 一直在大多數軟體工業的基礎中被重度使用, 而在二十一世紀的頭十年, 並發性變得很普遍。利用好硬體並發至關重要。和 C 一樣, C++ 當然一直支援各種形式的並發, 但這種支援那時沒有標準化, 並且一般都很底層。機器架構正在使用越來越精巧的記憶體架構, 編譯器編寫者也在應用越來越激進的優化技術, 這讓底層軟體編寫者的工作極為困難。機器架構師和優化器編寫者之間亟需一個協定。只有有了明確的記憶體模型, 基礎庫的編寫者才能有一個穩定的基礎和一定程度的可移植性。

並發方面的工作從 EWG 中分離出來, 成為由 Hans-J. Boehm (惠普, 後加入谷歌) 領導的專家成員組成的並發組。它有三項職責: 

- [§4.1.1](#411-記憶體模型): 記憶體模型
- [§4.1.2](#412-執行緒和鎖): 執行緒和鎖
- [§4.1.3](#413-期值future): 期值

此外, 並行演算法 ([§8.5](08.md#85-並行-stl)) 、網路 ([§8.8.1](08.md#881-網路庫)) 和協程 ([§9.3.2](09.md#932-協程)) 是單獨分組處理的, 並且 (正如預期) 還沒法用於 C++11。

### 4.1.1 記憶體模型

最緊迫的問題之一, 是在一個有着多核、快取、推測執行、指令亂序等的世界裡精確地規定訪問記憶體的規則。來自 IBM 的 Paul McKenney 在記憶體保證方面的課題上非常活躍。來自劍橋大學的 Mark Batty 的研究 [Batty et al. 2013, 2012, 2010, 2011] 幫助我們將這一課題形式化, 見 P. McKenney、M. Batty、C. Nelson、H. Boehm、A. Williams、S. Owens、S. Sarkar、P. Sewell、T. Weber、M. Wong、L. Crowl 和 B. Kosnik 合作的論文 [McKenney et al. 2010]。它是 C++11 的一個龐大而至關重要的部分。

在 C11 中, C 採用了 C++ 的記憶體模型。然而, 就在 C 標準付諸表決前的最後一刻, C 委員會引入了不兼容的寫法, 而此時 C++11 標準修改的最後一次機會已經過去。這成了 C 和 C++ 實現者和使用者的痛苦。

記憶體模型很大程度上是由 Linux 和 Windows 內核的需求驅動的。目前它不只是用於內核, 而且得到了更加廣泛的使用。記憶體模型被廣泛低估了, 因為大多數程式員都看不到它。從一階近似來看, 它只是讓程式碼按照任何人都會期望的方式正常工作而已。

最開始, 我想大多數委員都小瞧了這個問題。我們知道 Java 有一個很好的記憶體模型 [Pugh 2004], 並曾希望採用它。令我感到好笑的是, 來自英特爾和 IBM 的代表堅定地否決了這一想法, 他們指出, 如果在 C++ 中採用 Java 的記憶體模型, 那麼我們將使所有 Java 虛擬機的速度減慢至少兩倍。因此, 為了保持 Java 的性能, 我們不得不為 C++ 採用一個複雜得多的模型。可以想見而且諷刺的是, C++ 此後因為有一個比 Java 更複雜的記憶體模型而受到批評。

基本上, C++11 模型基于**之前發生 (happens-before) 關係** [Lamport 1978], 並且既支援寬鬆的記憶體模型, 也支援順序一致 [Lamport 1979] 的模型。在這些之上, C++11 還提供了對原子型別和無鎖編程的支援, 並且與之整合。這些細節遠遠超出了本文的範圍 (例如, 參見 [Williams 2018]) 。

不出所料, 並發組的記憶體模型討論有時變得有點激烈。這關係到硬體製造商和編譯器供應商的重大利益。最困難的決定之一是同時接受英特爾的 x86 原語 (某種全存儲順序, Total Store Order (TSO) 模型 [TSO Wikipedia 2020] 加上一些原子操作) 和 IBM 的 PowerPC 原語 (弱一致性加上記憶體屏障) 用於最底層的同步。從邏輯上講, 只需要一套原語, 但 Paul McKenney 讓我相信, 對於 IBM, 有太多深藏在複雜演算法中的程式碼使用了屏障, 他們不可能採用類似英特爾的模型。有一天, 我真的在一個大房間的兩個角落之間做了穿梭外交。最後, 我提出必須支援這兩種方式, 這就是 C++11 採用的方式。當後來人們發現記憶體屏障和原子操作可以一起使用, 創造出比單單使用其中之一更好的解決方案時, 我和其他人都感到非常高興。

稍後, 我們增加了對基于資料依賴關係的一致性支援, 通過屬性 ([§4.2.10](#4210-屬性)) 在原始碼中表示, 比如 `[[carries_dependency]]`。

C++11 引入了 `atomic` 型別, 上面的簡單操作都是原子的: 

```cpp
atomic<int> x;
void increment()
{
    x++;  // 不是 x = x + 1
}
```

顯然, 這些都是廣泛有用的。例如, 使用原子型別使出名棘手的雙重檢查鎖定優化變得極為簡單: 

```cpp
mutex mutex_x;
atomic<bool> init_x;  // 初始為 false
int x;

if (!init_x) {
    lock_guard<mutex> lck(mutex_x);
    if (!init_x) x = 42;
    init_x = true ;
}  // 在此隱式釋放 mutex_x (RAII) 

// ... 使用 x ...
```

雙重檢查鎖定的要點是使用相對開銷低的 `atomic` 保護開銷大得多的 `mutex` 的使用。

`lock_guard` 是一種 RAII 型別 ([§2.2.1](02.md#221-語言特性)) , 它確保會解鎖它所控制的 `mutex`。

Hans-J. Boehm 將原子型別描述為“令人驚訝地流行”, 但我不能說我感到驚訝。我沒 Hans 那麼專業, 對簡化更為欣賞。C++11 還引入了用於無鎖編程的關鍵運算, 例如比較和交換: 

```cpp
template<typename T>
class stack {
    std::atomic<node<T>*> head;
public:
    void push(const T& data)
    {
        node<T>* new_node = new node<T>(data);
        new_node->next = head.load(std::memory_order_relaxed);
        while(!head.compare_exchange_weak(new_node->next, new_node,
              std::memory_order_release, std::memory_order_relaxed)) ;
    }
    // ...
};
```

即使有了 C++11 的支援, 我仍然認為無鎖編程是專家級的工作。

### 4.1.2 執行緒和鎖

在記憶體模型之上, 我們還提供了執行緒加鎖的並發模型。我認為執行緒加鎖級別的並發是應用程式使用並發的最差模型, 但是對於 C++ 這樣的語言來說, 它仍然必不可少。不管它還是別的什麼, C++ 一直是一種能夠與作業系統直接交互的系統編程語言, 可用於內核程式碼和設備驅動程式。因此, 它必須支援系統最底層支援的東西。在此基礎上, 我們可以建立各種更適合特定應用的並發模型。就我個人而言, 我特別喜歡基于消息的系統, 因為它們可以消除資料競爭, 而資料競爭可能產生極為隱晦的並發錯誤。

C++ 對執行緒和鎖級別編程的支援是 POSIX 和 Windows 所提供的執行緒和鎖的型別安全變體。在 [Stroustrup 2013] 有所描述, 在 Anthony Williams 的書 [Williams 2012, 2018] 中有更為深入的探討: 

- `thread`——系統的執行執行緒, 支援 `join()` 和 `detach()`
- `mutex`——系統的互斥鎖, 支援 `lock()`、`unlock()` 和保證 `unlock()` 的 RAII 方式
- `condition_variable`——系統中線程間進行事件通信的條件變數
- `thread_local`——執行緒本地存儲

與 C 版本相比, 型別安全使程式碼更簡潔, 例如, 不再有 `void**` 和macro 。考慮一個簡單的例子, 讓一個函數在不同的執行緒上執行並返回結果: 

```cpp
class F {  // 傳統函數對象
public:
    F(const vector<double>& vv, double* p) : v{vv}, res{p} { }
    void operator()();        // 將結果放入 *res
private:
    const vector<double>& v;  // 輸入源
    double* res;              // 輸出目標
};

double f(const vector<double>& v);  // 傳統函數

void g(const vector<double>& v, double* res); // 將結果放入 *res

int comp(vector<double>& vec1, vector<double>& vec2, vector<double>& vec3)
{
    double res1;
    double res2;
    double res3;
    // ...
    thread t1 {F{vec1,res1}};            // 函數對象
    thread t2 {[&](){res2=f(vec2);}};    // lambda 表達式
    thread t3 {g,ref(vec3),&res3};       // 普通函數

    t1.join();
    t2.join();
    t3.join();

    cout << res1 << ' ' << res2 << ' ' << res3 << '\n';
}
```

型別安全庫支援的設計主要依賴變參模板 ([§4.3.2](#432-變參模板)) 。例如, `std::thread` 的建構子就是變參模板。它可以區分不同的可執行的第一個參數, 並檢查它們後面是否跟有正確數量正確型別的參數。

類似地, lambda 表達式 ([§4.3.1](#431-lambda-表達式)) 使 `<thread>` 庫的許多使用變得更加簡單。例如, `t2` 的參數是訪問周圍局部作用域的一段程式碼 (lambda 表達式) 。

在發佈標準的同時, 讓新特性在標準庫中被接受和使用是很困難的。有人提出這樣做過于激進, 可能會導致長期問題。引入新的語言特性並同時使用它們無疑是有風險的, 但它通過以下方式大大增加了標準的質量: 

- 給使用者一個更好的標準庫
- 給使用者一個很好的使用語言特性的例子
- 省去了使用者實現底層功能的麻煩
- 迫使語言特性的設計者應對現實世界的困難應用

執行緒和鎖模型需要使用某種形式的同步來避免競爭條件。C++11 為此提供了標準的 `mutex` (互斥鎖) : 

```cpp
mutex m;  // 控制用的互斥鎖
int sh;   // 共享的資料

void access ()
{
    unique_lock<mutex> lck {m};   // 得到互斥鎖
    sh += 7;                      // 操作共享資料
} // 隱式釋放互斥鎖
```

`unique_lock` 是一個 RAII 對象, 確保使用者不會忘記在這個 `mutex` 上呼叫 `unlock()`。

這些鎖對象還提供了一種防止最常見形式的死鎖的方法: 

```cpp
void f()
{
    // ...
    unique_lock<mutex> lck1 {m1,defer_lock};  // 還未得到 m1
    unique_lock<mutex> lck2 {m2,defer_lock};
    unique_lock<mutex> lck3 {m3,defer_lock};
    // ...
    lock(lck1,lck2,lck3);  // 獲取所有三個互斥鎖
    // ... 操作共享資料 ...
}   // 隱式釋放所有互斥鎖
```

這裡, `lock()` 函數“同時”獲取所有 `mutex` 並隱式釋放所有互斥鎖 (RAII ([§2.2.1](02.md#221-語言特性)) ) 。C++17 有一個更優雅的解決方案 ([§8.4](08.md#84-並發)) 。

執行緒庫是由 Pete Becker (Dinkumware) 在 2004 年首次為 C++0x 提出的 [Becker 2004], 它基于 Dinkumware 對 Boost.Thread [Boost 1998–2020] 所提供的介面的實現。在同一次會議上 (華盛頓州 Redmond 市, 2004 年 9 月) 提出了第一個關於記憶體模型的提案 [Alexandrescu et al. 2004], 這可能不是巧合。

最大的爭議是關於取消操作, 即阻止執行緒運行完成的能力。基本上, 委員會中的每個 C++ 程式員都希望以某種形式實現這一點。然而, C 委員會在給 WG21 的正式通知 [WG14 2007] 中反對執行緒取消, 這是唯一由 WG14 (ISO C 標準委員會) 發給 WG21 的正式通知。我指出, “但是 C 語言沒有用於系統資源管理和清理的解構子和 RAII”。管理 POSIX 的 Austin Group 派出了代表, 他們 100% 反對任何形式的這種想法, 堅稱取消既沒有必要, 也不可能安全進行。事實上 Windows 和其他作業系統提供了這種想法的變體, 並且 C++ 不是 C, 然而POSIX 人員對這兩點都無動于衷。在我看來, 恐怕他們是在捍衛自己的業務和 C 語言的世界觀, 而不是試圖為 C++ 提出最好的解決方案。缺乏標準的執行緒取消一直是一個問題。例如, 在並行搜索 ([§8.5](08.md#85-並行-stl)) 中, 第一個找到答案的執行緒最好可以觸發其他此類執行緒的取消 (不管是叫取消或別的名字) 。C++20 提供了停止令牌機制來支援這個用例 ([§9.4](09.md#94-並發)) 。

### 4.1.3 期值 (future) 

一個型別安全的、標準的、類似 POSIX/Windows 的執行緒庫是對正在使用的不兼容的 C 風格庫的重大改進, 但這仍然是 1980 年代風格的底層編程。一些成員, 特別是我, 認為 C++ 迫切需要更現代、更高層次的東西。舉例來說, Matt Austern (谷歌, 之前代表 SGI) 和我主張消息隊列 (“通道”) 和執行緒池。這些意見沒有什麼進展, 因為有反對意見說沒有時間來做這些事情。我懇求並指出, 如果委員會中的專家不提供這樣的功能, 他們最終將不得不使用“由我的學生匆匆炮製的”功能。委員會當然可以做得比這好得多。“如果你不願意這樣做, 請給我一種方法, 就一種方法, 在沒有顯式同步的情況下在執行緒之間傳遞訊息! ”

委員會成員分為兩派, 一派基本上想要在型別系統上有改進的 POSIX (尤其是 P.J. Plauger) , 另一派指出 POSIX 基本上是 1970 年代的設計, “每個人”都已經在使用更高層次的功能。在 2007 年的 Kona 會議上, 我們達成了一個妥協: C++0x (當時仍期望會是 C++09) 將提供 `promise` 和 `future`, 以及非同步任務的啟動器 `async()`, 允許但不需要執行緒池。和大多數折中方案一樣, “Kona 妥協”沒有讓任何人滿意, 還導致了一些技術問題。然而, 許多使用者認為它是成功的——大多數人不知道這當時是一種妥協——這些年來, 已經出現了一些改進。

最後, C++11 提供了: 

- `future`——一個句柄, 通過它你可以從一個共享的單對象緩衝區中 `get()` 一個值, 可能需要等待某個 `promise` 將該值放入緩衝區。
- `promise`——一個句柄, 通過它你可以將一個值 `put()` 到一個共享的單對象緩衝區, 可能會喚醒某個等待 `future` 的 `thread`。
- `packaged_task`——一個類, 它使得設置一個函數在執行緒上非同步執行變得容易, 由 `future` 來接受 `promise` 返回的結果。
- `async()`——一個函數, 可以啟動一個任務並在另一個 `thread` 上執行。

使用這一切的最簡單方法是使用 `async()`。給定一個普通函數作為參數, `async()` 在一個 `thread` 上運行它, 處理執行緒啟動和通信的所有細節: 

```cpp
double comp4(vector<double>& v)
// 如果 v 足夠大則會產生多個任務
{
    if (v.size()<10000)    // 值得用並發機制嗎? 
        return accum(v.begin(),v.end(),0.0);
    auto v0 = &v[0];
    auto sz = v.size();

    auto f0 = async(accum,v0,v0+sz/4,0.0);         // 第一部分
    auto f1 = async(accum,v0+sz/4,v0+sz/2,0.0);    // 第二部分
    auto f2 = async(accum,v0+sz/2,v0+sz*3/4,0.0);  // 第三部分
    auto f3 = async(accum,v0+sz*3/4,v0+sz,0.0);    // 第四部分

    return f0.get()+f1.get()+f2.get()+f3.get();    // 收集結果
}
```
`async` 將程式碼包裝在 `packaged_task` 中, 並管理 `future` 及其傳輸結果的 `promise` 的設置。

值或異常都可以通過這樣一對 `future`/`promise` 從一個 `thread` 傳遞到另一個 `thread`。例如: 

```cpp
X f(Y); // 普通函數

void ff(Y y, promise<X>& p)     // 非同步執行 f(y)
{
    try {
        X res = f(y);           // ... 給 res 計算結果 ...
        p.set_value(res);
    }
    catch (...) {               // 哎呀: 沒能計算出 res
        p.set_exception(current_exception());
    }
}
```

為簡單起見, 我沒有使用參數的完美轉發 ([§4.2.3](#423-移動語義)) 。

對應 `future` 的 `get()` 現在要麼得到一個值, 要麼拋出一個異常——與 `f()` 的某個等效同步呼叫完全一樣。

```cpp
void user(Y arg)
{
    auto pro = promise<X>{};
    auto fut = pro.get_future();
    thread t {ff,arg,ref(pro)}; // 在不同執行緒上運行 ff
    // ... 做一會別的事情 ...
    X x = fut.get();
    cout << x.x << '\n';
    t.join();
}

int main()
{
    user(Y{99});
}
```

標準庫的 `packaged_task` 自動化了這個過程, 可以將普通函數包裝成一個函數對象, 負責 `promise`/`future` 的自動配置並處理返回和異常。

我曾希望這會產生一個由執行緒池支援的工作竊取 (work-stealing) 的實現, 但我還是失望了。

另見 ([§8.4](08.md#84-並發)) 。

## 4.2 C++11: 簡化使用

C++ 是“專家友好”的。我想我是第一個將這句話用作委婉的批評, 並且在 C++ 中推行“**簡單的事情簡單做! **”的口號的人。當然, 主要面向工業應用的語言就應該對專家友好, 但是一門語言不能只對專家友好。大多數使用編程語言的人並不是專家——他們也不想精通該語言的方方面面, 而只是想把工作做到足夠好, 不會因為語言而分心。編程語言的存在, 是為了能夠表達應用程式的創意, 而不是把程式員變成語言律師。語言的設計應該儘力讓簡單的事情能夠簡單地做。語言要給專家使用的話, 則必須額外確保, 沒有啥基本事項是不可能做的, 並且代價也不會過于高昂。

當討論潛在的 C++ 語言擴展和標準庫組件時, 另外一個準則是“教起來容易嗎? ”這個問題現在已經很普遍了, 它最早是由 Francis Glassborow 和我倡導的。“教起來容易”的思想起源於 C++ 的早期, 可以在《C++ 語言的設計和演化》[Stroustrup 1994] 中找到。

當然, 新事物的擁護者不可避免地認為他們的設計簡單、易用、足夠安全、高效、易於傳授, 及對大多數程式員有用。反對者則傾向于懷疑他們的部分甚至全部說法。但是, 確保對 C++ 提議的每個特性都經歷這樣的討論是很重要的: 可以通過面對面會議, 可以通過論文 [WG21 1989–2020], 也可以通過電子郵件。在這些討論中, 我經常指出, 我大部分時間也是個新手。也就是說, 當我學習新的特性、技巧或應用領域時, 我是一個新手, 我會用到從語言和標準庫中可以獲得的所有幫助。一個結果是, C++11 提供了一些特別的功能, 旨在簡化初學者和非語言專家對 C++ 的使用。

每一項新特性都會讓一些人做某些事時更加簡單。“簡化使用”的主題聚焦于這樣一些語言特性, 它們的主要設計動機是讓已知的慣用法使用起來更加簡單。下面列舉其中的一些: 

- [§4.2.1](#421-auto-和-decltype): `auto`——避免型別名稱的不必要重複
- [§4.2.2](#422-範圍-for): 範圍 `for`——簡化範圍的順序遍歷
- [§4.2.3](#423-移動語義): 移動語義和右值引用——減少資料拷貝
- [§4.2.4](#424-資源管理指標): 資源管理指標——管理所指向對象生命周期的“智能”指標 (`unique_ptr` 和 `shared_ptr`) 
- [§4.2.5](#425-統一初始化): 統一初始化——對所有型別都 (几乎) 完全一致的初始化語法和語義
- [§4.2.6](#426-nullptr): `nullptr`——給空指標一個名字
- [§4.2.7](#427-constexpr-函數): `constexpr` 函數——編譯期被估值的函數
- [§4.2.8](#428-使用者定義字面量): 使用者定義字面量——為使用者自定義型別提供字面量支援
- [§4.2.9](#429-原始字元串字面量): 原始字元串字面量——轉義字元 (`\`) 不被解釋為轉義符的字面量, 主要用在正則表達式中
- [§4.2.10](#4210-屬性): 屬性——將任意訊息同一個名字關聯
- [§4.2.11](#4211-垃圾收集): 與可選的垃圾收集器之間的介面
- [§4.3.1](#431-lambda-表達式): lambda 表達式——匿名函數對象

在 C++11 開始得到認真使用後, 我就開始在旅行時做一些不那麼科學的小調查。我會問各地的 C++ 使用者: 你最喜歡哪些 C++11 的特性? 排在前三位的一直都是: 

- [§4.2.1](#421-auto-和-decltype): `auto`
- [§4.2.2](#422-範圍-for): 範圍 `for`
- [§4.3.1](#431-lambda-表達式): lambda 表達式

這三個特性屬於 C++11 中新增的最簡單特性, 它們並不能提供任何新的基礎功能。它們做的事情, 在 C++98 中也能做到, 只是不那麼優雅。

我認為這意味着不同水平的程式員都非常喜歡讓慣常用法變簡潔的寫法。他們會高興地放棄一個通用的寫法, 而選擇一個在適用場合中更簡單明確的寫法。有一個常見的口號是, “一件事只應有一種說法! [^1]”這樣的“設計原則”根本不能反映現實世界中的使用者偏好。我則傾向于依賴**洋蔥原則** [Stroustrup 1994]。你的設計應該是這樣的: 如果要完成的任務是簡單的, 那就用簡單的方法做; 當要完成的任務不是那麼簡單時, 就需要更詳細、更複雜的技巧或寫法。這就好比你剝下了一層洋蔥。剝得越深, 流淚就越多。

請注意, 這裡**簡單**並不意味着**底層**。`void*`、macro 、C 風格字元串和型別轉換等底層功能表面上學起來簡單, 但使用它們來產出高質量、易維護的軟體就難了。

### 4.2.1 `auto` 和 `decltype`

C++11 中最古老的的新特性, 是能夠在初始化的時候就給對象指定一個確定的型別。例如: 

```cpp
auto i = 7;          // i 是個整數
auto d = 7.2;        // d 是個雙精度浮點數
auto p = v.begin();  // p 是 v 的迭代器型別
                     //  (begin() 返回一個迭代器) 
```

`auto` 是一個方便的靜態特性, 它允許從初始化表達式中推導出對象的靜態型別。如果要用動態型別的變數, 應該使用 `variant` 或者 `any` ([§8.3](08.md#83-variantoptional-和-any)) 。

我早在 1982/83 年冬天就實現了 `auto`, 但是後來為了保持 C 兼容性而不得不移除了這一特性。

在 C++11 中, 大家提出用 `typeof` 運算符代替已經流行的 `typeof` macro 和編譯器擴展。不幸的是, 不同 `typeof` macro 在處理引用時並不兼容, 因而採用任何一種都會嚴重破壞現有程式碼。引入一個新的關鍵字總是困難的, 因為如果它簡短而且意義明確, 那它一定已經被使用了成千上萬次。如果建議的關鍵字又醜又長, 那大家就會討厭它。

Jaakko Järvi, Boost 庫最多產的貢獻者之一, 那時是我在得州農工大學的同事。他當時領導了 `typeof` 的討論。我們意識到語義的問題可以概括為: “一個引用的 `typeof` 到底是引用自身, 還是所引用的型別? ”同時, 我們還感覺到, `typeof` 有點冗長而且容易出錯, 比如: 

```cpp
typeof(x+y) z = y+x;
```

在這裡, 我以為我重複計算了 `x+y`, 但其實並沒有 (潛在的不良影響) , 但不管怎麼樣, 我為什麼要把任何東西重複寫兩遍呢? 這時候我意識到, 我其實在 1982 年就解決過這個問題, 我們可以“劫持”關鍵字 `auto` 來消除這種重複: 

```cpp
auto z = y+x;  // z 獲得 y+x 的型別
```

在 C 和早期的 C++ 中, `auto` 曾表示“在自動存儲 (比如堆疊上) 上分配”, 但是從來沒有被用過。我們查看了數百萬行的 C 和 C++ 程式碼, 確認了 `auto` 只在一些測試集和錯誤中用到過, 於是我們就可以回收這個關鍵字, 用作我 1982 年的意思, 表示“獲取初始化表達式的型別”。

剩下的問題是, 我們要在某些場景中把引用的型別也推導為一個引用。這在基于模板的基礎庫中並不少見。我們提出了用 `decltype` 運算符來處理這種保留引用的語義: 

```cpp
template<typename T> void f(T& r)
{
    auto v = r;            // v 是 T
    decltype(r) r2 = r;    // r2 是 T&
    // ...
}
```

為什麼是 `decltype`? 可惜, 我已經不記得是誰建議了這個名字了, 但是我還記得原因: 

- `typeof` 已經不能用了, 因為那樣會破壞很多老程式碼
- 我們找不到其他優雅、簡短、且沒有被用過的名字了
- `decltype` 足夠好記 (“declared type”的簡寫) ; 但也足夠古怪, 因而沒有在現有程式碼中用過
- `decltype` 還算比較短

提議 `decltype` 的論文寫於 2003 年 [Järvi et al. 2003b], 而通過投票接受到標準中的論文寫於 2006 年 [Järvi et al. 2007]。Jaakko Järvi 做了讓 `decltype` 通過委員會評審的大部分細節的工作, Doug Gregor、Gabriel Dos Reis、Jeremy Siek 和我也幫過忙, 並且在一些論文中作為合著作者出現。事實證明, 澄清 `decltype` 的確切語義比我在這裡說的要難得多。花費數年在一個看上去很簡單的特性細節上的情況並不少見——部分原因是特性的固有複雜性, 部分原因則是, 需要最後批准的人可真不少, 他們需要同意每個細節的設計和具體說明都已經讓人滿意了。

我認為 `auto` 是個純粹的簡化特性, 而 `decltype` 的主要目的, 則是讓基礎庫可以使用複雜的元編程。然而, 從語言使用的技術角度來看, 它們是密切相關的。

我探索過推廣 `auto` 到另外兩個顯而易見的場景 [Stroustrup and Dos Reis 2003b]: 作為返回型別和參數型別。這顯而易見, 因為在 C++ 中, 參數傳遞和值返回被定義為初始化。但在 2003 年, 當我第一次向委員會提出這些想法時, 演化工作組的成員們毫不掩飾地表現出恐懼的神情。考慮下面的例子: 

```cpp
auto f(auto arg)
{
    return arg;
}

auto x = f(1);                // x 是 int
auto s = f(string("Hello"));  // s 是 string
```

當我向委員會提出這個想法時, 我收到了超過我的任何其他提案的負面反饋。我形容當時的情景“就像貴婦見到了老鼠一樣”, 他們叫嚷着: “咦咿......! ”。然而, 故事還沒結束。C++17 後來對 lambda 表達式 ([§4.3.1](#431-lambda-表達式)) 的參數和返回值都支援了 `auto`, 而對普通的函數, C++17 只支援返回值的 `auto`。作為概念的一部分 ([§6.4](06.md#64-c20-概念)) , C++20 為函數參數添加了 `auto` 支援, 至此才完全實現了我在 2003 年提出的建議。

C++11 中添加了一種弱化的 `auto` 用法, 把返回型別的說明放到參數後面。例如, 在 C++98 中, 我們會這樣寫: 

```cpp
template<typename T>
vector<T>::iterator vector<T>::begin() { /* ... */ }
```

重複出現的 `vector<T>::` 令人厭煩, 當時也沒法表達返回型別依賴于參數型別 (這在一些泛型編程中很有用) 。C++11 彌補了這個問題, 並提高了程式碼的可讀性: 

```cpp
template<typename T>
auto vector<T>::begin() -> iterator { /* ... */ }
```

這樣, 在多年努力後, 我們終於有了 `auto`。它立即就變得非常流行, 因為它讓程式員不用再拼寫冗長的型別名稱, 也不需要在泛型程式碼中考慮型別的細節。例如: 

```cpp
for (auto p = v.begin(); p != v.end(); ++p) ...  // 傳統的 STL 循環
```

它允許人們對齊名字: 

```cpp
class X {
public:
    auto f() -> int;
    auto gpr(int) -> void;
    // ...
};
void use(int x, char* p)
{
    auto x2 = x*2;   // x2 是 int
    auto ch = p[x];  // ch 是 char
    auto p2 = p+2;   // p2 是 char*
    // ...
}
```

還曾經有論文主張儘量多地使用 `auto` [Sutter 2013b]。有句話很經典: 每個有用的新特性, 一開始都會被濫用和誤用。一段時間後, 部分開發者找到了平衡點。把這種平衡的用法闡述為最佳實踐, 是我 (和很多其他人) 致力於編程指南 ([§10.6](10.md#106-編碼指南)) 的原因之一。對於 `auto`, 我收到了很多評論, 說當人們將它和沒有明顯型別的初始化表達式放一起使用時可讀性不好。因此, **C++ 核心指南** [Stroustrup and Sutter 2014–2020] ([§10.6](10.md#106-編碼指南)) 有了這條規則: 

> ES.11: 使用 `auto` 來避免型別名稱的多餘重複

我的書 [Stroustrup 2013, 2014d] 中也有類似的建議。考慮下面的例子: 

```cpp
auto n = 1;  // 很好: n 是 int
auto x = make_unique<Gadget>(arg);  // 很好: x 是 std::unique_ptr<Gadget>
auto y = flopscomps(x,3);           // 不好: flopscomps() 返回的是啥東西? 
```

這仍然無法百分百地確定如何在每種情況下應用該規則, 但有規則總比沒有規則要好得多, 並且程式碼會比使用絶對規則“不許使用 `auto`! ”和“永遠使用 `auto`! ”更加可讀。真實世界的編程往往需要更多的技巧, 不會像展示語言特性的例子這樣簡單。

如果 `flopscomps()` 不是泛型計算的一部分, 那麼最好顯式地聲明想要的型別。我們需要等到 C++ 20 才能用概念來約束返回型別 ([§6.3.5](06.md#635-概念和型別)) : 

```cpp
Channel auto y = flopscomps(x,3);   // y 可以當做 Channel 使用
```

那麼, 針對 `auto` 的工作值得嗎? 它是一個很小的功能, 對於簡單的情況, 一天就可以實現, 但卻花了 4 年的時間才在委員會通過。它甚至都不算新穎: 很多語言 40 年前就有這樣的功能了, 甚至帶類的 C 在 35 年前就有這樣的功能! 

對 C++ 標準委員會通過哪怕是最小的功能所需的時間, 以及常伴其間的痛苦討論, 經常讓我感到絶望。但是另一方面, 把事情做好之後, 成千上萬的程式員會從中受益。當某件事做得很好時, 最常見的評論是: “這很明顯啊! 怎麼你們要花那麼久? ”

### 4.2.2 範圍 `for`

範圍 `for` 是用來順序遍歷一個序列中所有元素的語句。例如: 

```cpp
void use(vector<int>& v, list<string>& lst)
{
    for (int x : v) cout << x << '\n';
    int sum = 0;
    for (auto i : {1,2,3,5,8}) sum+=i; // 初始化列表是一個序列
    for (string& s : lst) s += ".cpp"; // 使用引用允許遍歷時修改
}
```

它最初是由 Thorsten Ottosen (丹麥奧爾堡大學) 提出的, 理由是“基本上任何現代編程語言都內置了某種形式的 for each” [Ottosen 2005]。我通常不認為“別人都有了”是個好的論據, 但在這一情況下, 真正的要點是, 簡單的範圍循環可以簡化一種最常見的操作, 並提供了優化的機會。所以, 範圍 `for` 完美符合我對 C++ 的總體設計目標。它直接表達應該做什麼, 而不是詳細描述如何做。它的語法簡潔, 語義明晰。

由於更簡單和更明確, 範圍 `for` 語句消除了一些“微不足道”然而常見的錯誤: 

```cpp
void use(vector<int>& v, list<string>& lst)
{
    for (int i=0; i<imax; ++i)
        for (int j=0; i<imax; ++j) ...  // 錯誤的嵌套循環

    for (int i=0; i<=max; ++i) ...      // 多循環了一次的錯誤
}
```

儘管範圍 `for` 夠簡單了, 它在這些年還是有些變化。Doug Gregor 曾建議使用 C++0x 中的概念來修改範圍 `for`, 方案優雅並且得到了批准 [Ottosen et al. 2007]。我還記得他在我在得州的辦公室裡寫這個提案的場景, 但很遺憾, 後來因為刪除了 C++0x 的概念 ([§6](06.md#6-概念)) , 我們不得不回退了那些修改。在 2016 年, 它還做過一點小修改, 以配合 Ranges TS ([§9.3.5](09.md#935-範圍)) 所支援的無限序列。

### 4.2.3 移動語義

在 C 和 C++ 中, 要從函數獲得大量的資料, 傳統做法是在自由存儲區 (堆、動態記憶體) 上分配空間, 然後傳遞指向該空間的指標作為函數參數。比如, 對於工廠函數和返回容器 (例如 `vector` 和 `map`) 的函數就需要如此。這對開發者來說看起來很自然, 而且相當高效。不幸的是, 它是顯式使用指標的主要來源之一, 導致了寫法上的不便、顯式的記憶體管理, 以及難以查找的錯誤。

多年來, 很多專家使用“取巧”的辦法來解決這個問題: 把句柄類作為簡單數值 (常稱為**值型別**) 來傳遞, 例如: 

```cpp
Matrix operator+(const Matrix&, const Matrix&);

void use(const Matrix& m1, const Matrix& m2)
{
    Matrix m3 = m1+m2;
    // ...
}
```

這裡 `operator+` 讓我們可以使用常規的數學記法, 同時也是一個工廠函數返回大對象的範例。

通過 `const` 引用把 `Matrix` 傳遞給函數, 一直是傳統而高效的做法。而問題在於, 如何以傳值來返回 `Matrix` 而不用拷貝所有的元素。早在 1982 年, 我曾通過一種優化方案來部分解決這一問題, 即乾脆將返回值分配在呼叫函數的堆疊幀上。它工作得很好, 但它只是優化技術, 不能處理更複雜的返回語句。而使用者在按值返回“大對象”時, 需要確保絶不會進行大量的資料複製。

要做到這一點, 需要觀察到“大對象”通常是在自由存儲區上的資料的一個句柄。為了避免複製大量的資料, 我們只需要確保在實現返回時, 建構子複製的只是句柄, 而不是所有元素。C++11 對這個問題的解決方案如下所示: 

```cpp
class Matrix {
    double* elements;    // 指向所有元素的指標
    // ...
public:
    Matrix (Matrix&& a)  // 移動構造
    {
        elements = a.elements;  // 複製句柄
        a.elements = nullptr;   // 現在 a 的解構子不用做任何事情了
    }
    // ...
};
```

當用於初始化或賦值的源對象馬上就會被銷毀時, **移動**就比**拷貝**要更好: 移動操作只是簡單地把對象的內部表示“竊取”過來。`&&` 表示建構子是一個**移動建構子**, `Matrix&&` 被稱為**右值引用**。當用於模板參數時, 右值引用的符號 `&&` 被叫做**轉發引用**, 這是由 John Spicer 在 2002 年的一次會議上, 同 Dave Abrahams 和 Howard Hinnant 一起提出的。

這個 `Matrix` 的例子有個有意思的地方: 如果 `Matrix` 的加法返回指標的話, 那傳統的數學記號 (`a+b`) 就不能用了。

移動語義蘊含著性能上的重大好處: 它消除了代價高昂的臨時變數。例如: 

```cpp
Matrix mx = m1+m2+m3;  // 不需要臨時變數
string sx = s1+s2+s3;  // 不需要臨時變數
```

這裡我添加了 `string` 的例子, 因為移動語義立刻就被添加到了所有的標準庫容器上, 這可以讓一些 C++98 的程式拿來不做任何程式碼修改就獲得性能提升。

允許類的設計者定義移動操作後, 我們就有了完整的對對象生命周期和資源管理的控制, 這套控制始於 1979 年對建構子和解構子的引入。移動語義是 C++ 資源管理模型的重要基石 [Stroustrup et al. 2015], 正是這套機制使得對象能夠在不同作用域之間可以簡單而高效地進行移動。

早期對參數傳遞、完美轉發和智能指標強調頗多, 可能掩蓋了這個重要的一般性觀點。Howard Hinnant、Dave Abrahams 和 Peter Dimov 在 2002 年提出了移動語義的一般化版本 [Hinnant et al. 2004, 2002]: 

> 右值引用可以用於給現有類方便地添加移動語義。意思是說, 拷貝建構子和賦值運算符可以根據實參是左值還是右值來進行重載。當實參是右值時, 類的作者就知道他擁有對該實參的唯一引用。

一個突出的例子是生成“智能指標”的工廠函數: 

```cpp
template <class T, class A1>
std::shared_ptr<T> factory(A1&& a1)
{
    return std::shared_ptr<T>(new T(std::forward<A1>(a1)));
}
```

現已進入標準庫的函數 `forward` 告訴編譯器將實參視為右值引用, 因此 `T` 的移動建構子 (而不是拷貝建構子) 會被呼叫, 來竊取該參數。它本質上就是個右值引用的型別轉換。

在 C++98 中, 沒有右值引用, 這樣的“智能指標”很難實現。在 C++11 中, 解決方案就簡單了 [Hinnant et al. 2006]: [^2]

```cpp
template <class T>
class clone_ptr
{
private:
    T* ptr;
public:
    // ...
    clone_ptr(clone_ptr&& p)            // 移動建構子
        : ptr(p.ptr)    // 拷貝資料的表示
    {
        p.ptr = 0;      // 把源資料的表示置空
    }
    clone_ptr& operator=(clone_ptr&& p) // 移動賦值
    {
        std::swap(ptr, p.ptr);
        return *this;   // 銷毀目標的舊值
    }
};
```

很快, 移動語義技術就被應用到了標準庫的所有容器類上, 像 `vector`、`string` 和 `map`。`shared_ptr` 和 `unique_ptr` 的確智能, 但它們仍然是指標。我更喜歡強調移動構造和移動賦值, 它們使得 (以句柄表示的) 大型對象在作用域間能夠高效移動。

右值引用的提案在委員會中涉險過關。有人認為右值引用和移動語義多半來不及進入 C++11, 因為這些概念很新, 而我們那時連合適的術語都沒有。部分由於術語上的問題 [Miller 2010], **右值引用**這一術語在核心語言和標準庫中的使用就有了分歧, 從而使得標準草案中出現了不一致。在 2010 年 3 月的匹茲堡會議上, 我參與了核心工作組 (CWG) 的討論, 在午飯休息的時間, 在我看來“我們陷入了僵局, 或者混亂之中, 也許兼而有之”。我沒有去吃午飯, 而是對問題進行了分析, 並得出結論, 這裡只涉及到兩個基本概念: **有標識符** (identity) , 及**可被移動**。從這兩個原語出發, 我推導出了傳統的左值和右值類別 [Barron et al. 1963], 以及解決我們的定義問題所需要的三個新類別。在核心工作組回來之後, 我提出了我的解決方案。它很快就得到了接受, 這樣我們就在 C++11 中保留了移動語義 [Stroustrup 2010a]。

### 4.2.4 資源管理指標

C++11 提供了“智能指標” ([§4.2.4](#424-資源管理指標)) : 

- `shared_ptr`——代表共享所有權
- `unique_ptr`——代表獨占所有權 (取代 C++98 中的 `auto_ptr`) 

添加這些表示所有權的資源管理“智能指標”對編程風格有很大的影響。對很多人來說, 這意味着不再有資源泄漏, 懸空指標的問題也顯著減少。在自動化資源管理和減少裸指標使用的努力中, 它們是最明顯的部分了 ([§4.2.3](#423-移動語義)) 。

`shared_ptr` 是傳統的計數指標: 指向同一對象的所有指標共享一個計數器。當最後一個指向對象的共享指標被銷毀時, 被指向的對象也會被銷毀。這是一種簡單、通用且有效的垃圾收集形式。它能正確地處理非記憶體資源 ([§2.2.1](02.md#221-語言特性)) 。為了正確處理環形資料結構, 還需要有 `weak_ptr`; 不過, 這往往不是最好的做法。人們常常簡單地使用 `shared_ptr` 來安全地從工廠函數返回資料: 

```cpp
shared_ptr<Blob> make_Blob(Args a)
{
    auto p = shared_ptr<Blob>(new Blob(a));
    // ... 把很多好東西填到 *p ...
    return p;
}
```

當把對象移出函數時, 引用計數會從 1 變到 2 再變回 1。在多執行緒程式中, 這通常是涉及到同步的緩慢操作。另外, 粗率地使用和/或實現引用計數, 會增加分配和回收的開銷。

正如預期的那樣, `shared_ptr` 很快就流行起來, 並在有些地方被嚴重濫用。因此, 後來我們提供了不引入額外開銷的 `unique_ptr`。`unique_ptr` 對它所指的對象擁有獨占的所有權, 並會在自身被銷毀的時候把指向的對象也簡單地 `delete` 掉。

```cpp
unique_ptr<Blob> make_Blob(Args a)
{
    auto p = unique_ptr<Blob>(new Blob(a));
    // ... 把很多好東西填到 *p ...
    return p;
}
```

`shared_ptr` 和 `weak_ptr` 是 Peter Dimov 的工作成果 [Dimov et al. 2003]。Howard Hinnant 貢獻的 `unique_ptr` 是對 C++98 的 `auto_ptr` 的改進 [Hinnant et al. 2002]。考慮到 `unique_ptr` 是 `auto_ptr` 的即插即用式的替代品, 這提供了從標準中 (最終) 刪除有缺陷的功能的難得機會。資源管理指標跟移動語義、完美轉發及右值引用的工作密切相關 ([§4.2.3](#423-移動語義)) 。

資源管理指標被廣泛地用於持有對象, 以便異常 (及類似的情況) 不會導致資源泄漏 ([§2.2](02.md#22-第二個十年)) 。例如: 

```cpp
void old_use(Args a)
{
    auto q = new Blob(a);
    // ...
    if (foo) throw Bad();  // 會泄漏
    if (bar) return;       // 會泄漏
    // ...
    delete q;    // 容易忘
}
```

顯式使用 `new` 和 `delete` 的舊方式容易出錯, 在現代 C++ 中已經不推薦使用 (例如, C++ 核心指南 ([§10.6](10.md#106-編碼指南)) ) 。現在我們可以這樣寫: 

```cpp
void newer_use(Args a)
{
    auto p = unique_ptr<Blob>(new Blob(a));
    // ...
    if (foo) throw Bad();  // 不會泄漏
    if (bar) return;       // 不會泄漏
    // ...
}
```

這種寫法更簡短、更安全, 迅速就流行開去。不過, “智能指標”仍然被過度使用: “它們的確智能, 但它們仍然是指標。”除非我們確實需要指標, 否則, 簡單地使用局部變數會更好: 

```cpp
void simplest_use(Args a)
{
    Blob b(a);
    // ...
    if (foo) throw Bad(); // 不會泄漏
    if (bar) return;      // 不會泄漏
    // ...
}
```

智能指標用於表示資源所有權的主要用途是物件導向編程, 其中指標 (或引用) 用於訪問對象, 而對象的確切型別在編譯時並不知道。

### 4.2.5 統一初始化

出於歷史原因, C++ 有多種初始化的寫法, 而它們的語義有驚人的不同。

從 C 語言中, C++ 繼承了三種初始化形式, 並添加了第四種形式: 

```cpp
int x;              // 預設初始化 (僅適用於靜態變數) 
int x = 7;          // 值初始化
int a[] = {7,8};    // 聚合初始化
string s;           // 由預設建構子初始化
vector<int> v(10);  // 由建構子初始化
```

用於初始化的概念既取決於要初始化的對象的型別, 也取決於初始化的上下文。這是一團亂麻, 而且人們也認識到這一點。比如, 為什麼可以用列表初始化內建陣列, 但卻不能初始化 `vector`? 

```cpp
int a[] = {7,8};        // 可以
vector<int> v = {7,8};  // 應該可以工作 (顯然, 但是沒有) 
```

上一個例子令我非常不舒服, 因為它違反了 C++ 的根本設計目標, 即為內建型別和使用者定義的型別提供同等的支援。特別是, 因為對陣列初始化有比 `vector` 更好的支援, 這會鼓勵人們使用容易出錯的內建陣列。

當 C++0x 的工作從 2002 年開始的時候, Daniel Gutson、Francis Glassborow、Alisdair Meredith、Bjarne Stroustrup 和 Gabriel Dos Reis 曾進行了許多討論和提議, 來解決其中一些問題。在 2005 年, Gabriel Dos Reis 和我提出了**統一初始化**的寫法, 該寫法可用於每種型別, 並且在程式中的任何地方都具有相同的含義 [Stroustrup and Dos Reis 2005b]。這種寫法有望大大簡化使用者程式碼並消除許多不易察覺的錯誤。該表示法是基于使用花括號的列表寫法。舉例來說: 

```cpp
int a = {5};            // 內建型別
int a[] {7,8};          // 陣列
vector<int> v = {7,8};  // 具有建構子的使用者定義的型別
```

花括號 (`{}`) 對於單個值是可選的, 並且花括號初始化器列表之前的 `=` 也是可選的。為了統一起見, 在許多 C++98 不允許使用花括號或者 `=` 初始化的地方都接受花括號樣式的初始化: 

```cpp
int f(vector<int>);
int i = f({1,2,3});  // 函數參數

struct X {
    vector<int> v;
    int a[];
    X() : v{1,2}, a{3,4} {}  // 成員初始化器
    X(int);
    // ...
}

vector<int>* p = new vector<int>{1,2,3,4};  // new 表達式
X x {};  // 預設初始化

template<typename T> int foo(T);
int z = foo(X{1});  // 顯式構造
```

其中許多的情形, 例如為使用 `new` 創建的對象提供初始化器列表, 乾脆就沒法使用以前的方式來完成。

可惜, 對於這一理想, 我們僅僅達到不完全的近似, 我們有的方案只能算大致統一。有些人發現, 使用 `{…}` 很彆扭, 除非 `…` 是同質對象的列表, 而其他人則堅持 C 語言中對聚合和非聚合的區分, 並且許多人擔心沒有顯式型別標記的列表會導致歧義和錯誤。例如, 以下寫法被認為是危險的, 不過最終還是被接受了: 

```cpp
struct S { string s; int i; };

S foo(S s)
{
    // ...
    return {string{"foo"},13};
}

S x = foo({string{"alpha"},12.3});
```

在一種情況下, 對統一寫法的追求被一種慣用法擊敗。考慮: 

```cpp
vector<int> v1(10);          // 10 個元素
vector<int> v2 {10};         // 10 個元素還是 1 個值為 10 的元素? 
vector<int> v3 {1,2,3,4,5};  // 擁有 5 個元素的 vector
```

使用像 `vector<int> v1(10)` 的指定大小的初始化器的程式碼有數百萬行, 而從基本原則上來說, `vector<int> v2 {10}` 確實是模棱兩可的。假如是在一門新的語言中, 我不會使用普通的整數來表示大小, 我會為此指定一種特定的型別 (比如 `Size` 或 `Extent`) ; 舉例來說: 

```cpp
vector<int> v1 {Extent{10}};  // 10 個元素, 預設值為 0
vector<int> v2 {10};          // 1 個元素, 值為 10
```

但是, C++ 並不是一門新語言, 因此我們決定, 在建構子中進行選擇時優先選擇初始化器列表解釋。這使 `vector<int> v2 {10}` 成為具有一個元素的 `vector`, 並且使 `{…}` 初始化器的解釋保持一致。但是, 當我們想要避免使用初始化器列表建構子時, 這就迫使我們使用 `(…)` 寫法。

初始化的問題之一正在於, 它無處不在, 因此基本上所有程式和語言規則的問題都會在初始化上下文中體現出來。考慮: 

```cpp
int x = 7.2;  // 傳統的初始化
int y {7.2};  // 花括號初始化
```

從大約 1974 年將浮點數引入 C 語言以來, `x` 的值就是 `7`; 也就是說, `7.2` 被隱式截斷, 從而導致訊息丟失。這是錯誤的來源。花括號初始化不允許窄化轉換 (此處為截斷) 。很好, 但是升級舊程式碼變得更加困難: 

```cpp
double d = 7.2;
int x = d;   // 可以: 截斷
int y {d};   // 錯誤
```

這是一個常見問題的例子。人們想要一條簡單的升級路徑, 但是除非需要做出一些努力和更改, 否則一次非常簡單的升級的結果是, 舊的問題和錯誤得以保留。改善一門廣泛使用的語言比我們一般想像的要難。

經過許多激烈的辯論和許多修改 (並非其中每一項我都認為是改進) , 統一初始化在 2008 年被批准進入 C++0x [Stroustrup 2008b]。

與以往一樣, 寫法是一個有爭議的問題, 但是最終我們同意有一個標準庫型別的 `initializer_list` 用作初始化器列表建構子的參數型別。舉例來說: 

```cpp
template<typename T> class vector {
public:
    vector(initializer_list<T>);  // 初始化器列表建構子
    // ...
};

vector<int> v3 {1,2,3,4,5};  // 具有 5 個元素的 vector
```

令人遺憾的是, 統一初始化 (`{}`——初始化) 的使用並不像我期望的那樣廣泛。人們似乎更喜歡熟悉的寫法和熟悉的缺陷。我似乎陷入了 N+1 問題: 你有 N 個不兼容和不完整的解決方案, 因此添加了一個新的更好的解決方案。不幸的是, 原始的 N 個解決方案並沒有消失, 所以你現在有了 N+1 個解決方案。公平地說, 有一些細微的問題超出了本文的範圍, 這些問題只是在 C++14、C++17 和 C++20 中被逐步補救。我的印象是, 泛型編程和對更簡潔的表示法的推進正在慢慢增加統一初始化的吸引力。所有標準庫容器 (如 `vector`) 都有初始化器列表建構子。

### 4.2.6 `nullptr`

在 C 和 C++ 中, 如果將字面量 `0` 賦值給指標或與指標比較時它表示空指標。更令人困惑的是, 如果將任何求值為零的整數常數表達式賦值給指標或與指標比較時它也表示空指標。例如: 

```cpp
int* p = 99-55-44; // 空指標
int* q = 2;        // 錯誤: 2 是一個 int, 而不是一個指標
```

這使很多人感到煩惱和困惑, 因此有一個標準庫macro  `NULL` (從 C 中採用) , 它在標準 C++ 中定義為 `0`。某些編譯器會對 `int* p = 0` 提出警告; 但是我們仍然沒法為函數針對指標和整數重載而避免 `0` 的歧義。

這很容易通過給空指標命名來解決, 但是不知何故沒有人能提出一份人們能達成一致的提議。在 2003 年的某個時候, 我正通過電話參加一個會議, 討論如何給空指標命名。如 `NULL`、`null`、`nil`、`nullptr` 和 `0p` 等建議名都是備選方案。照舊, 那些簡短而“漂亮”的名字已經被使用了成千上萬次, 因此不能在不破壞數百萬行程式碼的情況下使用。我聽了數十次這樣的討論, 有點厭煩了, 只是在似聽非聽。人們說到 null pointer, null ptr, nullputter 的變體。我醒過來說: “你們都在說 `nullptr`。我想我沒有在程式碼中看到過它”。

Herb Sutter 和我寫下了該提案 [Sutter and Stroustrup 2003], 該提案在 2007 年相對容易地通過了 (僅僅進行了四次小修訂後) , 所以現在我們可以說: 

```cpp
int p0 = nullptr;
int* p1 = 99-55-44;  // 可以, 為了兼容性
int* p2 = NULL;      // 可以, 為了兼容性

int f(char*);
int f(int);

int x1 = f(nullptr); // f(char*)
int x2 = f(0);       // f(int)
```

我對 `nullptr` 的發音是“null pointer”。

我仍然認為如能將macro  `NULL` 定義為 `nullptr` 可以消除一類重要的問題, 但委員會認為這一改變過于激進。

### 4.2.7 `constexpr` 函數

在 2003 年, Gabriel Dos Reis 和我提出了用於在 C++ 中進行常數表達式求值的一種根本不同且明顯更好的機制 [Dos Reis 2003]。人們當時使用 (無型別的) macro 和貧乏的 C 語言定義的常數表達式。另一些人則開始使用模板元編程來計算值 ([§10.5.2](10.md#1052-元編程)) 。“這既乏味又容易出錯” [Dos Reis and Stroustrup 2010]。我們的目標是

- 讓編譯期計算達到型別安全
- 一般來說, 通過將計算移至編譯期來提高效率
- 支援嵌入式系統編程 (尤其是 ROM) 
- 直接支援元編程 (而非**模板**元編程 ([§10.5.2](10.md#1052-元編程)) ) 
- 讓編譯期編程與“普通編程”非常相似

這個想法是簡單的: 允許在常數表達式中使用以 `constexpr` 為首碼的函數, 還允許在常數表達式中使用簡單使用者定義型別, 叫字面量型別。字面量型別基本上是一種所有運算都是 `constexpr` 的型別。

考慮這樣一個應用, 為了提高效率、支援 ROM 或可靠性, 我們想使用一套單位制 [Dos Reis and Stroustrup 2010]: 

```cpp
struct LengthInKM {
    constexpr explicit LengthInKM(double d) : val(d) { }
    constexpr double getValue() { return val; }
private:
    double val;
};

struct LengthInMile {
    constexpr explicit LengthInMile(double d) : val(d) { }
    constexpr double getValue() { return val; }
    constexpr operator LengthInKM() { return LengthInKM(1.609344 * val); }
private:
    double val;
};
```

有了這些, 我們可以製作一個常數表, 而不必擔心單位錯誤或轉換錯誤: 

```cpp
LengthInKM marks[] = { LengthInMile(2.3), LengthInMile(0.76) };
```

傳統的解決方案要麼需要更多的運行時間, 要麼需要程式員在草稿紙上算好值。我對單位制的興趣是由 1999 年的火星氣候探測者號的失事激發的, 事故原因是單位不匹配沒有被發現 [Stephenson et al. 1999]。

`constexpr` 函數可以在編譯期進行求值, 因此它無法訪問非本地對象 (它們在編譯時還不存在) , 因此 C++ 獲得了一種純函數。

為什麼我們要求程式員應該使用 `constexpr` 來標記可以在編譯期執行的函數? 原則上, 編譯器可以弄清楚在編譯期可以計算出什麼, 但是如果沒有標註, 使用者將受制於各種編譯器的聰明程度, 並且編譯器需要將所有函數體“永遠”保留下來, 以備常數表達式在求值時要用到它們。我們選擇 `constexpr` 一詞是因為它足夠好記, 但又“足夠奇怪”而不會破壞現有程式碼。

在某些地方, C++ 需要常數表達式 (例如, 陣列邊界和 case 標籤) 。另外, 我們可以通過將變數聲明為 `constexpr` 來要求它在編譯期被初始化: 

```cpp
constexpr LengthInKM marks[] = { LengthInMile(2.3), LengthInMile(0.76) };

void f(int x)
{
    int y1 = x;
    constexpr int y2 = x;   // 錯誤: x 不是一個常數
    constexpr int y3 = 77;  // 正確
}
```

早期的討論集中在性能和嵌入式系統的簡單範例上。直到後來 (大約從 2015 年開始) , `constexpr` 函數才成為元編程的主要支柱 ([§10.5.2](10.md#1052-元編程)) 。C++14 允許在 `constexpr` 函數中使用局部變數, 從而支援了循環; 在此之前, 它們必須是純函數式的。C++20 (最終, 在首次提出後約 10 年) 允許將字面型別用作值模板參數型別 [Maurer 2012]。因此, C++20 將非常接近最初的目標 (1979 年) , 即在可以使用內建型別的地方也都可以使用使用者定義的型別 ([§2.1](02.md#21-第一個十年)) 。

`constexpr` 函數很快變得非常流行。它們遍佈于 C++14、C++17 和 C++20 標準庫, 並且不斷有相關建議, 以求在 `constexpr` 函數中允許更多的語言構造、將 `constexpr` 應用於標準庫中的更多函數, 以及為編譯期求值提供更多支援 ([§9.3.3](09.md#933-編譯期計算支援)) 。

但是, `constexpr` 函數進入標準並不容易。它們一再被認為是無用和無法實現的。實現 `constexpr` 函數顯然需要改進較老的編譯器, 但是很快, 所有主要編譯器的作者都證明了“無法實現”的說法是錯誤的。關於 `constexpr` 的討論是有史以來最激烈、最不愉快的。讓初始版本通過標準化流程 [Dos Reis and Stroustrup 2007] 花費了四年的時間, 而完整地完成又花了十二年的時間。

### 4.2.8 使用者定義字面量

“使用者定義字面量”是一個非常小的功能。但是, 它合乎我們的總體目標, 即讓使用者定義型別得到和內建型別同等的支援。內建型別有字面量, 例如, `10` 是整數, `10.9` 是浮點數。我試圖說服人們, 對於使用者定義型別, 顯式地使用建構子是等價的方式; 舉例來說, `complex<double>(1.2,3.4)` 就是 `complex` 的字面量等價形式。然而, 許多人認為這還不夠好: 寫法並不傳統, 而且不能保證建構子在編譯期被求值 (儘管這還是早年間的事) 。對於 `complex`, 人們想要 `1.2+3.4i`。

與其他問題相比, 這似乎並不重要, 所以幾十年來什麼都沒有發生。2006 年的一天, David Vandevoorde (EDG) 、Mike Wong (IBM) 和我在柏林的一家中餐館吃了一頓豐盛的晚餐。我們在餐桌邊聊起了天, 於是一個設計浮現在一張餐巾紙上。這個討論的起因是 IBM 的一項十進制浮點提案中對尾碼的需求, 該提案最終成了一個獨立的國際標準 [Klarer 2007]。在大改後, 該設計在 2008 年成為**使用者定義字面量** (通常稱為 UDL) [McIntosh et al. 2008]。當時讓 UDL 變得有趣的重要發展是 `constexpr` 提案的進展 ([§4.2.7](#427-constexpr-函數)) 。有了它, 我們可以保證編譯期求值。

照例, 找到一種可接受的寫法是一個問題。我們決定使用晦澀的 `operator""` 作為字面量運算符 (literal operator) 的寫法是可以接受的, 畢竟 `""` 是一個字面量。然後, `""x` 是後面跟着尾碼 `x` 的字面量。這樣一來, 要定義一個用於 `complex` 數的 `Imaginary` 型別, 我們可以定義: 

```cpp
constexpr Imaginary operator""i(long double x) { return Imaginary(x); }
```

現在, `3.4i` 是一個 `Imaginary`, 而 `1.2+3.4i` 是 `complex<double>(1.2,3.4)`。任務完成! 

這一功能的語言技術細節相當古怪, 但我認為對於一個相對很少使用的特性來說, 這是合理的。即使在大量使用 UDL 時, 字面量運算符的定義也很少。最重要的是尾碼的優雅和易用性。對於許多型別, 重要的是可以在編譯時完成從內建型別到使用者定義型別的轉換。

很自然, 人們使用 UDL 來定義許多有用的型別的字面量, 有些來自標準庫 (例如, `s` 代表 秒, `s` 代表 `std::string`) 。關於支援二進制字面量的討論, Peter Sommerlad (HSR) 提出了我認為的“最佳濫用規則”獎的候選方案: 適當地定義 `operator""_01(long int)`, 於是 `101010_01` 就成了個二進制字面量! 當驚訝和笑聲平息下來後, 委員會決定在語言本身裡定義二進制字面量並使用 `0b` 作為首碼, 表示“binary” (例如 `0b101010`) , 類似於使用 `0x` 表示“hexadecimal” (例如 `0xDEADBEEF`) 。

### 4.2.9 原始字元串字面量

這是一個罕見的簡單特性, 它的唯一目的是為容易出錯的寫法提供一種替代方法。和 C 一樣, C++ 使用反斜杠作為轉義字元。這意味着要在字元串字面量中表示反斜杠, 你需要使用雙反斜杠 (`\\`) , 當你想在字元串中使用雙引號時, 你需要使用 `\"`。然而, 通常的正則表達式模式廣泛使用反斜杠和雙引號, 所以模式很快變得混亂和容易出錯。考慮一個簡單的例子 (美國郵政編碼) : 

```cpp
regex pattern1 {"\\w{2}\\s*\\d{5}(-\\d{4})?"}; // 普通字元串字面量

regex pattern2 {R"(\w{2}\s*\d{5}(-\d{4})?)"};  // 原始字元串字面量
```

這兩種模式是相同的。**原始字元串字面量** `R"(…)"` 的括號可以精調以容納更複雜的模式, 但是當你使用正則表達式 ([§4.6](#46-c11標準庫組件)) 時, 最簡單的版本就足夠了, 而且非常方便。當然, 提供原始字元串字面量是一個小細節, 但是 (類似於數字分隔符 ([§5.1](05.md#51-數字分隔符)) ) , 深受需要大量使用字面量的人們的喜愛。

原始字元串字面量是 Beman Dawes 在 2006 年 [Dawes 2006] 基于使用 Boost.Regex [Maddock 2002] 的經驗而提出來的。

### 4.2.10 屬性

在程式中, 屬性提供了一種將本質上任意的訊息與程式中的實體相關聯的方法。例如: 

```cpp
[[noreturn]] void forever()
{
    for (;;) {
        do_work();
        wait(10s);
    }
}
```

屬性 `[[noreturn]]` 通知編譯器或其他工具 `forever()` 永遠不會返回, 這樣它就可以抑制關於缺少返回的警告。屬性用 `[[…]]` 括起來。

屬性最早是在 2007 年由庫工作組的負責人 Alisdair Meredith [Meredith 2007] 提出來的, 目的是消除專有屬性寫法 (例如 `__declspec` 和 `__attribute__`) 之間的不兼容性, 這種不兼容性會使庫實現更加複雜。對此, Jens Maurer 和 Michael Wong 對問題進行了分析, 並提出了 `[[…]]` 語法, 方案是基于 Michael 為 IBM 的 XL 編譯器所做的實現 [Maurer and Wong 2007]。除了對大量不可移植的實踐進行標準化之外, 這還將允許用更少的關鍵字來完成語言擴展, 而新的關鍵字總是有爭議的。

該提案提到了可能的使用: 覆蓋虛函數的明確語法, 動態庫, 使用者控制的垃圾收集, 執行緒本地存儲, 控制對齊, 標識“簡舊資料” (POD) 類, default 和 delete 的函數, 強型別列舉, 強型別 typedef, 無副作用的純函數, final 覆蓋, 密封類, 對並發性的細粒度控制, 運行期反射支援, 及輕量級契約編程主持。在早期的討論中還提到了更多。

“屬性”當然是一個使某些事情變得更簡單的特性, 但我不確定它是否鼓勵了良好的設計, 或者它簡化的“事情”總是能產生最大的好處。我可以想象屬性打開了閘門, 放進來一大堆不相關的、不太為人們瞭解的、次要的特性。任何人都可以為編譯器添加一個屬性, 並遊說各處採用它, 而不是向 WG21 提出一個特性。許多程式員就是喜歡這些小特性。不需要引入關鍵字和修改語法能降低門檻。但同樣能造成不可避免的對特性交互關注度不夠, 造成重疊而不兼容的類似特性出現在不同的編譯器中。這種情況在私有擴展中已經發生過了, 但我認為它們是不可避免的、局部的, 而且往往是暫時的。

為了限制潛在的損害, 我們決定屬性應該意味着不改變程式的語義。也就是說, 忽略屬性, 編譯器不會有任何危害。多年來, 這條“規則”几乎奏效。大多數標準屬性——儘管不是全部——沒有語義效果, 即使它們有助于優化和錯誤檢測。

最後, 大多數最初那些建議的對屬性的使用都通過普通的語法和語言規則來解決。

C++11 增加了標準屬性 `[[noreturn]]` 和 `[[carries_dependency]]`。

C++17 增加了 `[[fallthrough]]`、`[[nodiscard]]` 和 `[[maybe_unused]]`。

C++20 增加了 `[[likely]]`、`[[unlikely]]`、`[[deprecated(message)]]`、`[[no_unique_address]]` 和 `[[using: …]]`。

我仍然看到屬性擴散是一個潛在的風險, 但到目前為止, 水閘還沒有打開。C++ 標準庫大量使用了屬性; `[[nodiscard]]` 屬性尤其受歡迎, 特別用來防止由於沒有使用本身是資源句柄的返回值而造成的潛在資源泄漏。

屬性語法被用於 (失敗的) C++20 契約設計 ([§9.6.1](09.md#961-契約)) 。

### 4.2.11 垃圾收集

從 C++ 的早期開始, 人們就考慮**可選**的垃圾收集 (對於“可選”有各種定義) [Stroustrup 1993, 2007]。經過一番爭論, C++11 為 Mike Spertus 和 Hans-J. Boehm 設計的保守垃圾收集器提供了一個介面 [Boehm and Spertus 2005; Boehm et al. 2008]。然而, 很少有人留意到這一點, 更少有人使用了垃圾收集 (儘管有好的收集器可用) 。設計的方法是 [Boehm et al. 2008]: 

> 同時支援垃圾收集實現和基于可達性的泄漏檢測器。這是通過把“隱藏指標”的程式定為未定義行為來實現的; 舉例來說, 將指標與另一個值進行異或運算, 然後將它轉換回普通指標並對其進行解引用就是一種隱藏行為。

這項工作造福了 C++ 語義的精確規範, 並且 C++ 中也存在一些對垃圾收集的使用 (例如, 在 Macaulay2 中 [Eisenbud et al. 2001; Macaulay2 2005–2020]) 。然而, 垃圾收集器不處理非記憶體資源, 而 C++ 社區通常選擇使用資源管理指標 ([§4.2.4](#424-資源管理指標)) 和 RAII ([§2.2.1](02.md#221-語言特性)) 二者的組合。

## 4.3 C++11: 改進對泛型編程的支援

泛型編程 (及其產物模板元編程 ([§10.5.2](10.md#1052-元編程)) ) 在 C++ 98 中迅速輕鬆地獲得了成功。它的使用對語言造成了嚴重的壓力, 而不充分的語言支援導致了巴洛克式矯揉造作的編程技巧和可怕的錯誤消息。這證明了泛型編程和元編程的實用性, 許多明智的程式員為了獲得其好處而甘願承受其痛苦。這些好處是

- 超越以 C 風格或物件導向風格所可能獲得的靈活性
- 更清晰的程式碼
- 更細的靜態型別檢查粒度
- 效率 (主要來自內聯、讓編譯器同時查看多處的原始碼, 以及更好的型別檢查) 

C++11 中支援泛型編程的主要新特性有: 

- [§4.3.1](#431-lambda-表達式): lambda 表達式
- [§4.3.2](#432-變參模板): 變參模板
- [§4.3.3](#433-別名): `template` 別名
- [§4.3.4](#434-tuple): `tuple`
- [§4.2.5](#425-統一初始化): 統一初始化

在 C++11 中, 概念本應是改進支援泛型編程的核心, 但這並沒有發生 ([§6.2.6](06.md#626-哪裡出錯了)) 。我們不得不等到 C++20 ([§6.4](06.md#64-c20-概念)) 。

### 4.3.1 lambda 表達式

BCPL 允許將程式碼塊作為表達式, 但是為了節省編譯器中的空間, Dennis Ritchie 沒有在 C 中採用這個特性。我在這點上遵循了 C 的做法, 但是添加了 `inline` 函數, 從而 (重新) 得到在沒有函數呼叫的開銷下執行程式碼的能力。不過, 這仍然不能提供以下能力

- 把程式碼寫在需要它的那個準確位置上 (通常作為函數參數) 。
- 從程式碼內部訪問程式碼的上下文。

在 C++98 的開發過程中, 曾有人提議使用局部函數來解決第二點, 但被投票否決了, 因為這可能成為缺陷的來源。

C++ 不允許在函數內部定義函數, 而是依賴于在類內部定義的函數。這使得函數的上下文可以表示為類成員, 因而函數對象變得非常流行。**函數對象**只是一個帶有呼叫運算符 (`operator()()`) 的類。這曾是一種非常高效和有效的技術, 我 (和其他人) 認為有名字的對象比未命名的操作更清晰。然而, 只有當我們可以在某樣東西使用的上下文之外給它一個合理的名稱, 特別是如果它會被使用多次時, 這種清晰度上的優勢才會表現出來。

2002 年, Jaakko Järvi 和 Gary Powell 編寫了 Boost.Lambda 庫 [Järvi and Powell 2002] 這讓我們可以寫出這樣的東西

```cpp
find_if(v.begin(), v.end(), _1<i);  // 查找值小於 i 的元素
```

這裡, `_1` 是程式碼片段 `_1<i` 的某個第一個實參的名稱, 而 `i` 是表達式所在作用域 (enclosing scope) 中的一個變數。`_1<i` 展開為一個函數對象, 其中 `i` 被綁定到一個引用, `_1` 成為 `operator()()` 的實參: 

```cpp
struct Less_than {
    int& i;
    Less_than(int& ii) :i(ii) {}  // 綁定到 i
    bool operator()(int x) { return x<i; }  // 跟參數比較
}
```

lambda 表達式庫是早期模板元編程的典範 ([§10.5.2](10.md#1052-元編程)) , 非常方便和流行。不幸的是, 它的效率並不特別高。多年來, 我追蹤了它相對於手工編碼的同等實現的性能, 發現它的開銷是後者的 2.5 倍且這種差距相當一致。我不能推薦一種方便但卻很慢的東西。這樣做會損害 C++ 作為產生高效程式碼的語言的聲譽。顯然, 這種慢在一定程度上是由於優化不當造成的, 但出於這個和其他原因, 我們有一群人在 Jaakko Järvi 領導下決定將 lambda 表達式作為一種語言特性 [Willcock et al. 2006] 來提出。舉例來說: 

```cpp
template<typename Oper>
void g(Oper op)
{
    int xx = op(7);
    // ...
}

void f()
{
    int y = 3;
    g(<>(int x) -> int {return x + y;});  // 以 lambda 表達式作為參數呼叫 g()
}
```

這裡, `xx` 會變成 `3+7`。

`<>` 是 lambda 表達式引導器。我們不敢提出一個新的關鍵詞。

這一提議引起了相當多的興奮和許多熱烈的討論: 

- 語法應該是富有表現力的還是簡潔的? 
- lambda 表達式可以從哪個作用域引用什麼名字? [Crowl 2009]。
- 從 lambda 表達式生成的函數對象應該是可變的嗎? 預設情況下不是。
- lambda 表達式能是多態的嗎? 到 C++14 才可以 ([§5.4](05.md#54-泛型-lambda-表達式)) 。
- lambda 表達式的型別是什麼? 獨有的型別, 除非它基本上是一個局部函數。
- lambda 表達式可以有名字嗎? 不。如果你需要一個名字, 就把它賦給一個變數。
- 名稱是由值綁定還是由引用綁定? 你來選擇。
- 變數可以移動到 lambda 表達式中 (相對於複製) 嗎? 到 C++14 才可以 ([§5](05.md#5-c14完成-c11)) 。
- 語法是否會與各種非標準擴展發生衝突?  (不嚴重) 。

到 2009 年 lambda 表達式被批准時, 語法已經發生了變化, 變得更加合乎慣例 [Vandevoorde 2009]: 

```cpp
void abssort(float* x, unsigned N)
{
    std::sort(x, x+N,
        [](float a, float b) { return std::abs(a) < std::abs(b); }
             );
}
```

從 `<>` 切換到 `[]` 是由 Herb Sutter 建議並由 Jonathan Caves 實現的。這種變化在一定程度上是由於需要一種簡單的方法來指定 lambda 表達式可以使用周圍作用域中的哪些名稱。Herb Sutter 回憶道: 

> 我的並行演算法項目需要 lambda 表達式, 這是我的動機......看到 EWG 改採用的 lambda 表達式那實在醜到爆的用法, 以及從語法一致性/乾淨性的角度來看極為糟糕的設計 (例如, 捕獲出現在兩個分開的位置, 語法元素使用不一致, 順序錯誤——因為“建構子”元素應該先出現然後才是呼叫“運算符”元素, 以及其他一些小問題) 。

預設情況下, lambda 表達式不能引用在本地環境的名字, 所以它們只是普通的函數。然而, 我們可以指定 lambda 表達式應該從它的環境中“捕獲”一些或所有的變數。回調是 lambda 表達式的一個常見用例, 因為操作通常只需要寫一次, 並且操作會需要安裝該回調的程式碼上下文中的一些訊息。考慮: 

```cpp
void test()
{
    string s;
    // ... 為 s 計算一個合適的值 ...
    w.foo_callback([&s](int i){ do_foo(i,s); });
    w.bar_callback([=s](double d){ return do_bar(d,s); });
}
```

`[&s]` 表示 `do_foo(i,s)` 可以使用 `s`, `s` 通過引用來傳遞 (“捕獲”) 。`[=s]` 表示 `do_bar(d,s)` 可以使用 `s`, `s` 是通過值傳遞的。如果回調函數在與 `test` 相同的執行緒上被呼叫, `[&s]` 捕獲可能效率更高, 因為 `s` 沒有被覆制。如果回調函數在不同的執行緒上被呼叫, `[&s]` 捕獲可能是一個災難, 因為 `s` 在被使用之前可能會超出作用域; 這種情況下, 我們想要一份副本。一個 `[=]` 捕獲列表意味着“將所有局部變數複製到 lambda 表達式中”。而一個 `[&]` 捕獲列表意味着“lambda 表達式可以通過引用指代所有局部變數”, 並意味着 lambda 表達式可以簡單地實現為一個局部函數。事實證明, 捕獲機制的靈活性非常有價值。捕獲機制允許控制可以從 lambda 表達式引用哪些名稱, 以及如何引用。這是對 1990 年代人們擔心局部函數容易出錯的一種回答。

lambda 表達式的實現基本上是編譯器構建一個合適的函數對象並傳遞它。捕獲的局部變數成為由建構子初始化的成員, lambda 表達式的程式碼成為函數對象的呼叫運算符。例如, `bar_callback` 變成: 

```cpp
struct __XYZ {
    string s;
    __XYZ(const string& ss) : s{ss} {}
    int operator()(double d) { return do_bar(d,s); }
};
```

lambda 表達式的返回型別可以從它的返回語句推導出來。如果沒有 return 語句, lambda 表達式就不會返回任何東西。

我把 lambda 表達式歸類為對泛型編程的支援, 因為最常見的用途之一——也是主要的動機——是用作 STL 演算法的參數: 

```cpp
// 按降序排序: 
sort(v.begin(),v.end(),[](int x, int y) { return x>y; });
```

因此, lambda 表達式顯著地增加了泛型編程的吸引力。

在 C++11 之後, C++14 添加了泛型 lambda 表達式 ([§5.4](05.md#54-泛型-lambda-表達式)) 和移動捕獲 ([§5](05.md#5-c14完成-c11)) 。

### 4.3.2 變參模板

2004 年, Douglas Gregor、Jaakko Järvi 和 Gary Powell (當時都在印第安納大學) 提出了**變參模板** [Gregor et al. 2004] 的特性, 用來: 

> 直接解決兩個問題: 
> - 不能實例化包含任意長度參數列表的類模板和函數模板。
> - 不能以型別安全的方式傳遞任意個參數給某個函數

這些都是重要目標, 但我起初發現其解決方案過于複雜, 記法太過晦澀, 按我的品味其編程風格又太遞迴。不過在 Douglas Gregor 于 2004 年做的精綵演示之後, 我改變了主意並全力支援這項提案, 幫助它在委員會順利通過。我被說服的部分原因是變參模板和當時的變通方案在編譯時間上的對比測量。編譯時間過長的問題隨模板元編程的大量使用 ([§10.5.2](10.md#1052-元編程)) 變得越來越嚴重, 對此變參模板是一項重大 (有時是 20 倍) 改進。可惜, 變參模板越變越流行, 也成了 C++ 標準庫中必需的部分, 以至編譯時間的問題又出現了。不過, 成功的懲罰 (在當時) 還是在遙遠的將來。

變參模板的基本思路是, 遞迴構造一個**參數包**, 然後在另一個遞迴過程來使用它。遞迴技巧是必須的, 因為參數包中的每個元素都有它自己的型別 (和大小) 。

考慮 `printf` 的一種實現, 能夠處理可由標準庫 iostream 的輸出運算符 `<<` 輸出的每種型別 [Gregor 2006]: 

> 為了創建型別安全的 `printf()`, 我們採用以下策略: 寫出字元串直至碰到第一個格式說明符, 按格式打印相應的值, 然後遞迴呼叫 `printf()` 來打印字元串剩下部分和其餘各值。

```cpp
template<typename T, typename... Args>
void printf(const char* s, const T& value, const Args&... args)
{
    while (*s) {
        if (*s == '%' && *++s != '%') { // 忽略 % 後的字元: 
                                        // 我們已經知道要打印的型別了! 
            std::cout << value;
            return printf(++s, args...);
        }
        std::cout << *s++;
    }
    throw std::runtime error("extra arguments provided to printf");
}
```

這裡 `<typename T, typename... Args>` 指定了一個傳統的列表, 有頭 (`T`) 和尾 (`Args`) 。每次呼叫會處理頭, 然後以尾為參數來呼叫自身。普通字元會被簡單打印, 而格式符 `%` 則表示某個參數要被打印了。Doug (當時他住在印第安納州) 提供了一個測試例子: 

```cpp
const char* msg = "The value of %s is about %g (unless you live in %s).\n";
printf(msg, std::string("pi"), 3.14159, "Indiana");
```

結果會打印

```
The value of pi is about 3.14159 (unless you live in Indiana).
```

這個實現的好處之一是, 和標準的 `printf` 不同, 使用者定義的型別也和內建型別一樣會得到正確處理。通過使用 `<<` 也避免了型別指示符和參數型別之間的不匹配, 比如 `printf("%g %c","Hello",7.2)`。

這個 `printf` 所展示的技巧是 C++20 `format` ([§9.3.7](09.md#937-格式化)) 的基礎之一。

變參模板的缺點是容易導致程式碼膨脹, 因為 N 個參數意味着模板的 N 次實例化。

### 4.3.3 別名

C 定義型別別名的機制是靠 `typedef`。例如: 

```cpp
typedef double (*pf)(int);   // pf 是一個函數指標, 該函數接受一個 int
                             // 返回一個 double
```

這是有點詰屈聱牙, 但是型別別名在 C 和 C++ 程式碼中非常有用, 使用非常普遍。從最初有 C++ 模板的時候, 人們就一直考慮是否可以有 **typedef 模板**; 如果可以, 它們應該是什麼樣子。2002 年時, Herb Sutter 提出一個方案 [Sutter 2002]: 

```cpp
template<typename A, typename B> class X { /* ... */ };
template<typename T> typedef X<T,int> Xi;  // 定義別名
Xi<double> Ddi;                            // 相當於 X<double, int>
```

在此基礎之上, 又經歷了冗長的郵件列表討論, Gabriel Dos Reis (當時在法國國立計算機及自動化研究院) 和 Matt Marcus (Adobe) 解決了特化相關的若干棘手問題, 並引入 David Vandevoorde 稱之為**別名模板**的簡化語法 [Dos Reis and Marcus 2003]。例如: 

```cpp
template<typename T, typename A> class MyVector { /* ... */};
template<typename T> using Vec = MyVector<T, MyAlloc<T> >;
```

其中的 `using` 語法, 即要引入的名字總是出現在前面, 則是我的建議。

我和 Gabriel Dos Reis 一道把這個特性推廣成一個 (几乎) 完整的別名機制, 並最終得到接受 [Stroustrup and Dos Reis 2003c]。即便不涉及模板, 它也給了人們一種記法上的選擇: 

```cpp
typedef double (*analysis_fp)(const vector<Student_info>&); 

using analysis_fb = double (*)(const vector<Student_info>&);
```

型別和模板別名是某些最有效的零開銷抽象及模組化技巧的關鍵。別名讓使用者能夠使用一套標準的名字而同時讓各種實現使用各自 (不同) 的實現技巧和名字。這樣就可以在擁有零開銷抽象的同時保持方便的使用者介面。考慮某通訊庫 (使用了 Concepts TS [Sutton 2017] 和 C++20 的簡化記法) 中的一個實例: 

```cpp
template<InputTransport Transport, MessageDecoder MessageAdapter>
class InputChannel {
public:
    using InputMessage = MessageAdapter::InputMessage<Transport::InputBuffer>;
    using MessageCallback = function<void(InputMessage&&)>;
    using ErrorCallback = function<void(const error_code&)>;
    // ...
};
```

概念和別名對於規模化地管理這樣的組合極有價值。

`InputChannel` 的使用者介面主要由三個別名組成, `InputMessage`、`MessageCallback` 和 `ErrorCallback`, 它們由模板的參數初始化而來。

`InputChannel` 需要初始化它的傳輸層, 該傳輸層由一個 `Transport` 對象表示。然而, `InputChannel` 不應該知道傳輸層的實現細節, 所以它不應直接初始化它的 `Transport` 成員。變參模板 ([§4.3.2](#432-變參模板)) 就派上了用場: 

```cpp
template<InputTransport Transport, MesssageDecoder MessageAdapter>
class InputChannel {
public:
    template<typename... TransportArgs>
        InputChannel(TransportArgs&&... transportArgs)
            : _transport {forward<TransportArgs>(transportArgs)... }
        {}
    // ...
    Transport _transport;
}
```

如果沒有變參模板, 就得定義出一個通用介面來初始化傳輸層, 或者得把傳輸層暴露給使用者。

這個漂亮的例子展示了如何把 C++11 的特性 (加上概念) 組合起來以優雅的零開銷方案解決一個困難問題。

### 4.3.4 `tuple`

C++98 有個 `pair<T,U>` 模板; 它主要用來返回成對的值, 比如兩個迭代器或者一個指標加上一個成功標誌。2002 年時, Jaakko Järvi 在參考 Haskell、ML、Python 和 Eiffel 後, 提議把這個思路進一步推廣, 變成 `tuple` (元組) [Järvi 2002]: 

> 元組是大小固定而成員型別可以不同的容器。作為一種通用的輔助工具, 它們增加了語言的表現力。舉幾個元組型別一般用法的例子: 
> - 作為返回型別, 用於需要超過一個返回型別的函數
> - 編組相關的型別或對象 (如參數列表中的各條目) 成為單個條目
> - 同時賦多個值

對於特定的設計意圖, 定義一個類, 並在裡面對成員進行合理命名、清晰表述成員間的語義關係, 通常會是最好的做法。Alisdair Meredith 在委員會內力陳以上觀點, 勸阻在介面中過度使用未命名的型別。然而, 當撰寫泛型程式碼時, 把多個值打包到一個元組中作為一個實體進行處理往往能簡化實現。元組對於不值得命名、不值得設計類的一些中間情況特別有用。

比如, 考慮一個只需返回三個值的矩陣分解: 

```cpp
auto SVD(const Matrix& A) -> tuple<Matrix, Vector, Matrix>
{
    Matrix U, V;
    Vector S;
    // ...
    return make_tuple(U,S,V);
};

void use()
{
    Matrix A, U, V;
    Vector S;
    // ...
    tie(U,S,V) = SVD(A); // 使用元組形式
}
```

在這裡, `make_tuple()` 是標準庫函數, 可以從參數中推導元素型別來構造 `tuple`, `tie()` 是標準庫函數, 可以把 `tuple` 的成員賦給有名字的變數。

使用 C++17 的結構化綁定 ([§8.2](08.md#82-結構化綁定)) , 上面例子可簡化為: 

```cpp
auto SVD(const Matrix& A) -> tuple<Matrix, Vector, Matrix>
{
    Matrix U, V;
    Vector S;
    // ...
    return {U,S,V};
};

void use()
{
    Matrix A;
    // ...
    auto [U,S,V] = SVD(A); // 使用元組形式和結構化綁定
}
```

進一步的記法簡化被提議加入 C++20 [Spertus 2018], 但沒來得及成功通過: 

```cpp
tuple SVD(const Matrix& A) // 從返回語句中推導出元組模板參數
{
    Matrix U, V;
    Vector S;
    // ...
    return {U,S,V};
};
```

為什麼 `tuple` 不是語言特性? 我不記得當時有人這麼問過, 儘管一定有人想到過這一點。長期以來 (自 1979 年) , 我們的策略就是, 如果能合理地將新特性以庫的形式加入 C++, 就不要以語言特性加入; 如果不能, 就要改進抽象機制使其成為可能。這一策略有顯而易見的優勢: 

- 通常對一個庫做試驗比對一個語言特性做試驗更容易, 這樣我們就更快地得到更好的反饋。
- 庫可以早在所有編譯器升級到支援新特性之前就得到嚴肅使用。
- 抽象機制 (類, 模板等) 上的改進, 能在眼前問題之外提供幫助。

`tuple` 以 Boost.Tuple 為基礎構建, 其實現之巧妙也足以讓眾人引以為傲。在這一特性上, 並沒有出現運行期效率方面的理由, 使我們去偏向一個語言實現而不是庫實現。這讓人頗為敬佩。

參數包就是一個擁有編譯器支援介面的元組的例子 ([§4.3.2](#432-變參模板)) 。

元組大量用於 C++ 和其他語言 (例如 Python) 交互的程式庫裡。

## 4.4 C++11: 提高靜態型別安全

依賴靜態型別安全有兩大好處: 

- 明確意圖
  - 幫助程式員直接表達想法
  - 幫助編譯器捕獲更多錯誤
- 幫助編譯器生成更好的程式碼。

第二點是第一點的結果。受 Simula 的啟發, 我對 C++ 的目標是要提供一個靈活可擴展的靜態型別系統。目的不僅是型別安全, 還要能夠直接表達細粒度的區別, 例如物理單位檢查 ([§4.2.7](#427-constexpr-函數)) 。一段只用了內建型別如整型和浮點型寫成的程式, 也算是型別安全但卻沒有由此帶來特別的安全優勢。那樣的程式碼沒有直接表達應用中的概念。特別需要指出, `int` 或者 `string` 几乎可以表達任何東西, 所以傳遞這樣的值就完全沒有給出被傳遞值的任何語義訊息。

C++11 中與型別安全直接相關的改進有: 

- 對於執行緒和鎖的型別安全介面——避免 POSIX 和 Windows 在並發程式碼中對 `void**` 及macro 的依賴 ([§4.1.2](#412-執行緒和鎖))
- 範圍 `for`——避免錯誤地指定範圍 ([§4.2.2](#422-範圍-for)) 
- 移動語義——解決指標的過度使用問題 ([§4.2.3](#423-移動語義)) 
- 資源管理指標 (`unique_ptr` 和 `shared_ptr` ([§4.2.4](#424-資源管理指標)) ) 
- 統一初始化——讓初始化更通用, 更一致, 更安全 ([§4.2.5](#425-統一初始化)) 
- `constexpr`——消除多處 (無型別和無作用域的) macro 的使用 ([§4.2.7](#427-constexpr-函數)) 
- 使用者定義的字面量——讓使用者定義型別更像內建型別 ([§4.2.8](#428-使用者定義字面量)) 
- `enum class`——消除一些涉及整型常數的弱型別做法
- `std::array`——避免內建陣列不安全地“退化”成指標

委員會一直收到建議, 應當通過禁止不安全特性 (例如, 廢棄像內建陣列和型別轉換這樣的 C 風格特性) 來改善型別安全。然而, 移除特性 (“取締”它們) 的嘗試一再失敗, 因為使用者無視移除的警告並堅持要求實現的提供者繼續支援這些特性。一個更可行的方式似乎是給使用者提供使用指南和實施指南的手段, 同時保持標準本身繼續和先前的版本兼容 ([§10.6](10.md#106-編碼指南)) 。

## 4.5 C++11: 支援對庫的開發

設計 C++ 基礎庫, 往往要在性能和易用性方面同 C++ 及其他語言的內置功能進行競爭。這時, 查找規則、重載決策、訪問控制、模板實例化規則等特性之中的微妙之處會組合起來, 產生強大的表達能力, 但同時也暴露出可怕的複雜性。

### 4.5.1 實現技巧

有些實現技巧實屬“黑魔法”, 不應當暴露給非專家。大部分程式員可以愉快地編寫多年好的 C++ 程式碼, 而不用瞭解這些複雜手段和神秘技巧。遺憾的是, 初學者們一擁而上去研究這些最可怕的特殊程式碼, 並從給別人 (經常是錯誤地) 解釋它們的過程中得到巨大的自豪感。博主和演講者們通過顯擺令人提心吊膽的例子抬高他們的名望。這是 C++ 語言複雜性名聲的一個主要來源。在其他語言中, 要麼不提供這樣的優化機會, 要麼手段被藏在了優化器內部。

我不能在此深入細節, 就只提一個技巧, 它在 C++11 的發展中作為關鍵技巧出現, 並在基于模板的庫 (包括 C++ 標準庫) 中廣為使用。它以奇怪的縮寫為人所知: **SFINAE** (Substitution Failure Is Not An Error, 替換失敗不是錯誤) 。

你如何表達一個若且唯若某個謂詞為真時才有的操作? 概念為 C++20 提供了這樣的支援 (GCC 自 2015 年開始支援) , 但在 21 世紀早期, 人們不得不依賴于晦澀的語言規則。例如: 

```cpp
template<typename T, typename U>
struct pair {
    T first;
    U second;
    // ...
    enable_if<is_copy_assignable<T>::value
              && is_copy_assignable<U>::value,pair&>::type
        operator=(const pair&);
    //...
};
```

這樣, 若且唯若 `pair` 的兩個成員都有拷貝賦值操作時 `pair` 才有拷貝賦值操作。這超乎尋常的醜陋, 但它對於定義和實現基礎庫也超乎尋常的有用——在概念還沒有出現時。

要點在於, 如果成員都有拷貝賦值, `enable_if<…,pair&>::type` 會成為一個普通的 `pair&`, 否則它的實例化就會失敗 (因為 `enable_if` 沒有為賦值提供一個返回型別) 。這裡 SFINAE 就起作用了: 替換失敗不是錯誤; 失敗的結果就如同整條聲明不曾出現一樣。

這裡的 `is_copy_assignable` 是一個 `type trait` (型別特徵) , C++11 提供了數十個這樣的特徵以便程式員在編譯期詢問型別的屬性。

`enable_if` 元函數由 Boost 開創並成為 C++11 的一部分。一個大致合理的實現: 

```cpp
template<bool B, typename T = void>
struct enable_if {}; // false 的情況: 裡面沒有 type

template<typename T>
struct enable_if<true, T> { typedef T type; }; // type 是 T
```

SFINAE 的精確規則非常微妙而難以駕馭, 但是在使用者的不斷壓力下, 它們在 C++11 的發展過程中變得越來越簡單和通用。SFINAE 的一個附帶收穫是, 它從內部顯著改善了編譯器, 因為編譯器必須能夠從失敗的模板實例化中進行無副作用的回退。這就大大阻止了編譯器對非本地狀態的使用。

### 4.5.2 元編程支援

二十一世紀的頭十年對於 C++ 元編程來說有點像是無法無天的美國西部拓荒時代, 新的技巧和應用在僅有基本模板機制支援的情況下被不斷嘗試。那些基本機制被反覆使用到令人痛苦。錯誤訊息可謂糟糕透頂, 編譯時間經常奇慢無比, 編譯器資源 (如記憶體、遞迴深度和標識符長度) 會輕易耗盡。同時, 人們紛紛重新發現同樣的問題, 並重新發明一些基本技巧。顯然, 我們需要更好的支援。改進嘗試採用了兩條 (至少理論上) 互補的路徑: 

- **語言**: 概念 ([§6](06.md#6-概念)) , 編譯期函數 ([§4.2.7](#427-constexpr-函數)) , lambda 表達式 ([§4.3.1](#431-lambda-表達式)) , 模板別名 ([§4.3.3](#433-別名)) , 以及更精確的模板實例化規範 ([§4.5.1](#451-實現技巧)) 。
- **標準庫**: `tuple` ([§4.3.4](#434-tuple)) , 型別特徵 ([§4.5.1](#451-實現技巧)) , 以及 `enable_if` ([§4.5.1](#451-實現技巧)) 。

遺憾的是, 概念在 C++11 ([§6.2](06.md#62-c0x-概念)) 中失敗了, 這給 (通常複雜得可怕而且容易出錯的) 權宜之計留下了生存空間, 典型情況會涉及型別特徵和 `enable_if` ([§4.5.1](#451-實現技巧)) 。

### 4.5.3 `noexcept` 規約

起初的異常設計沒有辦法表明某個異常可能會從某函數中拋出。我仍然認為那才是正確的設計。為了讓異常為 C++98 接納, 我們不得不加入異常規約, 來列舉一個函數會拋出那些異常 [Stroustrup 1993]。使用異常規約可選, 並會在運行期進行檢查。正如我擔心的那樣, 這帶來了維護的問題, 在展開路徑上對異常反覆檢查增加的運行期開銷, 還有原始碼膨脹。在 C++11 中, 異常規約被廢棄 [Gregor 2010], 而到了 C++17, 我們終於 (一致同意) 移除了異常規約這個特性。

一直有人希望能夠在編譯時檢查函數會拋出什麼異常。從型別理論的角度, 在小規模程式中, 在有高速編譯器和對程式碼完全控制的情況下, 那當然行得通。委員會一再拒絶這種想法, 原因是它不能擴展到由數十 (或更多) 組織維護的百萬行程式碼規模的程式上 [Stroustrup 1994]。參見 ([§7.4](07.md#74-型別系統的支援)) 。

沒有異常規約, 庫實現者們就要面對一個性能問題: 在許多重要場合, 一個庫實現者需要知道一個拷貝操作是否會拋異常。如果會, 就必須拿到一份拷貝以避免留下一個無效對象 (這樣會違犯異常保證 [Stroustrup 1993]) 。如果不會, 我們可以直接寫入到目標中。在這種場合, 性能的差別可以非常顯著, 而最簡單的異常規約 `throw()`, 什麼也不拋出, 在此可以幫助判斷。於是, 在異常規約被棄之不用並最終從標準中移除的時候, 我們基于 David Abrahams 和 Doug Gregor 的提案 [Abrahams et al. 2010; Gregor 2010; Gregor and Abrahams 2009] 引入了 `noexcept` 概念。

一個 `noexcept` 函數仍會被動態檢查。例如: 

```cpp
void do_something(int n) noexcept
{
    vector<int> v(n);
    // ...
}
```

如果 `do_something()` 拋異常, 程式會被終止。這樣操作恰好非常接近零開銷, 因為它簡單地短路了通常的異常傳播機制。參見 ([§7.3](07.md#73-noexcept-規約)) 。

還有一個條件版本的 `noexcept`, 用它可以寫出這樣的模板, 其實現依賴于某參數是否會拋異常。這是最初促成 `noexcept` 的用例。例如, 下面程式碼中, 若且唯若 `pair` 的兩個元素都有不拋異常的移動建構子時, `pair` 的移動建構子才會聲明不拋異常: 

```cpp
template<typename First, typename Second>
class pair {
    // ...
    template <typename First2, typename Second2>
    pair(pair<First2, Second2>&& rhs)
        noexcept(is_nothrow_constructible<First, First2&&>::value
              && is_nothrow_constructible<Second, Second2&&>::value)
    : first(move(rhs.first)),
      second(move(rhs,second))
    {}
    // ...
};
```

其中的 `is_nothrow_constructible<>` 是 C++11 標準庫的型別特徵 (type traits) 之一 ([§4.5.1](#451-實現技巧)) 。

在這相對底層和非常通用的層級寫出最優程式碼可不簡單。在基礎層面上, 懂得到底該按位拷貝, 該移動, 還是該按成員拷貝, 會帶來非常大的區別。

## 4.6 C++11: 標準庫組件

C++ 跟其他現代語言比一直有個小巧的標準庫。此外, 大多標準庫組件都很基礎, 而不是試圖處理應用層面的任務。不過, C++11 增加了幾個關鍵的庫組件來支援特定任務: 

- `thread`——基于執行緒和鎖的並發
- `regex`——正則表達式
- `chrono`——時間
- `random`——隨機數產生器和分佈

和大量的商業支援程式庫相比, 這顯然小得可憐, 但這些組件質量很高, 並且跟之前的標準 C++ 相比數量也多多了。

設計這些組件, 是要服務于一些特定任務。在這些任務中, 它們為程式員提供了重大幫助。遺憾的是, 這些庫來自不同背景, 體現在介面風格上, 就出現了差異; 除了要靈活和高性能之外它們沒有一致的整體設計哲學。C++11 在合入一個組件方面沒有明晰的標準 (C++98 有一些 [Stroustrup 1994]) 。更準確地說, 我們只是從現有的、已被社區證明成功的組件中接收組件進來。很多組件來自 Boost ([§2.3](02.md#23-c-的-2006)) 。

如果你需要使用正則表達式, 標準庫中新加入的 `regex` 就是個巨大改進了。類似, 加入無序容器 (哈希表) , 如 `unordered_map`, 為很多程式員省去了大量繁瑣的工作, 使之可以產出更好的程式。然而, 這些庫組件並沒有對人們組織程式碼的方式產生重大影響, 所以我在此不對這些庫組件的細節展開討論。

`regex` 庫主要是 John Maddock 的工作 [Maddock 2002]。

哈希表不巧錯過了 C++98 的截止時間, 因而出現在了 C++0x 的第一批提案之中 [Austern 2002]。它們被稱做無序的 (例如 `unordered_map`) , 是為了區別于老的、有序的標準容器 (例如 `map`) , 也是因為較明顯的名字 (例如 `hash_map`) 已經在 C++11 之前被其他庫大量使用了。另外, `unordered_map` 也可以說是個更好的名字, 因為它指出了型別提供什麼, 而不是它是如何實現的。

`random` 庫提供了分佈函數和隨機數產生器, 其複雜性被譽為“每個隨機數庫都想長成的樣子”。但它對初學者或者一般使用者 (常需要隨機數) 並不易用。它在 2002 年由 Jens Maurer [Maurer 2002] 提出, 並在 2006 年經由費米國家實驗室的一群人修訂 [Brown et al. 2006], 隨即被接受。

相比之下, Howard Hinnant 的 `chrono` 庫 [Hinnant et al. 2008] 處理時間點和時間間隔, 在提供複雜功能的同時仍保持了易用性。例如: 

```cpp
using namespace std::chrono;  // 在子命名空間 std::chrono
auto t0 = system_clock::now();
do_work();
auto t1 = system_clock::now();
cout << duration_cast<milliseconds>(t1-t0).count() << "msec\n";
```

其中的 `duration_cast` 把依賴于時鐘的“嘀嗒”節拍數轉換為程式員選用的時間單位。

使用如此簡單的程式碼, 你可以讓大一學生都能感受到不同演算法和資料結構的代價差異。`chrono` 為 `thread` 庫提供了時間支援 ([§4.1.2](#412-執行緒和鎖)) 。

到了 C++20, `chrono` 得到進一步增強, 加入了處理日期和時區的功能 ([§9.3.6](09.md#936-日期和時區)) 。C++20 也允許把上面的例子簡化為: 

```cpp
cout << t1-t0 << '\n';
```

這就會把 `t0` 和 `t1` 之間的時間差自動以合適的單位進行輸出。

[^1]: 譯註: 參考 Python 在 PEP 20—The Zen of Python 中的不同態度: “應該有且僅有一種明顯的完成任務的方式 (There should be one—and preferably only one—obvious way to do it) 。”

[^2]: 譯註: 下面的程式碼引自 2006 年的論文, 但 `operator=` 的實現不符合現代慣用法: 一般要麼把參數設為 `clone_ptr p`, 這就成了一個可以同時適配拷貝或移動的通用賦值函數; 要麼在函數體內進行一次移動構造, 先 `clone_ptr temp(std::move(p));` 再 `std::swap(ptr, temp.ptr);`。否則, 當傳遞的實參是 `std::move` 的結果 (xvalue) 而不是真正的臨時對象 (prvalue) 時, 程式碼的行為會不符合預期。當然, 就如下面 Bjarne 討論到的, 在 2006 年應該還沒有 xvalue 和 prvalue 的概念。
