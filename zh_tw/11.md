# 11. 回顧

編程語言設計的最終目的, 是在程式員交付有用的程式的同時, 改進他們的思考方式和工作方式。儘管有些程式語言被視為“只是實驗性的”, 但是一旦程式語言被用於和語言本身無關的實際工作, 這門語言的設計者們就應對他們的使用者承擔相應的責任。正確、合適、穩定性和足夠的性能就成為重要的課題。對 C++ 來說, 這些事情在 1979 年僅用了 6 個月就發生了。C++ 已經茁壯成長了 40 年之久。為什麼能成功? 又是如何成功的? 

我之前的 HOPL 論文 [Stroustrup 1993, 2007] 以 1991 到 2006 年的觀點回答了這些問題。從那時起發生的變化, 除了語言的特性和組件庫之外, 主要是標準委員會的作用和影響 ([§3](03.md#3-c-標準委員會)) 。

這裡, 我主要考慮: 

- [§11.1](#111-c-模型): C++ 模型
- [§11.2](#112-技術上的成功): 技術上的成功
- [§11.3](#113-需要工作的領域): 需要努力的領域
- [§11.4](#114-教訓): 教訓
- [§11.5](#115-未來): 未來

## 11.1 C++ 模型

C++ 為高要求的應用而生, 並成長為一種重要的編程語言——在某些領域, 它甚至是主導語言。這是在沒有認真的商業支援和沒有營銷的情況下達到的。許多現代語言拷貝了它的特性和理念。關鍵的語言技術貢獻有: 

- 靜態類型系統, 對內置類型和使用者定義類型具有同等支援 ([§2.1](02.md#21-第一個十年)) 
- 既有值語義, 又有引用語義 ([§4.2.3](04.md#423-移動語義)) 
- 系統和通用資源管理 (RAII)  ([§2.2](02.md#22-第二個十年)) 
- 支援高效的物件導向編程 ([§2.1](02.md#21-第一個十年)) 
- 支援靈活的和高效的泛型編程 ([§10.5.1](10.md#1051-泛型編程)) 
- 支援編譯期編程 ([§4.2.7](04.md#427-constexpr-函數)) 
- 直接使用機器和作業系統資源 ([§1](01.md#1-前言)) 
- 通過庫提供並發支援 (往往使用內建函數實現)  ([§4.1](04.md#41-c11並發支援))  ([§9.4](09.md#94-並發)) 

相較于目前占主導地位的依靠垃圾收集器和廣泛運行期支援的“託管”模式——典型的如 Java、C#、Python 和 JavaScript ([§2.3](02.md#23-c-的-2006)) 等語言——C++ 提供了一種不同的、對許多應用領域來說更好的軟體模式。我所說的 “更好”是指更容易編寫、更有可能正確、更可維護、使用更少的記憶體、耗能更低和更快。

這些貢獻的領域是互幫互助的, 舉例來說: 

- 引用語義 (例如, 指標和智能指標) 支援使用值語義 (例如, `jthread` 和 `vector`) 高效地實現高級類型。
- 對內置類型和使用者定義類型的統一規則, 簡化了泛型編程 (內置類型不是特殊情況) 。
- 編譯期編程使得一系列的抽象技術因為能夠有效使用硬體而變得負擔得起。
- RAII 允許使用使用者定義的類型, 而無需採取特定的操作來支援其實現對資源 (包括非記憶體資源) 的使用。

## 11.2 技術上的成功

C++ 成功的根本原因很簡單——它填補了編程領域的的一個重要的“生態位”: 

> 需要有效使用硬體和管理高複雜性的應用程式

如果你能負擔得起“浪費”25% 甚至 99% 的硬體機能, 那可供選擇的編程語言和環境就多了。如果你的底層模組需要僅僅千行的底層程式碼, C 語言或者組合語言語言可以效勞。40 年以來, C++ 的獨特“生態位”足以使其社區不斷成長。

這裡有一個現代 (2014 年) 的 C++ 總結: 

> - 直接映射到硬體
>   - 指令和基本資料類型
>   - 最初來自于 C 語言
> - 零開銷抽象
>   - 帶構造和解構子的類、繼承、泛型編程、函數對象
>   - 最初來自于 Simula 語言 (當時還不是零開銷的) 

Simula 開創了許多抽象機制和一個靈活的類型系統, 但在運行時間和空間成本上, 它們帶來了沉重的代價。與 1995 年的 C++ ([§2.1](02.md#21-第一個十年)) 描述相比, 關注點從編程技術轉向了問題領域。這更多的是解釋風格和人們興趣的不同, 而不是語言設計的不同。這兩個總結現在和當時都是準確的。

在過去幾十年的基礎上, 21 世紀的關鍵技術進步包括: 

- 記憶體模型 ([§4.1.1](04.md#411-記憶體模型)) 
- 類型安全的並發支援: 執行緒和鎖 ([§4.1.2](04.md#412-執行緒和鎖)) 、並行演算法 ([§8.5](08.md#85-並行-stl)) 、合併執行緒 ([§9.4](09.md#94-並發)) 
- 類型推導: `auto` ([§4.2.1](04.md#421-auto-和-decltype)) 、概念 ([§6](06.md#6-概念)) 、模板參數推導 ([§8.1](08.md#81-建構子模板參數推導)) 、變參模板 ([§4.3.2](04.md#432-變參模板)) 
- 簡化使用: `auto` ([§4.2.1](04.md#421-auto-和-decltype)) 、範圍 `for` ([§4.2.2](04.md#422-範圍-for)) 、並行演算法 ([§8.5](08.md#85-並行-stl)) 、範圍 ([§9.3.5](09.md#935-範圍)) 、lambda 表達式 ([§4.3.1](04.md#431-lambda-表達式)) 
- 移動語義 ([§4.2.3](04.md#423-移動語義)) 
- 編譯期編程: `constexpr` ([§4.2.7](04.md#427-constexpr-函數)) 、編譯期循環 ([§5.5](05.md#55-constexpr-函數中的局部變數)) 、可確保的編譯期求值和容器 ([§9.3.3](09.md#933-編譯期計算支援)) 、元編程 ([§10.5.2](10.md#1052-元編程)) 
- 泛型編程: STL ([§10.5.1](10.md#1051-泛型編程)) 、概念 ([§6](06.md#6-概念)) 、使用者定義類型作為模板參數 ([§9.3.3](09.md#933-編譯期計算支援)) 、lambda 表達式 ([§4.3.1](04.md#431-lambda-表達式)) 
- 元編程 ([§10.5.2](10.md#1052-元編程)) 

它們都與零開銷原則相關, 但最後兩個有點令人驚訝, 因為在 2006 至 2020 年期間內, C++ 對它們的支援並不完全。

假如 C++ 分裂成互不兼容的方言, 或者成為你無法長期依賴的東西, 以上這些就都失去意義了: 

- 穩定性和兼容性至關重要 ([§1.1](01.md#11-年表))  ([§11.4](#114-教訓)) 

新特性 (C++11 以來) 帶來了標準庫的改進 (例如: `unique_ptr`、`chrono`、`format` 和 `scoped_lock`) , 也帶來了很多其他庫的改進。

C++ 的目的是成為構建應用程式的工具, 許多用 C++ 開發的偉大應用程式, 例如在 ([§2.3](02.md#23-c-的-2006)) 和 ([§10.1](10.md#101-c-用來做什麼)) 章節提到的那些, 是 C++ 真正的成功。

## 11.3 需要工作的領域

沒有一種語言對所有人和所有事都是完美的。對於這點, 沒有人比既懂多種語言、又嚴肅使用其中一種並努力支援它的人瞭解更多了。阻礙進步的很少是單純的無知。相反, 重大改進的主要障礙是缺乏方向、缺乏開發資源以及害怕破壞現有程式碼。

C++ 苦于誕生過早, 在現代化的整合開發環境 (IDE) 、構建系統、圖形界面 (GUI) 系統和 Unicode 問世之前就已經誕生了。我期待 C++ 能慢慢趕上來。舉例來說: 

- **工具使用**: 從 C 語言開始, 用字元和詞法標記來說明語義, 以及用 `#include` 和macro 來組織原始碼, 這一直是有效工具建設的主要障礙。模組應該會有所幫助 ([§9.3.1](09.md#931-模組)) , 而且是有可能為 C++ 設計出一個合理的內部表示的 [Dos Reis and Stroustrup 2009, 2011]。
- **教育**: 今天的 C++ 教學大多仍然過時和落後 ([§2.3](02.md#23-c-的-2006)) 。核心指南 ([§10.6](10.md#106-編碼指南)) 是對實踐進行現代化的一種方法。WG21 的教育研究小組 ([§3.2](03.md#32-組織)) 和許多面向教育的會議報告表明, 這些問題得到了重視和並正在解決中。
- **打包和發佈**: C++ 誕生時, 由獨立開發、維護的模組組成的軟體並不常見。今天, 已經有了用於 C++ 的構建系統和打包管理程式。然而, 還沒有一個是標準的, 有些難以用於簡單的任務, 有些則不夠通用, 不能應對使用 C++ 構建的大規模系統。我在 2017 年的 CppCon 主題演講中提出了這個問題, 並向社區發起挑戰 [Stroustrup 2017c] 來解決它。我認為我們正在看到進展。此外, C++ 社區還缺少一個標準的地方來尋找有用的庫。Boost [Boost 1998–2020] 是解決這個問題的一個努力, GitHub 正逐漸成為一個通用的資源庫。但要達到讓相對的新手能找到、下載、安裝和運行幾個主流的庫這樣的方便程度, 我們的路還很長。
- **字符集和圖形**: C++ 語言和標準庫依賴于 ASCII, 但大多數應用程式使用某種形式的 Unicode。WG21 工作組現在有一個研究小組試圖找到一個方式去標準化 Unicode 支援 ([§3.2](03.md#32-組織)) 。缺乏標準的圖形和圖形界面則是更難的問題。
- **清理陳年爛賬**: 這非常困難, 而且令人不快。例如, 我們知道內置類型之間的隱式窄化轉換會導致無窮無盡的問題 ([§9.3.8](09.md#938-跨度)) , 但是有數以萬億計的 C++ 程式碼行, 這些程式碼以難以預測的方式依賴于那些轉換。試圖通過添加“更現代”的特性來替換舊特性來進行改進很容易成為 N+1 問題 ([§4.2.5](04.md#425-統一初始化)) 的犧牲品。改進的工具 (例如靜態程式分析和程式轉換) 提供了希望。

大型語言社區所面臨的挑戰是多種多樣的, 不可能有單一而簡單的解決方案。這不僅僅是一個語法、類型理論或基本語言設計的問題。有些問題是商業性的。在工業規模上取得成功所需的各種技能範圍令人望而生畏。時間會證明, C++ 社區是否能處理好所有這些問題, 以及更多的其他問題。這點上我適度樂觀, 因為現在所有領域都已經有一些積極的舉措 ([§3.2](03.md#32-組織)) 。

## 11.4 教訓

C++ 是由一個大型委員會控制的, 成員多種多樣, 並且會不斷變化 ([§3.2](03.md#32-組織)) 。因此, 除了技術問題外, 我們必須考慮在語言的演化過程中什麼是有效的: 

- **問題驅動**: C++ 開發應該被那些真實世界中的具體問題的需求所驅動。
- **簡單**: C++ 應該從簡單、高效、易用的解決方案中進行推廣而成長。
- **高效**: C++ 語言和標準庫應該遵循零開銷原則。
- **穩定性**: 不要搞砸我的程式碼! 

大部分 (全部? ) C++ 最成功部分的開發都遵從了那些“經驗法則”。它們自然會限制語言的發展範圍, 但這是好事。C++ 並不意味着對所有的人都是無所不能的。此外, 這些原則迫使 C++ 在現實世界的挑戰中相對緩慢地成長, 並從反饋中受益。也請參見《C++ 語言的設計和演化》中的其他“經驗法則” [Stroustrup 1994] 和我的 HOPL2 論文 [Stroustrup 1993]。這裡面一直有連續性。

相比之下, 一個功能如果設計時沒有明確專注在解決大部分開發者實際面臨的問題上, 那它通常會失敗: 

- **只為專家**: 某個功能從開始的時候就要滿足所有專家的需要。
- **模仿**: 我們需要這個功能, 因為它在另外某個語言裡很流行。
- **理論性**: 語言理論裡說語言裡一定要有這個特性。
- **革命性**: 此功能非常重要, 以至於我們必須打破兼容性, 或者摒棄那些不好的老方法。

我的結論是, 儘早確定方向和期望至關重要。稍晚一些, 就會有太多的人有太多的不同意見, 因而無法達成一套連貫而一致的想法。

給定一個方向和一套原則, 一種語言可以基于反饋、使用者經驗、實驗和作為工具的理論成長。這是好的工程方法; 反之, 則是無原則的實用主義或教條的理想主義。

C++ 標準委員會的章程几乎只關注語言和庫的設計。這是有侷限性的。一直以來, 像動態連結、構建系統和靜態分析之類的重要主題大多被忽略了。這是個錯誤。工具是軟體開發人員世界的一個重要組成部分, 要是能不把它們置於語言設計的外圍就好了。

熱衷于各種不同的想法具有危險性。在 2018 年的一篇論文 [Stroustrup 2018d] 中, 我列出了 51 條最近的提案: 

> 我列出了我認為有可能顯著改變我們編寫程式碼方式的論文, 每一篇對教學、維護和編碼指導都有重要的影響, 其中許多對實現也有影響。
>
> 單獨來說, 許多 (大多數) 提案都是有道理的, 但是放在一起卻是瘋狂的, 甚至足以危及 C++ 的未來。

那篇論文的題目是《記住瓦薩號! 》 (*Remember the Vasa!*) 。瓦薩號是 17 世紀瑞典的一艘macro 偉戰艦, 由於設計上不斷後期添加以及測試不充分, 在首航時就沉沒在斯德哥爾摩港。在 1990 年代, 委員會經常提醒自己記得瓦薩號, 但在 2010 年代, 這一教訓似乎已經被遺忘。

為了對委員會的流程進行組織約束, 方向組提出 C++ 程式員的“權利法案” [Dawes et al. 2018]: 

1. **編譯期穩定性**: 新版本標準中的每一個重要行為變化都可以被支援以前版本的編譯器檢測到。
2. **連結期穩定性**: 除極少數情況外, 應避免 ABI 兼容性破壞, 而且這些情況應被很好地記錄下來並有書面理由支援。
3. **編譯期性能穩定性**: 更改不會導致現有程式碼的編譯時間開銷有明顯增加。
4. **運行期性能穩定性**: 更改不會導致現有程式碼的運行時間開銷有明顯增加。
5. **進步**: 標準的每一次修訂都會為某些重要的編程活動提供更好的支援, 或為某些重要編程群體提供更好的支援。
6. **簡單性**: 每一次對標準的修訂都會簡化某些重要的編程活動。
7. **準時性**: 每一次標準的修訂都會按照公佈的時間表按時交付。

接下來的幾十年, 我們將會看到結果到底怎麼樣。

## 11.5 未來

從近期來說, C++20 會像 C++11 那樣, 讓 C++ 社區受益良多。在 2020 年 2 月的布拉格會議上, 委員會對 C++20 進行了定稿, 也投票同意了 Ville Voutilainen 的“C++23 大膽計劃” [Voutilainen 2019b]: 

“在 C++23 努力做到以下幾點: ”

- 對協程的庫支援 ([§9.3.2](09.md#932-協程)) 
- 模組化的標準庫 ([§9.3.1](09.md#931-模組)) 
- 通用非同步計算模型 (執行器)  ([§8.8.1](08.md#881-網路庫)) 
- 網路 ([§8.8.1](08.md#881-網路庫)) 

注意關注點是在庫上。“同時也在以下方面取得進展: ”

- 靜態反射功能 ([§9.6.2](09.md#962-靜態反射)) 
- 函數式編程風格的模式匹配 ([§8.2](08.md#82-結構化綁定)) 
- 契約 ([§9.6.1](09.md#961-契約)) 

鑒於這些議題的工作已經相當深入, 委員會有可能會完成大部分工作。這一大群充滿熱情的人還能拿出什麼東西並達成共識, 就不那麼容易預測了。對於未來幾年, 方向小組 (我是其中的一員) 提到了一些有希望進一步開展工作的領域 [Hinnant et al. 2020]: 

- 改進 Unicode 的支援
- 支援簡單圖形和簡單使用者交互
- 支援新類型的硬體
- 探索錯誤處理的更好表達方式和實現方法

在委員會之外, 我期望在構建系統、包管理和靜態分析方面取得重大進展 ([§10.4](10.md#104-工具)) 。

再往後的五年、十年或更遠的未來, 我在預測水晶球裡就有點看不清了。在這個時間範圍內, 我們需要着眼于根本, 而不是具體的語言特性。我希望標準委員會能注意到學到的教訓 ([§11.4](#114-教訓)) , 並把重點放在根本上 ([§11.1](#111-c-模型)) : 

- 把完全資源安全和類型安全的 C++ 作為追求目標
- 很好地支援各種各樣的硬體
- 保持 C++ 的穩定性記錄 (兼容性) 

保持穩定性需要在關注兼容性的同時, 抵制試圖通過添加大量“完美”特性來取代不完美或不時髦的舊方式來大幅改善 C++ 的衝動。新的特性總是會帶來意外 (有些令人愉快, 有些則不那麼令人愉快) , 舊的特性不會簡單地消失。記住瓦薩號! [Stroustrup 2018d] ([§11.4](#114-教訓)) 。很多情況下, 庫、指南和工具是比修改語言更好的方法。

對於單線程計算來說, 硬體已無法變得更快, 所以對效率的重視將持續存在, 而有效支援各種形式的並發和並行的壓力將不斷增加 ([§2.3](02.md#23-c-的-2006)) 。專用硬體將大量湧現 (例如, 各種記憶體架構和特殊用途的處理器) ; 這將使 C++ 這樣的、可以利用這些硬體的語言受益。唯一比硬體性能增長更快的是人們的期望。

隨着系統越來越複雜, 開銷可負擔的抽象機制的重要性也在增加。對於依賴實時交互的系統, 可預測的性能是至關重要的 (例如, 許多實時系統禁止使用自由存儲 (動態記憶體) ) 。

隨着我們對計算機化系統的依賴程度的增加、高手駭客數量的增多, 安全問題只會越來越重要。為了防禦, 我看好硬體保護, 看好更結構化、能支援更好的靜態分析的系統, 而非無休止的臨時運行期檢查和低級程式碼。

語言和系統之間的互操作性仍會至關重要; 很少有大系統會只用一種語言來編寫。

隨着系統變得越來越複雜, 對可靠性的要求也越來越高, 對設計和編碼質量的需求也急劇增加。我認為 C++ 已經為此做好了充分的準備, C++23 的計劃是要進一步加強它。然而, 僅靠語言特性是不足以滿足未來需求的。我們需要有工具支援的使用指南, 以確保語言的有效使用 ([§10.6](10.md#106-編碼指南)) 。特別是, 我們需要確保完全的類型安全和資源安全, 這必須反映在教育中。為了蓬勃發展, C++ 需要為新手提供更好的教育材料, 也需要幫助有經驗的程式員掌握現代 C++。僅僅介紹奇技淫巧和高級用法是不夠的, 而且反而會因為增強了 C++ 的複雜性名聲而對語言造成傷害。

由於種種原因, 我們需要簡化大多數的 C++ 使用的場景。C++ 的演進已經使之成為可能, 而我預計這一趨勢將繼續下去 ([§4.2](04.md#42-c11簡化使用)) 。改進的優化器——有能力利用程式碼中使用的類型系統和抽象——讓優化這件事變得不同了。在過去的幾年裡, 這極大地改變了我優化程式碼的方式。我從放棄精巧而複雜的東西開始, 那是錯誤的藏身之處; 並且, 如果我難以理解發生了什麼, 編譯器和優化器也會如此。我發現, 這種方法通常會給我帶來從適度到驚人的性能提高, 同時也簡化了未來的維護。只有當這種方法不能給我帶來我想要的性能時, 我才會求助于高級 (又稱複雜) 的資料結構和演算法。這是 C++ 抽象機制設計上的一大勝利。

我期待着看到用 C++ 構建更多令人興奮的應用程式, 並看到新的編程慣用法和設計技巧的發展。

我也希望其他語言能從 C++ 的成功中學習。假如從 C++ 的演化中吸取的經驗教訓僅侷限于 C++ 社區, 那將是可悲的。我希望並期待在其他語言和系統中看到 C++ 模型的關鍵方面, 這將是一個真正的成功衡量標準。在一定程度上, 這已經發生了 ([§2.4](02.md#24-其他語言)) 。

# 致謝

我痛苦地意識到

- 這篇論文太長了。
- 對大多數技術主題的描述都省略了很多可以看作是根本的內容。很多情況下, 許多人經年累月的工作會被簡化為一頁甚至一句話。特別是, 我忽略了並發性這個極其重要的話題; 它應該有一篇專門的長篇論文來進行詳述。

感謝讓 C++ 成功的數以百萬計的程式員, 他們創建的應用是我們這個世界的關鍵部件。

感謝本文草稿的審稿人, 包括 Al Aho、A. Bratterud、Shigeru Chiba、J. Daniel Garcia、Brent Hailpern、Howard Hinnant、Roger Orr、Aaron Satlow、Yannis Smaragdakis、David Vandevoorde、J.C. Van Winkel 和 Michael Wong。本文的完整性和準確性在很大程度上依靠這些審稿人。當然, 錯誤是我自己的。

感謝 Guy Steele 幫我順利解決了 LaTex 和 BibTex 中的謎團, 把文章引用做到滿足 ACM 要求的形式。

感謝所有在標準上努力工作的人。還有很多我沒有提到的名字, 可以在 WG21 論文的作者和這些論文的致謝部分中找到。我參考和引用的許多“P”和“N”編號的論文保存在 [open-std.org/jtc1/sc22/wg21/docs/papers/](http://open-std.org/jtc1/sc22/wg21/docs/papers/)。沒有這些論文, 本文的一些內容就會過度依賴我的記憶了。
