# 8. C++17: 大海迷航

在經過 C++14 這個小版本標準之後, C++17 [Smith 2017] 原本被看作是一個大版本。C++17 有很多新的特性, 但沒有一個我認為稱得上重大。儘管我們已經有給 C++11 和 C++14 帶來成功的工作流程, 標準社區也更豐富、更強大、更熱情, 但對於 C++17 的關鍵問題是: 為什麼所有的辛勞卻沒有帶來更顯著的改進? 

C++17 有大約 21 個新的語言特性 (取決於你的計數方式) , 包括: 

- 建構子模板參數推導——簡化對象定義 ([§8.1](#81-建構子模板參數推導)) 
- 推導指引——解決建構子模板參數推導歧義的顯式標註 ([§8.1](#81-建構子模板參數推導)) 
- 結構化綁定——簡化標註, 並消除一種未初始化變數的來源 ([§8.2](#82-結構化綁定)) 
- `inline` 變數——簡化了那些僅有標頭檔的庫實現中的靜態分配變數的使用 [Finkel and Smith 2016]
- 摺疊表達式——簡化變參模板的一些用法 [Sutton and Smith 2014]
- 條件中的顯式測試——有點像 for 語句中的條件 ([§8.7](#87-條件的顯式測試)) 
- 保證的複製消除——去除了很多不必要的拷貝操作 [Smith 2015]
- 更嚴格的表達式求值順序——防止了一些細微的求值順序錯誤 [Dos Reis et al. 2016b]
- `auto` 當作模板參數型別——值模板參數的型別推導 [Touton and Spertus 2016]
- 捕捉常見錯誤的標準屬性——`[[maybe_unused]]`、`[[nodiscard]]` 和 `[[fallthrough]]` [Tomazos 2015]
- 十六進制浮點字面量 [Köppe 2016a]
- 常數表達式 `if`——簡化編譯期求值的程式碼 [Voutilainen and Vandevoorde 2016]

不幸的是, 這並不是完整的功能擴展列表。相當一部分是如此之小, 我們很難簡單地描述它們。

C++17 標準程式庫中增加了大約 13 個新特性, 並加上了許多小的修改: 

- `optional`、`any` 和 `variant`——用於表達“可選”的標準程式庫型別 ([§8.3](#83-variantoptional-和-any)) 
- `shared_mutex` 和 `shared_lock` (讀寫鎖) 和 `scoped_lock` ([§8.4](#84-並發)) 
- 並行 STL——標準程式庫演算法的多執行緒及矢量化版本 ([§8.5](#85-並行-stl)) 
- 檔案系統——可移植地操作檔案系統路徑和目錄的能力 ([§8.6](#86-檔案系統)) 
- `string_view`——對不可變字元序列的非所有權引用 [Yasskin 2014]
- 數學特殊函數——包括拉蓋爾和勒讓德多項式、貝塔函數、黎曼澤塔函數 [Reverdy 2012]

儘管我也喜歡 C++17 中的某些功能, 但令人困擾的是這些功能沒有統一的主題, 沒有整體的規劃, 似乎只是由於可以達到投票多數而被扔進語言和標準程式庫中的一組“聰明的想法”。這種狀況可能給未來語言的發展帶來更大的弊端, 因此必須採取一些措施做出改變 [Stroustrup 2018d]。方向小組的成立是 WG21 針對這個問題的回應 ([§3.2](03.md#32-組織))  ([§9.1](09.md#91-設計原則)) 的一部分。

不可否認, C++17 提供了一些可以在小方面幫助大多數程式員的東西, 但沒有什麼可以讓我認為是重大的。在這裡, 我將“重大”定義為“對我們思考編程和組織程式碼的方式產生影響”。在此, 我描述了我猜想會產生最大積極影響的功能。

我也檢查了一些儘管經過嚴肅考慮、仍沒有進入 C++17 標準的例子: 

- [§6.3.8](06.md#638-為什麼在-c17-中沒有概念): 概念 (C++20) 
- [§8.8.1](#881-網路庫): 網路庫
- [§8.8.2](#882-點運算符): 點運算符 (`operator.()`) 
- [§8.8.3](#883-統一呼叫語法): 統一函數呼叫
- [§8.8.4](#884-預設比較): 簡單型別的預設比較運算符 `==`、`!=`、`<`、`<=`、`>` 和 `>=`
- [§9.3.2](09.md#932-協程): 協程 (C++20) 

我懷疑如果它們被採納的話, 其中的任何一項都會成為 C++17 最重要的特性之一。它們符合 C++ 應該成為什麼的一致觀點 ([§9.2](09.md#92-我的-c17-清單)) ; 即使只有少數幾項, 也會極大地改變 C++17 的使用方式。

在 C++11 中我看到了相互支援的特性網, 它們帶來了更好的程式碼編寫方式。對於 C++17, 我沒有看到。但是, C++20 完善了這樣一張網, 使 C++ 又向前邁進了一大步 ([§9](09.md#9-c20方向之爭)) 。可以說 C++17 只是通向 C++20 路上的墊腳石, 但是委員會的討論對此毫無暗示, 重點始終放在單獨的特性上。我甚至聽到有人說“列車模型” ([§3.2](03.md#32-組織)) 不適合長期規劃; 事實並非如此。

## 8.1 建構子模板參數推導

幾十年來, 人們好奇為什麼模板參數可以從其他函數參數中推導出來, 卻不能從建構子參數中推導。例如, 在 C++98、C++11 和 C++14 中: 

```cpp
pair<string,int> p0 (string("Hi!"),129);  // 不需要推導
auto p1 = make_pair("Hi!"s,129);          // p1 是 pair<string,int>
pair p2 ("Hi!"s,129);    // 錯誤: pair 缺少模板參數
```

很自然, 在我第一次設計模板的時候, 我也考慮過從建構子參數中推導出模板參數的可能性, 但因為擔心出現歧義而止步。解決方案也有技術障礙, 但 Michael Spertus 和 Richard Smith 克服了這些障礙。所以在 C++17 中, 我們可以寫上面最後一個例子中那樣的程式碼 (`p2`) 而不會報錯, 這樣一來就不需要 `make_pair()` 了。

這簡化了型別的使用, 例如 `pair` 和 `tuple`, 還有當編寫並行的程式碼時用到的鎖和互斥鎖 ([§8.4](#84-並發)) 。

```cpp
shared_lock lck {m};    // 不需要顯式寫出鎖型別
```

這是一個在 C++17 中少見的例子, 相互支援的特性促成了明顯的程式碼簡化。不幸的是, 這些簡化被接受與否都是個案, 而非總體的簡化努力的結果。所以, 在型別推導規則中“填坑”的努力仍在繼續 [Spertus et al. 2018]。

除了這裡的描述之外, 這套機制提供瞭解決歧義的一種寫法 ([§8.3](#83-variantoptional-和-any)) 。

## 8.2 結構化綁定

結構化綁定始於 Herb Sutter、Bjarne Stroustrup 和 Gabriel Dos Reis 的一個簡單的提案 [Sutter et al. 2015], 旨在簡化寫法和消除剩餘的幾個變數未初始化的來源。例如: 

```cpp
template<typename T, typename U>
void print(vector<pair<T,U>>& v)
{
    for (auto [x,y] : v)
        cout << '{' << x << ' ' << y << "}\n";
}
```

名稱 `x` 和 `y` 被分別綁定於 `pair` 的第一個和第二個元素。這可算作是寫法上的重大便利。

C++14 給我們提供了返回多個值的方便方式。例如: 

```cpp
tuple<T1,T2,T3> f(/*...*/)  // 優美的聲明語法
{
    // ...
    return {a,b,c};  // 優美的返回語法
}
```

我認為在當前的 C++ 中, `tuple` 有點被過度使用了, 當多個值並不互相獨立的時候, 我傾向于使用明確定義的型別, 但從寫法上講, 這沒有什麼區別。然而, C++14 並沒有提供像創建多返回值那樣方便的方式去解包它們。這導致了繁瑣的變通解決方案、變數未初始化或運行期開銷。例如: 

```cpp
tuple<T1,T2,T3> res = f();
T1& alpha = get<0>(res);    // 通過 alpha 來間接訪問
T2& val = get<1>(res);
T3 err_code = get<2>(res);  // 拷貝
```

很多專家更喜歡用標準程式庫函數 `tie()` 去解包 `tuple`: 

```cpp
T1 x;
T2 y;
T3 z;
// ...
tie(x,y,z) = f(); // 使用現有變數的優美呼叫方式
```

向 `tie()` 函數賦值的時候, 會向 `tie()` 函數的參數賦值。然而, 使用 `tie`, 你必須分別定義變數, 並且寫出它們的型別以匹配 `f()` 返回的對象的成員 (在這個例子中就是 `T1`、`T2`、和 `T3`) 。不幸的是, 這會導致局部變數“設置前使用”的錯誤, 及“初始化後賦值”的開銷。並且, 大多數程式員並不知道 `tie()` 的存在, 或者認為在真實程式碼中使用它太奇怪了。

Herb Sutter 建議了一種跟正常返回語法類似的方案: 

```cpp
auto {x,y,z} = f(); // 優美的呼叫語法, 會引入別名
```

這對任何有三個成員的 `struct` 都有效, 而不僅僅只對 `tuple`。消除核心指南 ([§10.6](10.md#106-編碼指南)) 中未初始化變數的倒數第二個來源是我的主要動機。是的, 我喜歡這種寫法, 更重要的是它使 C++ 更接近自己的理想表達。

不是每個人都喜歡這個想法, 而且我們几乎沒能在 C++17 中及時討論它。提出結構化綁定的論文 [Sutter et al. 2015] 比較晚, 而正當 2015 年 11 月底在科納 Ville Voutilainen 剛要結束 EWG 會議時, 我注意到我們離午飯還有 45 分鐘, 我覺得小組應該會想要看到這個提案。2015 年科納的會議是我們凍結 C++17 的功能集的時間點, 所以這 45 分鐘很關鍵。我們甚至沒時間去另一個小組找到 Herb, 我就直接講了這個提案。EWG 喜歡這個提案, 會議紀要說**鼓掌以資鼓勵; EWG 想要這樣的東西**。

現在, 真正的工作開始了。

在這個及以後的會議中, 幾個人——尤其是 Chandler Carruth——指出要達到 C++ 的理想, 我們需要擴展將一個對象分解為多個值的能力, 以應對不是 `tuple` 或普通 `struct` 的型別。例如: 

```cpp
complex<double> z = 2+3i;
auto {re,im} = sqrt(z);      // sqrt() 返回覆數值
```

標準程式庫型別 `complex` 並沒有暴露其內部表示。

在 C++17 中我們通過允許使用者定義一系列 `get` 函數解決了這個問題, 例如, `get<0>` 和 `get<1>` 實際上是假裝將結果看作是 `tuple`。這能工作, 但需要使用者提供一些不優雅的重複樣板式程式碼。關於潛在改進的討論仍在繼續, 但沒有明顯的簡化被納入 C++20。

有人要求讓這種方式也能適用於返回陣列的函數和返回帶位域的 `struct` 的函數。我們加入了對那些情況的支援, 所以最終設計至少比原始提案複雜了一倍。

有一個冗長的爭論 (跨多次會議) , 是關於是否可能 (或必須) 顯式地指定被引入的局部變數型別。例如: 

```cpp
auto {int x, const double* y, string& z} = f();    // 非 C++
```

關於這種做法的理由——其中最雄辯的當屬 Ville Voutilainen——如果沒有顯式型別, 寫法的可讀性將會降低, 從而損害可維護性, 還可能導致錯誤。這跟常見的反對 `auto` 的理由很相似, 而顯式型別也會有它們自己的問題。如果型別跟返回值不匹配怎麼辦? 有人說這應該屬於錯誤。有些人說, 轉換到指定的型別將是非常有用的 (例如, `char[20]` 返回到 `string` 中) 。我指出結構化綁定應該引入零開銷別名, 而任何意味着表示變化的型別轉換將導致顯著的開銷。並且, 結構化綁定的一個目的是優化寫法, 而要求顯式型別會導致程式碼比現有的方式更加冗長。

最初的提案使用花括號 (`{}`) 來聚合引入的名字: 

```cpp
auto {x,y,z} = f(); // 優美的呼叫語法, 引入別名
```

然而一些成員, 如 Chandler Carruth 和 David Vandevoorde, 怕語法上會有歧義, 而堅持認為這樣會令人困惑, “因為 `{}` 代表作用域”。所以我們有了 `[]` 語法: 

```cpp
auto [x,y,z] = f(); // 呼叫語法, 引入別名
```

這是個小改動, 但我認為是個錯誤。這個最後一刻的改動, 導致了屬性表達語法的小小複雜化 (比如 `[[fallthrough]]`)  ([§4.2.10](04.md#4210-屬性)) 。我對關於美學或作用域的論據並不買賬, 並且在 2014 年我就展示了關於為 C++ 添加函數式編程風格的模式匹配的想法, 以 `{ … }` 表示用模式將值分解出來 ([§8.3](#83-variantoptional-和-any)) 。結構化綁定的設計就是為了適應這一總體方案。

這些並不是唯一的後期修改提案。每個提案都增加了或將增加複雜性。

對語言每次升級僅孤立地增加一項功能是危險的。除非符合更大的規劃, 最後一刻的改變也是危險的, 容易導致在要求“完整性”的過程中“膨脹”。在這個結構化綁定的例子中, 我不相信允許結構化綁定指定位域能提供充分的效用, 值得為之提高複雜性。

## 8.3 `variant`、`optional` 和 `any`

可選型別可以用 `union` 表示, 沒有運行期開銷。例如: 

```cpp
union U {
    int i;
    char* p;
};

U u;
// ...
int x = u.i;    // 正確: 若且唯若 u 持有整數
char* p = u.p;  // 正確: 若且唯若 u 持有指標
```

從 C 語言最早期開始, 這就被當作一個不同的型別之間“分時共享”記憶體的基本方法來使用和誤用。沒有編譯期和運行期的檢查來確保這個位址僅被用作其真實指代的型別。確保 `union` 成員在使用上一致, 是程式員的職責, 然而令人頭痛的是程式員常在這個地方出錯。

有經驗的程式員通過將聯合體封裝在類中去避免問題, 用類來確保正確使用。Boost 特別提供了三種這樣的型別: 

- `optional<T>`——持有 `T` 或什麼都不持有
- `variant<T,U>`——持有 `T` 或 `U`
- `any`——持有任意型別

這些型別的巨大效用已經在 C++ 和許多其他語言中得到了證明。

委員會決定對這三種型別進行標準化。不幸的是, 這三種型別的設計被分開討論, 好像它們的使用情況毫不相幹一樣。相對於標準程式庫而言, 直接語言支援的可能性似乎從未被認真考慮。結果是三種標準程式庫型別 (就像它們的 Boost 祖先一樣) 彼此之間有很大的不同。因此, 儘管這些型別的效用毋庸置疑, 但它們是委員會設計的一個典型案例。試考慮: 

```cpp
optional<int> var1 = 7;
variant<int,string> var2 = 7;
any var3 = 7;

auto x1 = *var1 ;               // 對 optional 解引用
auto x2 = get<int>(var2);       // 像訪問 tuple 一樣訪問 variant
auto x3 = any_cast<int>(var3);  // 轉換 any
```

為了提取存儲的值, 需要使用三種不兼容的寫法之一。這對程式員來講是一種負擔。沒錯, 有經驗的程式員會習慣的, 但這種非要人們去習慣的不規則性本就不該存在。

為了簡化 `variant` 的使用, 有一種訪問者機制。首先我們需要一個輔助模板去定義一個重載集合: 

```cpp
// 簡單訪問的樣板: 
template<class... Ts> struct overloaded : Ts... { using Ts::operator()...; };
template<class... Ts> overloaded(Ts...) -> overloaded<Ts...>;
```

模板 `overloaded` 真應該是標準的。只有那些熟悉變參模板 ([§4.3.2](04.md#432-變參模板)) 和模板參數推導 ([§8.1](#81-建構子模板參數推導)) 的人才會覺得它比較簡單。不過, 有了 `overloaded`, 我就能根據變體的型別來構造出分支: 

```cpp
using var_t = std::variant<int, long, double, std::string>; // variant 型別

// 簡單訪問的樣板: 
template<class... Ts> struct overloaded : Ts... { using Ts::operator()...; };
template<class... Ts> overloaded(Ts...) -> overloaded<Ts...>;

void use()
{
    std::vector<var_t> vec = {10, 20L, 30.40, "hello"};

    for (auto& var : vec) {
        std::visit (overloaded {
            [](auto arg) { cout << arg << '\n '; },    // 處理整數型別
            [](double arg) { cout << " double : " << arg << '\n '; },
            [](const std::string& arg) { cout << "\"" << arg << "\"\n"; },
        }, var);
    }
}
```

毋庸置疑, `variant` 和它的夥伴們解決了一個重要問題, 但其方式並不優雅。或許將來的工作能減輕介面不一致上的困惑, 從而讓人能專注于真正需要區分的地方。同時, 應該讓更多的 C++ 同仁去使用這些新的型別, 從而消除 `union` 經年累月帶來的老問題。

我認為這三種可辨識 `union` 的變體只是權宜之計。要解決 `union` 的問題, 函數式編程風格的模式匹配更優雅、通用, 潛在也更為高效。在 2014 年 11 月在伊利諾大學厄巴納——香檳分校舉行的會議上, 我發表了關於模式匹配相關設計問題的演講 [Solodkyy et al. 2014], 部分內容基於我同得州農工大學的 Yuriy Solodkyy 和 Gabriel Dos Reis 合作的研究 [Solodkyy et al. 2013]。我們有一個庫的實現, 它的性能和函數式編程語言相若, 儘管沒有和編譯器進行整合。這個庫不僅能應付包含替換型別的封閉集合 (代數型別) , 也能應付開放集合 (類層次結構) 。我們的目的是消除對訪問者模式的使用 [Gamma et al. 1994]。然而, 我們沒有一種能讓人普遍接受的語法。我的演講目的是提高人們的興趣, 並設定長期的目標。人們對此很感興趣。在 C++17 完成後, 工作已經開始 [Murzin et al. 2019, 2020]。或許模式匹配能加入到 C++23 中 ([§11.5](11.md#115-未來)) 。

## 8.4 並發

在 C++17 中, 以下型別的加入極大地簡化了鎖的使用: 

- `scoped_lock`——獲取任意數量的鎖, 而不會造成死鎖
- `shared_mutex` 和 `shared_lock`——實現讀寫鎖

例如, 我們能獲取多個鎖, 而不用擔心會產生死鎖: 

```cpp
void f()
{
    scoped_lock lck {mutex1, mutex2, mutex3}; // 獲得所有三把鎖
    // ... 操作共享資料 ...
} // 隱式地釋放所有鎖
```

C++11 和 C++14 沒能帶給我們讀寫鎖。這顯然是個嚴重的疏忽, 原因是各種提議的壓力, 以及處理提議所需的時間。C++17 通過加入 `shared_mutex` 解決了這一問題: 

```cpp
shared_mutex mx;    // 一個可以被共享的鎖
void reader()
{
    shared_lock lck {mx};  // 跟其他 reader 共享訪問
    // ... 讀 ...
}
void writer()
{
    unique_lock lck {mx};  // writer 需要獨占訪問
    // ... 寫 ...
}
```

多個讀執行緒可以“共享”該鎖 (即同時進入臨界區) , 而寫執行緒則需要獨占訪問。

我認為這些例子很好體現了“簡單的事情簡單做”的哲學。有時, 我同很多 C++ 程式員一樣在想, “是什麼讓他們花了這麼長時間? ”

請注意使用從建構子參數推導出來的模板參數是如何簡化表達寫法的 ([§8.1](#81-建構子模板參數推導)) 。

## 8.5 並行 STL

從長遠來看, 並行演算法的使用將是非常重要的, 因為從使用者角度看, 沒有什麼比只說“請執行這個演算法”更簡單的了。從實現者的角度來看, 演算法中有一套特定介面而沒有對演算法的串列約束將是一個機會。C++17 只邁出了一小步, 但這遠比沒有開始好得多, 因為它指明了方向。不出意外, 委員會中有一些反對的聲音, 大多數來自于希望為專家級使用者提供複雜介面的人。有些人對這樣簡單的一個方案是否可行表示嚴重懷疑, 並主張推遲這一方案。

基本的想法是, 為每個標準程式庫演算法提供一個額外參數, 允許使用者請求向量化和/或多執行緒。例如: 

```cpp
sort(par_unseq, begin(v), end(v));  // 考慮並行和向量化
```

但這還只適用於 STL 演算法, 所以重要的 `find_any` 和 `find_all` 演算法被忽略了。將來我們會看到專門為並行使用而設計的演算法。這正在 C++20 中變為現實。

另一個弱點是, 仍然沒有取消一個執行緒的標準方法。例如, 在搜索中找到一個對象後, 一個執行緒不能停止其他正在並行執行的搜索。這是 POSIX 干預的結果, 它反對所有形式的取消操作 ([§4.1.2](04.md#412-執行緒和鎖)) 。C++ 20 提供了協作式取消 ([§9.4](09.md#94-並發)) 。

C++17 的並行演算法也支援向量化。這很重要, 因為對 SIMD 的優化支援是硬體在單線程性能方面仍然 (2017 年後) 有巨大增長的少數領域之一。

在 C++20 中, 我們 (總算) 能用範圍庫 ([§6.3](06.md#63-concepts-ts)) 來避免顯式使用容器的元素序列, 只要這麼寫: 

```cpp
sort(v);
```

不幸的是, 並行版本的範圍在 C++20 中沒有及時完成, 因此我們只能等到 C++23 才能這麼寫: 

```cpp
sort(par_unseq, v);  // 使用並行和向量化來對 v 進行排序
```

不想等 23 的話, 我們可以自己實現適配器: 

```cpp
template<typename T>
concept execution_policy = std::is_execution_policy<T>::value;

void sort(execution_policy auto&& ex, std::random_access_range auto& r)
{
    sort(ex, begin(r), end(r));  // 使用執行策略 ex 來排序
}
```

畢竟標準程式庫是可擴展的。

## 8.6 檔案系統

2002 年, Beman Dawes 編寫了 Boost 檔案系統庫, 成為最受歡迎的 Boost 庫之一 [Boost 1998–2020]。2014 年, Boost 檔案系統庫 [Dawes 2002–2014] (經修改後) 被加入了 TS [Dawes 2014, 2015], 又經過進一步修改被加入了 C++17 標準。跟檔案名和檔案系統打交道是很棘手的, 因為它涉及到並行、多種自然語言和作業系統間的差異。最終能通過標準方式操作目錄 (檔案夾) 是件好事 (正如 Boost 從 15 年前開始做的那樣) 。提供的關鍵型別是 `path`, 對字符集和檔案系統的不同寫法進行了抽象。例如: 

```cpp
void do_something(const string& name)
{
    path p {name};  // name 可能是俄語或阿拉伯語
                    // name 可能使用 Windows 或 Linux 檔案寫法
    try {
        if (exists(p)) {
            if (is_regular_file(p))
                cout << p << " regular file, size: " << file_size(p) << '\n';
            else if (is_directory(p)) {
                cout << p << " directory, containing:\n";
                for (auto& x : directory_iterator(p))
                    cout << "    " << x.path() << '\n';
            }
            else
                cout << p << " exists\n";
        }
        else
            cout << p << " does not exist\n";
    }
    catch (const filesystem_error& ex) {
        cerr << ex.what() << '\n';
        throw;
    }
    // ... 使用 p ...
}
```

捕捉異常可以防止罕見的錯誤, 比如有人在 `exists(p)` 檢查後、執行詳細檢索前刪除了檔案。檔案系統介面同時為罕見 (異常) 和常見 (預期) 錯誤提供了支援 ([§7.2](07.md#72-現實中的問題)) 。

## 8.7 條件的顯式測試

我認為“很多小的提案”是危險的, 即使每個都能幫助一些人。考慮為條件增加顯式測試的能力 [Köppe 2016b]: 

```cpp
if (auto p = f(y); p->m>0) {
    // ...
}
```

`p->m>0` 是一個顯式測試, 它的意思是: 

```cpp
{
    auto p = f(y);
    if (p->m>0) {
        // ...
    }
}
```

這是對 C++98 裡在條件裡同時聲明和測試的推廣 ([§2.2.1](02.md#221-語言特性)) : 

```cpp
if (auto pd = dynamic_cast<Derived*>(pb)) { // 如果 pd 指向 Derived 型別則為真
    // ...
}
```

問題是這種推廣是否足夠明顯和有用, 值得作為提案引入。我的回答是否定的。然而, 這是我被否決的一個例子 (不是很罕見) 。

我的觀點是, 顯式測試最好體現在 `if` 語句中。那裡更不容易被忽視, 而且遵循常規有其好處, 特別是對那些不僅僅使用 C++ 語言編程的人。另一方面, 顯式測試似乎在有的人那裡很受歡迎, 他們的程式碼設計成需要對每個函數的結果都做錯誤檢查。我個人非常反感那種設計風格 ([§7.5](07.md#75-回歸基礎)) 。

有人為了用上新特性而積極地重寫程式碼。我聽說過好幾個例子, 有人看到下面這樣的程式碼: 

```cpp
if (auto p = f(y)) {
    if (p->m>2) {
        // ...
    }
    // ...
}
```

就立即重寫為這樣: 

```cpp
if (auto p = f(y); p->m>2) {
    // ...
}
```

並聲稱這樣更優雅和簡潔。自然, 當 `p==nullptr` 時它會崩潰, 而最初的程式碼不會。無論我們從中能得到什麼好處, 這樣的重寫可能帶來新的錯誤和混亂。

為了通用, 顯式測試也可以用在 `switch` 和 `while` 條件中。在 C++20 中, 這一機制被進一步擴展到可以在範圍 `for` 語句中包含初始化 [Köppe 2017c]。

## 8.8 C++17 中未包含的提議

除了概念 ([§6.3.8](06.md#638-為什麼在-c17-中沒有概念)) 以外, 一些我認為很重要的提案沒有加入 C++17。如果不提及它們, C++ 的歷史就不完整: 

- [§6.3.8](06.md#638-為什麼在-c17-中沒有概念): 概念 (C++20) 
- [§8.8.1](#881-網路庫): 網路
- [§8.8.2](#882-點運算符): 點運算符
- [§8.8.3](#883-統一呼叫語法): 統一呼叫語法
- [§8.8.4](#884-預設比較): 預設比較
- [§9.3.2](09.md#932-協程): 協程 (C++20) 

靜態反射是在一個研究小組 ([§3](03.md#3-c-標準委員會)) 中處理的, 並不在 C++17 的既定規劃之中。但作為一項重要工作, 它是在這一時期啟動的。

### 8.8.1 網路庫

在 2003 年, Christopher M. Kohlhoff 開始開發一個名叫 *asio* 的庫, 以提供網路支援 [Kohlhoff 2018]: 

> “Asio 是用於網路和底層 I/O 編程的一個跨平台 C++ 庫, 它採用現代化 C++ 的方式, 為開發者提供了一致的非同步模型”

在 2005 年, 它成為了 Boost [Kohlhoff 2005] 的一部分, 並在 2006 年被提案進入標準 [Kohlhoff 2006]。在 2018 年, 它成為了 TS [Wakely 2018]。儘管經過了 13 年的重度生產環境使用, 它還是未能進入 C++17 標準。更糟糕的是, 讓網路庫進入 C++20 標準的工作也停滯不前。這意味着, 在 asio 得以在生產環境中使用 15 年之後, 我們還是不得不至少等到 2023 年, 才能看到它成為標準的一部分。延誤原因在於, 我們仍在進行嚴肅的討論, 如何最好地將 asio 中和其他場合中處理並發的方式一般化。為此提出的“執行器 (executors) ”提案得到了廣泛的支援, 並且有人還期望它能成功進入 C++20 [Hoberock et al. 2019, 2018]。我認為 C++20 中執行器和網路庫的缺失, 正是“最好是好的敵人”的一個例子。

### 8.8.2 點運算符

在標準化進程啟動之初, 首個對 C++ 擴展的提案, 就是由 Jim Adcock 在 1990 年提出的允許重載點 (`.`) 運算符的提案 [Adcock 1990]。從 1984 年開始, 我們就可以重載箭頭運算符 (`->`) , 並且該機制被重度使用, 以實現“智能指標” (比如 `shared_ptr`) 。人們當時希望 (並且現在仍然希望) 能重載點運算符以實現智能引用 (代理) 。基本上, 人們想要有一種方式, 使得 `x.f()` 意味着 `x.operator.().f()`, 從而 `operator.()` 可以控制對成員的訪問。然而, 關於該議題的討論總是陷入僵局, 因為大家對於重載版的點運算符是否應該應用到其隱式使用上無法達成一致。舉個例子: `++x` 對於使用者定義型別, 被解釋為 `x.operator++()`。現在, 如果使用者定義型別定義了 `operator.()`, `++x` 是否應該表示 `x.operator.().operator++()`? Andrew Koenig 和 Bjarne Stroustrup 在 1991 年 [Koenig and Stroustrup 1991a] 嘗試過解決這個問題, 但被最初的提案者 Jim Adcock 所強烈反對。Gary Powell、Doug Gregor 和 Jaakko Järvi 在 2004 年再度進行了嘗試, 試圖提案到 C++0x [Powell et al. 2004], 但在委員會那裡又一次陷入僵局。最後, 在 2014 年, Bjarne Stroustrup 和 Gabriel Dos Reis 又進行了一次嘗試, 試圖提案到 C++17, 我認為該提案 [Stroustrup and Dos Reis 2014] 是更為全面的, 也是更為合理的。舉例如下: 

```cpp
template<class X>
class Ref {  // 智能引用 (帶有所有權) 
public:
    explicit Ref(int a) : p{new X{a}} {}
    X& operator.() { /* 這裡可以有程式碼 */ return *p; }
    ~Ref() { delete p; }
    void rebind(X* pp) { delete p; p=pp; }
    // ...
private:
    X* p;
};

Ref<X> x {99};
x.f();                // 意思是 (x.operator.()).f() 即  (*x.p).f()
x = X{9};             // 意思是 x.operator.() = X{9} 即 (*x.p)=X{9}
x.rebind(new X{77});  // 意思是 x 持有並擁有那個新的 X
```

其基本想法是, 在“句柄” (這裡是 `Ref` 類) 中定義的運算 (比如構造、析構、`operator.()` 和 `rebind()`) 會作用於句柄之上, 而沒有在“句柄”中定義的運算則作用於該句柄所對應的 “值”, 也就是 `operator.()` 的結果之上。

在付出很多努力之後 [Stroustrup and Dos Reis 2016], 這個提案也失敗了。2014 年的這份提案失敗的原因頗為有趣。當然, 設計中還存在一些常見的措辭問題和模糊的“陰暗角落”, 但我認為, 這份提案本來是可以獲得成功的, 如果不是因為委員會對智能引用的想法太過激動以至于逐漸偏離了目標, 再加上 Mathias Gaunard 和 Dietmar Kühl [Gaunard and Kühl 2015] 以及 Hubert Tong 和 Faisal Vali [Tong and Vali 2016] 也分別提交了替代方案的話。這兩份提案中, 前者需要所有試圖定義 `operator.()` 的使用者去重度使用模板元編程, 而後者基本上是物件導向的, 引入了一種新的繼承形態和隱式轉換。

`operator.()` 的動作應該取決於將被訪問的成員呢? 還是說 `operator.()` 應該是個一元運算符, 僅僅依賴于它應用的對象呢 (就像 `operator->()` 一樣) ? 前者是 Gaunard 和 Kühl 的提案的核心。Bjarne Stroustrup 和 Gabriel Dos Reis 也考慮過讓 `operator.()` 成為二元運算符, 但結論是這種方案過于複雜, 而且在這件事上跟箭頭運算符 (`->`) 保持匹配是重要的。

最後, 雖然初始的提案並沒有被真正拒絶 (它被 EWG 所批准, 但從未進入全體委員會投票的階段) , 但由於缺乏新的輸入從而無法在相互競爭的提案中間贏得共識, 進一步的進展也就停滯不前了。另外, 最初的提議者 (Bjarne Stroustrup 和 Gabriel Dos Reis) 也被更為重要的提案以及他們的“日常工作”分散了精力, 比如概念 ([§6](06.md#6-概念)) 和模組 ([§9.3.1](09.md#931-模組)) 。我認為點運算符的歷程是一個典型案例, 體現了委員會成員對於 C++ 是什麼和它應該發展成什麼樣 ([§9.1](09.md#91-設計原則)) 缺乏共同的看法。三十年的時間, 六個提案, 很多次的討論, 大量的設計和實現工作, 最終我們卻一無所獲。

### 8.8.3 統一呼叫語法

對概念的首次討論是在 2003 年, 在這個過程中提及了函數呼叫需要一個統一的語法 [Stroustrup and Dos Reis 2003b]。也就是說, 理想情況下 `x.f(y)` 和 `f(x,y)` 應該含義相同。重點是, 當編寫泛型庫時, 你必須決定呼叫參數做運算時是採用物件導向的寫法還是函數式的寫法 (`x.f(y)` 或 `f(x,y)`) 。而作為使用者, 你不得不適應庫的設計者所做出的選擇。不同的庫和不同的組織會有不同的選擇。對於運算符, 如 `+` 和 `*`, 統一的重載決策是一直以來的規則; 也就是說, 一個使用 (比如 `x+y`) 既會找到成員函數, 也會找到獨立函數。在標準程式庫中, 我們使用氾濫成災的成對的函數來應對這種困境 (例如, 讓 `begin(x)` 和 `x.begin()` 都能使用) 。

我應該在 1985 年左右, 在委員會糾結于細節和潛在問題之前, 就把這個問題解決掉。但我當時沒能把運算符的情形推廣。

在 2014 年, Herb Sutter 和我各自提案了“統一函數呼叫語法” [Stroustrup 2014a; Sutter 2014]。當然, 這兩份提案並不兼容, 但我們立刻解決了兼容問題, 並將它們合併成了一份聯合提案 [Stroustrup and Sutter 2015]。

Herb 的部分動力來自于希望在 IDE 裡面支援自動完成, 並且傾向于“物件導向”的寫法 (例如 `x.f(y)`) , 而我則主要出於泛型編程的考慮, 並且傾向于傳統的數學式寫法 (例如 `f(x,y)`) 。

一如既往地, 第一個嚴重的反對意見是兼容性問題; 也就是, 我們可能會破壞現有的程式碼。最初的提案確實可能會破壞一些程式碼, 因為它傾向于更好的匹配或使得呼叫變得含糊, 而我們的辯論主張是它是值得的, 並且往往是有益的。但我們在這場辯論中失敗了, 之後我們重新準備了一份修改過的版本, 其工作方式基于一個原則, `x.f(y)` 會首先查找 `x` 的類, 僅當無法找到 `f` 成員函數時, 才考慮 `f(x,y)`。類似的, `f(x,y)` 只會在沒有相應的獨立函數的情況下才會查找 `x`  對應的類。這個方案並不會讓 `f(x,y)` 和 `x.f(y)` 完全等價, 但顯然它不會破壞現有程式碼。

這看起來很有希望, 但卻遭到了一片憤怒的嚎叫: 它將意味着穩定介面的終結! 這個觀點主要由來自谷歌的人提出, 他們認為依賴于重載決策的介面無法再保持穩定了, 因為添加一個函數就有可能改變現有程式碼的含義。這當然是真的。考慮: 

```cpp
void print(int);
void print(double);

print('a');       // 打印 'a' 的整數值

void print(char); // 添加一個 print () 以改變重載集合

print('a');       // 打印字元 'a'
```

我對於這個觀點的回應就是, 几乎任何程式都可被相當多的各種新增聲明改變其含義。而且, 重載的一個常見用法, 就是通過添加函數, 來提供語義上更佳的方案 (往往是為了修復缺陷) 。我們總是強烈建議, 不要在程式的半途添加會導致重載集合的呼叫語義發生變化的重載 (比如上例中的 `print(char)`) 。換句話說, 這個“穩定”的定義是不切實際的。我 (和其他人) 指出, 這個問題對於類成員也早就存在了。反方的基本回應是說, 類成員的集合是封閉的, 所以這個問題在類成員上是可控的。我觀察到, 通過使用命名空間, 和某個類相關的獨立函數集合几乎可以像成員一樣來識別 [Stroustrup 2015b]。

在這個時候, 大量的爭議和混亂爆發了, 新的提案也開始出現, 並和正處于討論中的提案競爭。英國的代表建議採用 C# 風格的拓展方法 [Coe and Orr 2015], 而其他一些人, 尤其是 John Spicer 堅持認為, 如果我們需要一種統一的函數呼叫寫法, 那它應該是一種全新的寫法, 以和現有的兩種相區分。我還是不能看出添加第三種標記 (例如所建議的 `.f(x,y)`) 能統一什麼。這只會變成 N+1 問題 ([§4.2.5](04.md#425-統一初始化)) 的又一個案例。

在提案被否決後, 我被要求在有了模組後 ([§9.3.1](09.md#931-模組)) 重新審視該問題。到那時, 對獨立函數名字的查找範圍就可以被限定在它第一個參數的類所在的模組。這可能可以使統一函數呼叫的提案起死回生, 但我仍然無法看出這可以怎樣解決 (在我看來過于誇大的) 關於介面穩定性的顧慮。

又一次的, 對 C++ 的角色和未來缺乏共同的看法阻礙了事情的進展 ([§9.1](09.md#91-設計原則)) 。

回頭看, 我認為物件導向的寫法 (如 `x.f(y)`) 壓根就不該被引入。傳統的數學式寫法 `f(x,y)` 就足夠了。而且作為一個附帶的好處, 數學式寫法可以很自然的給我們帶來多方法 (multi-methods) , 從而將我們從訪問者模式這個變通方案 [Solodkyy et al. 2012] 中拯救出來。

### 8.8.4 預設比較

和 C 一樣, C++ 並沒有給資料結構提供預設的比較。比如: 

```cpp
struct S {
    char a;
    int b;
};

S s1 = {'a',1};
S s2 = {'a',1};

void text ()
{
    S s3 = s1 ;       // 可以, 初始化
    s2 = s1 ;         // 可以, 賦值
    if (s1 == s2) { /* ... */ }  // 錯誤: == 對 S 未定義
}
```

其原因在於, 考慮到 `S` 的通常記憶體佈局, 在持有 `S` 的記憶體中的部分會有“未使用的比特位”, 因此 `s1==s2` 的樸素實現, 也就是比較持有 `s1` 和 `s2` 的字的比特位的方式, 可能會給出 `false` 值。如果不是由於這些“未使用的比特位”, C 語言至少會有預設的等值比較。我在 1980 年代早期曾經和 Dennis Ritchie 進行過討論, 但我們當時都太忙了, 因而沒時間為解決這個問題做些什麼。這個問題對於複製 (如 `s1=s2`) 不是個問題, 樸素而傳統的方案就是簡單的複製所有比特位。

由於簡單實現的效率, 允許賦值而不允許比較在 1970 年代是合適的, 而到了 2010 年代就不合適了。現在我們的優化器可以很容易地處理這個問題, 而且我——跟其他很多人一樣——已經厭倦瞭解釋為什麼沒有提供這樣的預設比較。尤其是很多 STL 演算法需要 `==` 或 `<`, 如果使用者沒有顯式地為這些資料結構定義 `operator==()` 和/或 `operator<()`, 它們就無法支援簡單的資料結構。

在 2014 年, Oleg Smolsky [Smolsky 2014] 提議了一種定義比較運算符的簡單方法: 

```cpp
struct Thing {
    int a, b, c;
    std::string d;

    bool operator==(const Thing &) const = default;
    bool operator<(const Thing &) const = default;

    bool operator!=(const Thing &) const = default;

    bool operator>=(const Thing &) const = default;
    bool operator>(const Thing &) const = default;
    bool operator<=(const Thing &) const = default;
};
```

這處理了正確的問題, 但它是繁瑣的 (長長的六行程式碼就為了說明“我想要預設的運算符”) , 並且, 和預設就有比較運算符相比, 這絶對是退而求其次了。它還有些其他的技術問題 (例如“但這個方案是侵入式的: 如果我不能修改一個類, 我就沒法給它添加比較能力”) , 但現在競賽已經是在如何更好地在 C++17 支援運算符上了。

我寫了一篇論文討論這個問題 [Stroustrup 2014c], 並且提議為簡單類提供預設比較 [Stroustrup 2014b]。事實證明, 在這個上下文中, 很難定義“一個類是簡單的”意味着什麼, 而且 Jens Maurer 發現了一些令人不愉快的作用域問題, 關於在有了預設運算符的同時又自定義比較運算符的組合情況 (例如, “在使用了預設的 `==` 之後, 如果我們在不同的作用域又定義了 `operator==()`, 這意味着什麼? ”) 。

Oleg、我還有其他人寫了更多的其他論文, 但提案都停滯了。人們開始在提案上堆積更多的要求。比如, 要求預設比較的性能在簡單使用情況下要和三路比較相等。Lawrence Crowl 寫了對通用的比較的分析 [Crowl 2015b], 論及如全序、弱序和偏序這樣的問題。EWG 的普遍觀點是 Lawrence 的分析非常棒, 但他需要時間機器才能把這些機制加入到 C++ 中。

最後, 在 2017 年, Herb Sutter 給出了一份提案 (部分基于 Lawrence Crowl 的工作) , 該提案基于三路比較運算符 `<=>` (如在各種語言中可見到的) , 基于該運算符可以生成其他常用的運算符 [Sutter 2017a]。它沒有為我們提供預設的運算符, 但至少它讓我們可以用一行公式去定義它們: 

```cpp
struct S {
    char a;
    int b;
    friend std::strong_order operator<=>(S,S) = default;
};

S s1 = {'a',1};
S s2 = {'a',1};

bool b0 = s1==s2;    // true
int b1 = s1<=>s2;    // 0
bool b2 = s1<s2;     // false
```

上述方案是 Herb Sutter 所推薦的, 因為它帶來的問題最少 (例如跟重載和作用域相關的) , 但它是侵入式的。我無法在不能修改的類中使用這個方案。在這種情況下, 可以定義一個非成員函數的 `<=>`: 

```cpp
struct S {
    char a;
    int b;
};

std::strong_order operator<=>(S,S) = default;
```

關於 `<=>` 的提案包含了一個可選項, 為簡單類隱式定義 `<=>`, 但不出所料, 認為一切都是顯式的才更安全的人們投票否決了這個選項。

於是, 我們得到的並不是一個讓簡單的例子在新手手中按預期工作的功能, 而是一個允許專家仔細打造精妙比較運算的複雜功能。

儘管這個 `<=>` 的提案並沒有可用的實現, 並且對標準程式庫有強烈潛在影響。它還是比其他任何我能想到的近期的提案都更容易地通過了委員會。不出所料, 這個提案帶來了很多驚訝 ([§9.3.4](09.md#934-)) , 包括導致之前 `==` 提案未能成功的查找問題。我猜測, 關於比較運算符的討論讓很多人相信了我們總得做些什麼, 而 `<=>` 提案解決了很多各種問題, 並與其他語言中熟悉的內容相吻合。

將來的某個時間, 我很可能會再次提議為簡單類預設定義 `==` 和 `<=>`。C++ 的新人和普通使用者理當享有這種簡單性。

`<=>` 被提議于 2017 年, 錯過了 C++17, 但經過後來很多進一步的工作, 它進入了 C++20 ([§9.3.4](09.md#934-)) 。
