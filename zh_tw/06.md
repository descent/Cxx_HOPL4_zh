# 6. 概念

對 C++ 來說, 泛型編程和使用模板的元編程已經取得了巨大的成功。但是, 對泛型組件的介面卻遲遲未能以一種令人滿意的方式進行合適的規範。例如, 在 C++98 中, 標準程式庫演演算法大致是如下規定的: 

```cpp
template<typename Forward_iterator, typename Value>
ForwardIterator find(Forward_iterator first, Forward_iterator last,
                              const Value & val)
{
    while (first != last && *first != val)
        ++first;
    return first;
}
```

C++ 標準規定: 

- 第一個模板參數必須是前向迭代器。
- 第二個模板參數類型必須能夠使用 `==` 與該迭代器的值類型進行比較。
- 前兩個函數參數必須標示出一個序列。

這些要求是隱含在程式碼中的: 編譯器所要做的就是在函數體中使用模板參數。結果是: 極大的靈活性, 對正確呼叫生成出色的程式碼, 以及對不正確的呼叫有糟糕得一塌糊塗的錯誤訊息。解決方案顯而易見, 將前兩項條件作為模板介面的一部分來指定: 

```cpp
template<forward_iterator Iter, typename Value>
    requires equality_comparable<Value, Iter::value_type>
forward_iterator find(Iter first, Iter last, const Value& val);
```

這大致就是 C++20 所提供的了。注意 `equity_comparable` 概念, 它捕獲了兩個模板參數之間必需有的關係。這樣的多參數概念非常常見。

表達第三個要求 ([first:last) 是一個序列) 需要一個庫擴展。C++20 在 Ranges 標準程式庫組件 ([§9.3.5](09.md#935-範圍)) 中提供了該特性: 

```cpp
template<range R, typename Value>
    requires equality_comparable<Value, Range::value_type>
forward_iterator find(R r, const Value& val)
{
    auto first = begin(r);
    auto last = end(r);
    while (first!=last && *first!=val)
        ++first;
    return first;
}
```

為了規範模板對其參數的要求, 對其提供良好支援, 有過數次嘗試。本節會進行描述: 

- [§6.1](#61-概念的早期歷史): 概念的早期歷史
- [§6.2](#62-c0x-概念): C++0x 中的概念
- [§6.3](#63-concepts-ts): Concepts TS
- [§6.4](#64-c20-概念): C++20 中的概念

## 6.1 概念的早期歷史

1980 年, 我猜想泛型編程可以通過 C 風格的macro 來有效支援 [Stroustrup 1982]。然而我完全錯了。一些有用的簡單泛型抽象能通過這種方法表達, 1980 年代的標準化之前的 C++ 通過 `<generic.h>` 中的一組macro 為泛型編程提供支援, 但macro 在大型項目或廣泛使用的情況下無法有效管理。儘管泛型編程在當時流行的“物件導向的思想”中並沒有一席之地, 我確實發現了一個問題, 需要解決它才能達到我對“帶類的 C”的目標。

大約在 1987 年, 我嘗試設計具有合適介面的模板 [Stroustrup 1994], 但失敗了。我需要三個基本屬性來支援泛型編程: 

- **全面的通用性/表現力**——我明確不希望這些功能只能表達我想到的東西。
- **與手工編碼相比, 零額外開銷**——例如, 我想構建一個能夠與 C 語言的陣列在時間和空間性能方面相當的 vector。
- **規範化的介面**——我希望類型檢查和重載的功能與已有的非泛型的程式碼相類似。

那時候沒人知道如何做到全部三個方面, 因此 C++ 所做到的是: 

- 圖靈完備性 [Veldhuizen 2003]
- 優於手動編碼的性能
- 糟糕的介面 (基本上是編譯期鴨子類型) , 但仍然做到了靜態類型安全

前兩個屬性使模板大獲成功。

由於缺乏規範化的介面, 我們在這些年裡看到了極其糟糕的錯誤訊息, 到了 C++17 還仍然是這樣。缺乏規範化的介面這一問題, 讓我和很多其他人困擾很多年。它讓我非常困擾的原因是, 模板無法滿足 C++ 的根本的設計標準 [Stroustrup 1994]。我們 (顯然) 需要一種簡單的、沒有運行期開銷的方法來指定模板對其模板參數的要求。

多年以來, 一些人 (包括我) 相信模板參數的要求可以在 C++ 本身中充分指定。1994 年, 我在 [Stroustrup 1994] 中記錄了基本的想法, 並在我的網站上發佈了範例 [Stroustrup 2004–2020]。自 2006 年以來, 基于 Jeremy Siek 的作品, Boost 提供了該想法的一個變體, Boost 概念檢查庫 [Siek and Lumsdaine 2000–2007]。不知何故, 它並未像我所希望的那樣廣泛流行。我懷疑原因是它不夠通用、不夠優雅 (Boost 感到有義務使用macro 隱藏細節) , 並且在標準中不受支援。許多人將其視為一種奇技淫巧。

為 C++ 定義的概念可以追溯到 Alex Stepanov 在泛型編程上的工作, 這是 1970 年代末開始的, 一開始用的名稱是“代數結構” [Kapur et al. 1981]。注意, 那差不多比 Haskell 的類型類設計 [Wadler and Blott 1989] 要早十年, 比我嘗試解決 C++ 的類似問題要早 5 年。對於這種需求, Alex Stepanov 早在 1990 年代末期的講座中就使用了“概念”這一名稱, 並記錄在 [Dehnert and Stepanov 2000]。我之所以提到這些, 是因為許多人猜測概念是從 Haskell 類型類派生而來但被錯誤命名了。Alex 使用“概念”這一名稱是因為概念此處用來代表應用領域 (如代數) 中的基本概念。

目前使用概唸作為類型謂詞, 依靠使用模式來描述操作, 起源於二十一世紀初期 Bjarne Stroustrup 和 Gabriel Dos Reis 的工作並記錄在 [Dos Reis and Stroustrup 2005b, 2006; Stroustrup and Dos Reis 2003b, 2005a]。這種方法在 1994 年的《設計和演化》[Stroustrup 1994] 一書也被提及, 但是我不記得我第一次進行嘗試的時間了。將概念建立於使用模式的主要原因是為了以一種簡單而通用的方式處理隱式轉換和重載。我們瞭解 Haskell 類型類, 但它們對當前的 C++ 設計影響不大, 因為我們認為它們太不靈活了。

精確指定並檢查一個模板對於參數的要求曾經是 C++0x 的最出彩之處, 會對泛型編程提供關鍵支援。可是, 它最終甚至沒能進入 C++17。

Bjarne Stroustrup 和 Gabriel Dos Reis 在 2003 年發表的論文 [Stroustrup 2003; Stroustrup and Dos Reis 2003a,b] 明確指出, 概念是簡化泛型編程的macro 偉計劃的一部分。例如, 一個 `concept` 可以被定義為一組使用模式的約束, 就是說, 作為對某種類型有效的語言構造 [Stroustrup and Dos Reis 2003b]: 

```cpp
concept Value_type {
    constraints(Value_type a)
    {
        Value_type b = a;      // 拷貝初始化
        a = b;                 // 拷貝賦值
        Value_type v[] = {a};  // 不是引用
    }
};

template<Value_type V>
    void swap(V& a, V& b);  // swap() 的參數必須是值類型
```

但是, 當時的語法和語義還很不成熟。我們主要是試圖建立設計標準 [Stroustrup and Dos Reis 2003a]。從現代 (2018 年) 的角度來看, [Stroustrup 2003; Stroustrup and Dos Reis 2003a,b] 有很多缺陷。但是, 它們為概念提供了設計約束, 並在以下方面提出了建議: 

- 概念——用於指定對模板參數要求的編譯期謂詞。
- 根據使用模式來指定原始約束——以處理重載和隱式類型轉換。
- 多參數概念——例如 `Mergeable<In1,In2,Out>`。
- 類型和值概念——也就是說, 概念既可以將值也可以將類型當作參數, 例如 `Buffer<unsigned char,128>`。
- 模板的“類型的類型”簡寫記法——例如 `template<Iterator Iter> …`。
- “模板定義的簡化記法”——例如 `void f(Comparable&);` 使泛型編程更接近於“普通編程”。
- `auto` 作為函數參數和返回值中約束最少的類型。
- 統一函數呼叫 ([§8.8.3](08.md#883-統一呼叫語法)) ——減少泛型編程與物件導向編程之間的風格差異問題 (例如 `x.f(y)`、`f(x,y)` 和 `x+y`) 。

奇怪的是, 我們沒有建議通用的 `requires` 子句 ([§6.2.2](#622-概念使用)) 。這些都是後面所有概念變體的一部分。

## 6.2 C++0x 概念

2006 年, 基本上每個人都期望 [Gregor et al. 2006; Stroustrup 2007] 中所描述的概念版本會成為 C++09 的一部分, 畢竟它已經投票進入了 C++ 標準草案 (工作檔案) 。但是, C++0x 變成了 C++11, 並且在 2009 年, 概念因複雜性和可用性問題陷入困境 [Stroustrup 2009a,b], 委員會以絶對多數票一致同意放棄概念設計 [Becker 2009]。失敗的原因多種多樣, 而且可能使我們獲得在 C++ 標準化努力之外的教訓。

在 2004 年, 有兩項獨立的工作試圖將概念引入 C++。因為主要支援者分別來自印第安納大學和德克薩斯農工大學, 這兩派通常就被稱為“印第安納”和“德克薩斯”: 

- **印第安納**: 一種與 Haskell 類型類相關的方法, 主要依賴于操作表來定義概念。這派認為, 程式員應當顯式聲明一個類型“模擬”了一個概念; 也就是說, 該類型提供了一組由概念指定的操作 [Gregor et al. 2006]。關鍵人物是 Andrew Lumsdaine (教授) 和 Douglas Gregor (博士後和編譯器作者) 。
- **德克薩斯**: 一種基于編譯期類型謂詞和謂詞邏輯的方法。這派認為, 可用性很重要, 因而程式員**不必**顯式指定哪些類型與哪些概念相匹配 (這些匹配可以由編譯器計算) 。對於 C++, 優雅而有效地處理隱式轉換、重載以及混合類型的表達式被認為是必需的 [Dos Reis and Stroustrup 2006; Stroustrup and Dos Reis 2003b]。關鍵人物是 Bjarne Stroustrup (教授) 和 Gabriel Dos Reis (博士後, 後來成為教授) 。

根據這些描述, 這些方法似乎是不可調和的, 但是對於當時的參與人員而言, 這並不明顯。實際上, 我認為這些方法在理論上是等效的 [Stroustrup and Dos Reis 2003b]。該論點的確可能是正確的, 但對於 C++ 上下文中的詳細語言設計和使用的實際影響並不等同。另外, 按照委員會成員的解釋, WG21 的共識流程強烈鼓勵合作和聯合提案, 而不是在競爭性的提案上工作數年, 最後在它們之間進行大決戰 ([§3.2](03.md#32-組織)) 。我認為後一種方法是創造方言的秘訣, 因為失敗的一方不太可能放棄他們的實現和使用者, 並就此消失。請注意, 上面提到的所有的人在一起與 Jeremy Siek (印第安納的研究生和 AT&amp;T 實驗室的暑期實習生) 和 Jaakko Järvi (印第安那的博士後, 得州農工大學教授) 是 OOPSLA 論文的合著者, 論文展示了折中設計的第一個版本。印第安納和德克薩斯的團體從未完全脫節, 我們為達成真正的共識而努力。另外, 從事這項工作之前, 我已經認識 Andrew Lumsdaine 很多年。我們確實希望折中方案能夠正常工作。

在實現方面, 印第安納的設計的進度遠遠領先於德克薩斯的設計的進度, 並且具有更多人員參與, 所以我們主要基于此進行。印第安納的設計也更加符合常規, 基于函數簽名, 並且與 Haskell 類型類有明顯相似之處。考慮到涉及的學術界人士的數量, 重要的是印第安納的設計被視為更符合常規並且學術上更為得體。看來我們“只是”需要

- 使編譯器足夠快
- 生成有效的程式碼
- 處理重載和隱式轉換。

這個決定使我們付出了三年的辛勤工作和許多爭論。

C++0x 概念設計在 [Gregor et al. 2006; Stroustrup 2007] 中得到闡述。前一篇論文包含一個標準的學術“相關工作”部分, 將這個設計與 Java、C#、Scala、Cecil、ML、Haskell 和 G 中的工具進行比較。在這裡, 我使用 [Gregor et al. 2006] 中的例子進行總結。

### 6.2.1 概念定義

概念被定義為一組操作和相關類型: 

```cpp
concept EqualityComparable<typename T> {
    bool operator==(const T& x, const T& y);
    bool operator!=(const T& x, const T& y) { return !(x==y); }
}

concept InputIterator<typename Iter> {
    // Iter 必須有 value_type 成員: 
    typename value_type = Iter::value_type;
    // ...
}
```

某些人 (印第安納) 認為概念和類之間的相似性是一種優勢。

但是, 概念中指定的函數並不完全類似於類中定義的函數。例如, 在一個 `class` 中定義的運算符具有隱式參數 (“`this`”) , 而 `concept` 中聲明的運算符則沒有。

將概念定義為一組操作的方法中存在一個嚴重的問題。考慮在 C++ 中傳遞參數的方式: 

```cpp
void f(X);
void f(X&);
void f(const X&);
void f(X&&);
```

暫時不考慮 `volatile`, 因為它在泛型程式碼參數中很少見到, 但是我們仍然有四種選擇。在一個 `concept` 中, 我們是否

- 將 `f` 表示為一個函數, 使用者是否為呼叫選擇了正確的參數? 
- 是否重載了 `f` 的所有可能? 
- 將 `f` 表示為一個函數, 並要求使用者定義一個 `concept_map` ([§6.2.3](#623-概念映射)) 映射到 `f` 的所需的參數類型? 
- 語言是否將使用者的參數類型隱式映射到模板的參數類型? 

對於兩個參數, 我們將有 16 種選擇。儘管很少有三個參數泛型函數, 但是這種情況我們會有 4\*4\*4 種選擇。變參模板會如何呢? 我們會有 4<sup>N</sup> 種選擇, 如 ([§4.3.2](04.md#432-變參模板)) 。

傳遞參數的不同方式的語義並不相同, 因此我們自然而然地轉向接受指定的參數類型, 將匹配的負擔推到了類型設計者和 `concept_maps` 的作者 ([§6.2.3](#623-概念映射)) 。

類似地, 我們到底是在為 `x.f(y)` (物件導向樣式) 指定 `concept` 還是為 `f(x,y)` (函數樣式) , 還是兩者兼而有之。這個問題在我們嘗試描述二元運算符時, 例如 `+`, 會立刻出現。

回想起來, 我們對於在以特定類型的操作或特定的偽簽名定義的概念框架內解決這些問題太過樂觀了。“偽簽名”某種程度上代表了對此處概述的問題的解決方案。

概念之間的關係通過顯式**細化**定義: 

```cpp
concept BidirectionalIterator<typename Iter>    // BidirectionalIterator 是
    : ForwardIterator<Iter> {                   // 一種 ForwardIterator
        // ...
}
```

細化有點像, 但又不那麼像類派生。這個想法是為了讓程式員明確地建立概念的層次結構。不幸的是, 這給系統引入了嚴重的不靈活性。概念 (按常規的英語含義) 通常不是嚴格的層次結構。

### 6.2.2 概念使用

一個概念既可以用作 `where` 子句中的推斷, 也可以用作簡寫: 

```cpp
template<typename T>
    where LessThanComparable<T>    // 顯式謂詞
const T& min(const T& x, const T& y)
{
    return x<y ? x : y;
}

template<GreaterThanComparable T>  // 簡寫記法
    const T& max(const T& x, const T& y)
{
    return x>y ? x : y;
}
```

對於簡單的“類型的類型”的概念, 簡寫形式 (最早在 [Stroustrup 2003] 中提出) 很快變得非常流行。但是, 我們很快發現, 現有程式碼中的標識符中 `where` 太過于流行, 於是將其重命名為 `requires`。

### 6.2.3 概念映射

概念和類型之間的關係是由 `concept_map` 的特化來定義的: 

```cpp
concept_map EqualityComparable<int> {};  // int 滿足 EqualityComparable

// student_record 滿足 EqualityComparable: 
concept_map EqualityComparable<student_record> {
    bool operator==(const student_record& a, const student_record& b)
    {
        return a.id_equal(b);
    }
};
```

對於 `int`, 我們可以簡單地說 `int` 類型具有 `EqualityComparable` 所要求的屬性 (也就是說, 它具有 `==` 和 `!=`) , 然而, `student_record` 沒有 `==`, 但是我們可以在 `concept_map` 中添加一個。因此, `concept_map` 是一種非常強大的機制, 可以在特定的環境中非侵入性地往類型中添加屬性。

既然編譯器已經知道 `int` 是可比較的, 為什麼我們還要再告訴編譯器?

這一直是一個爭論的焦點。“印第安納小組”一般認為明確表達意圖 (永遠) 是好的, 而“德克薩斯小組”傾向于認為除非一條概念映射能增加新的功能, 寫它就不只是沒用, 更可能有害。顯式的聲明是否能使使用者避免因為語義上無意義的“意外”語法匹配而導致的嚴重錯誤? 還是說這種錯誤會很少見, 顯式的建模語句多半隻是增加了編寫麻煩和犯錯誤的機會? 折中的解決方案是允許在 `concept` 的定義處通過加上 `auto` 來聲明使用某條 `concept_map` 是可選的: 

```cpp
auto concept EqualityComparable<typename T> {
    bool operator==(const T& x, const T& y);
    bool operator!=(const T& x, const T& y) { return !(x==y); }
}
```

這樣, 當一個類型被要求是 `EqualityComparable` 時, 即使使用者沒有提供該類型的特化, 編譯器也會自動使用指向 `EqualityComparable` 的 `concept_map`。

### 6.2.4 定義檢查

編譯器根據模板參數的概念檢查模板定義中的程式碼: 

```cpp
template<InputIterator Iter, typename Val>
    requires EqualityComparable<Iter::value_type,Val>
Iter find(Iter first, Iter last, Val v)
{
    while (first<last && !(*first==v))  // 錯誤: EqualityComparable 中沒有 <
        ++first;
    return first;
}
```

這裡我們用到了 `<` 比較迭代器, 但 `EqualityComparable` 只保證了 `==`, 因此這個定義不能通過編譯。捕獲這種無保障操作的使用那時被視為一個重要的好處, 但是事實證明這會帶來嚴重的負面影響:  ([§6.2.5](#625-教訓)) 和 ([§6.3.1](#631-定義檢查)) 。

### 6.2.5 教訓

初始提案得到了相對迅速的批准, 之後的若干年, 我們忙於為初始的設計堵漏, 還要應付在通用性、可實現性、規範質量和可用性方面的意見。

作為主要實現者, Doug Gregor 為生成高質量的程式碼做出了英勇的表現, 但最終, 支援概念的編譯器在速度上仍然比只實現了無約束模板的編譯器慢了 10 倍以上。我懷疑實現問題的根源是在編譯器中採用類的結構來表示概念。這樣可以快速獲得早期結果, 但卻讓概念用上了本來為類精心打造的表示方式, 但概念並不是類。將概念表示為一組函數 (類似於虛成員函數) , 導致在處理隱式轉換和混合類型操作時出問題。將來自不同上下文的程式碼靈活的加以組合, 原本是支撐泛型編程和元編程的強大程式碼生成技術的“秘訣”, 但這種組合卻無法使用 C++0x 的概念來指定。要趕上 (無約束的) 模板性能, 用於指定概念的函數就不能作為可被呼叫的函數出現在生成的程式碼中 (更糟糕的是, 間接的函數呼叫也不行) 。

我不愉快地聯想到了許多早期 C++ 編譯器作者由於採用了 C 編譯器的結構和程式碼庫而遇到的問題, 當時用來處理 C++ 作用域和重載的程式碼沒法合適地放到 C 語言的編譯器框架中。本着設計概念應該直接以程式碼表示的觀點, Cfront ([§2.1](02.md#21-第一個十年)) 使用了特定的作用域類來避免這種問題, 然而, 大多數 C 語言背景的編譯器作者認為他們可以使用熟悉的 C 技巧走捷徑, 最終還是不得不從頭開始重寫 C++ 前端程式碼。語言設計和實現技巧可以非常強烈地彼此影響。

很快, 事情就變得很明顯: 為了完成從無約束的模板到使用概念的模板的轉換, 我們需要語言支援。在 C++0x 的設計中, 這兩類模板非常不同: 

- 受約束模板不能呼叫無約束模板, 因為不知道無約束模板使用什麼操作, 因此無法對受約束模板進行定義檢查。
- 無約束模板可以呼叫受約束模板, 但是檢查必須推遲到實例化的時候, 因為在那之前我們不知道無約束模板在呼叫中使用什麼類型。

第一個問題的解決方案是允許程式員使用 `late_check` 塊, 告訴編譯器“別檢查這些來自受約束模板的呼叫” [Gregor et al. 2008]: 

```cpp
template<Semigroup T>
T add(T x, T y) {
    T r = x + y;    // 用 Semigroup<T>::operator+
    late_check {
        r = x + y;  // 使用在實例化的時候找到的 operator+
                    //  (不考慮 Semigroup<T>::operator+) 
    }
    return r;
}
```

這一“解決方案”充其量只能算是個補丁, 而且有一個特殊的問題, 即呼叫到的無約束模板中不會知道 `Semigroup` 的 `concept_map`。這樣就導致一個“有趣效果”, 即一個對象可以在一段程式的兩個地方以一模一樣的方式被使用, 但卻表達不同的語義。這樣一來, 類型系統就以一種實在難以追蹤的方式被破壞了。

隨着概念的使用越來越多, 語義在概念 (實際上是類型和庫) 設計中的作用變得越來越清晰, 委員會中的許多人開始推動一種表達語義規則的機制。這並不奇怪, Alex Stepanov 喜歡說“概念全都是語義問題”。然而, 大部分人那時都像對待其他語言功能一樣對待概念, 他們更關心語法和命名查找規則。

2009年, Gabriel Dos Reis (在我大力支援下) 提出了一種稱為 `axiom` (公理) 的記法並獲得批准 [Dos Reis et al. 2009]: 

```cpp
concept TotalOrdering<typename Op, typename T> {
    bool operator()(Op, T, T);
    axiom Antisymmetry(Op op, T x, T y) {
        if (op(x, y) && op(y, x))
            x <=> y;
    }
    axiom Transitivity(Op op, T x, T y, T z) {
    if (op(x, y) && op(y, z))
        op(x, z);
    }
    axiom Totality(Op op, T x, T y) {
        op(x, y) || op(y, x);
    }
}
```

奇怪的是, 要讓公理的概念被接受很困難。主要的反對意見似乎是, 提議者們明確拒絶了讓編譯器針對它們所使用的類型來對公理進行測試“以捕獲錯誤”的想法。顯然, `axiom` 就是數學意義上的公理 (也就是說, 是因為你通常無法檢查而允許作的一些假設) , 這一觀念對於某些委員是陌生的。另外一些人則不相信指定公理還可以幫助編譯器以外的工具。不過, `axiom` 還是被納入了 `concept` 規範中。

我們在概念的定義和實現上都存在明顯的問題, 但我們有了一套相當完整的工具, 努力地試圖通過使用標準程式庫 [Gregor and Lumsdaine 2008] 和其他庫中定義的概念來解決這些問題並獲得經驗。

### 6.2.6 哪裡出錯了? 

2009年, 我不情願地得出結論, 概念工作陷入了困境。我期望能被我們解決掉的問題仍在加劇, 而新的問題又層出不窮: 

- 我們仍然沒有達成一致意見, 在大多數情況下, 到底應使用隱式還是顯式建模 (隱式或顯式使用 `concept_map`) , 哪種才是正確的方法。
- 我們仍然沒有達成一致意見, 是要依賴概念之間隱式還是顯式的關係陳述 (我們是否應該以某種非常類似物件導向的繼承的方式, 顯式地構建“精化”關係的層次結構? ) 。
- 我們仍不斷看到一些實例, 由受概念約束的程式碼生成出來的程式碼不及無約束模板生成出來的程式碼。來自模板的後期組合機會仍然顯示出驚人的優勢。
- 編寫概念來捕獲我們在泛型和非泛型 C++ 中慣于使用的每種轉換和重載情況仍然很困難。
- 我們看到了越來越多的例子, 這些例子中, 足夠複雜的 `concept_map` 和 `late_check` 的組合導致了對類型的不一致的看法 (也就是對類型系統的驚人和几乎無法追蹤的破壞) 。
- 標準草案中規範的複雜性吹氣球般迅速膨脹, 超出了所有人的預期 (有 91 頁, 這還不包括庫中對概念的使用) , 我們中的一些人認為它基本上不可讀。
- 用於描述標準程式庫的概念集越來越大 (大約有 125 個概念, 僅 STL 就有 103 個) 。
- 編譯器在程式碼生成方面越來越好 (因為 Doug Gregor 的英勇努力) , 但速度仍未提高。一些主要的編譯器供應商私下裡向我透露, 如果一個支援概念的編譯器比舊的編譯器慢 20% 以上, 他們就不得不反對這些概念, 不管它們有多好。當時, 支援概念的編譯器要慢 10 倍以上。

在 2009 年春季, 在標準的郵件群組上進行過一場廣泛的討論。起頭的是 Howard Hinnant, 他提出一個關於概念使用的非常實際的問題: 他正在設計的工具可以通過兩種方式來完成: 一種將需要大量使用者——不一定是專家使用者——編寫概念映射。另一種——遠不夠優雅的——設計將避免使用概念映射 (和概念) , 以免要求使用者瞭解有關概念的任何重要知識。“普通使用者”需要理解概念嗎? 理解到足以使用它們就行? 還是要能理解到足以定義它們? 

這個討論主題後來被稱作“碼農小明是否需要概念? ”。誰是“碼農小明”? Peter Gottschling 問道。這是個好問題, 我回答道: 

> 我認為大多數 C++ 程式員都是“碼農小明” (我再次表示反對該術語) , 我大部分時間和使用大多數庫的時候都是“碼農小明”, 我預料我一直都會是, 因為我會一直保持學習新技術和庫。但是, 我想使用概念 (並且在必要時使用概念映射) , 我希望“使用原則”比現在這樣僅供專家使用的精細功能要簡單得多。

換句話說, 我們是應該將概念設計成為供少數語言專家進行細微控制的精密設備, 還是供大多數程式員使用的健壯工具? 在語言特性和標準程式庫組件的設計中, 這個問題反覆出現。關於類, 我多年以來都聽到這樣的聲音; 某些人認為, 顯然不應該鼓勵大多數程式員定義類。在某些人眼裡, 普通的程式員 (有時被戲稱為“碼農小明”) 顯然不夠聰明或沒有足夠的知識來使用複雜的特性和技巧。我一向強烈認為大多數程式員可以學會並用好類和概念等特性。一旦他們做到了, 他們的編程工作就變得更容易, 並且他們的程式碼也會變得更好。整個 C++ 社區可能需要花費數年的時間來吸取教訓; 但是如果做不到的話, 我們——作為語言和庫的設計者——就失敗了。

為了回應這場討論, 並反映我對 C++0x 概念的工作方向的日益關注, 我寫了一篇論文 *Simplifying the use of concepts* [Stroustrup 2009c] 概述了在我看來要讓概念在 C++0x 中變得可接受所必須做的最小改進: 

- 儘量少使用 `concept_map`。
- 使所有 `concept_map` 隱式/自動化。
- 概念如需要 `begin(x)`, 那它也得接受 `x.begin()`, 反之亦然 (統一函數呼叫) ;  ([§6.1](#61-概念的早期歷史)) ,  ([§8.8.3](08.md#883-統一呼叫語法)) 
- 使所有標準程式庫概念隱式/自動化。

這篇論文非常詳細地包含了多年來出現的許多例子和建議。

我堅持讓**所有**概念都成為隱式/自動的原因之一是觀察到, 如果給一個選擇, 最不靈活和最不輕信的程式員可能會強迫每個人都接受他們所選擇的顯式概念。庫作者們表現出一種強烈的傾向, 即通過使用顯式的 (非自動的) 概念把決策推到使用者那去做, 即便是對於那些最明顯的選擇也一樣。

我當時注意到, C++ 泛型編程之父 Alex Stepanov 不久之前所寫的《編程原本》 (*Elements of Programming*) [Stepanov and McJones 2009] 並沒有使用哪怕是一條 `concept_map` 來描述 STL 工具的超集和當時常見的泛型編程技術的超集。

委員展開了一次討論回應我的論文, 焦點是, 為了及時加入標準, 我們是否來得及達成共識。結論也很顯然, 沒多大希望。我們沒法同意“修補”概念讓它對大多數程式員可用, 同時還能 (多少) 及時地推出標準。這樣, “概念”, 這個許多有能力的人多年工作的成果, 被移出了標準草案。我對“刪除概念”決定的總結 [Stroustrup 2009a,b] 比技術論文和討論更具可讀性。

當委員會以壓倒多數投票贊成刪除概念時 (我也投票贊成刪除) , 每個發言的人都再次確認他們想要概念。投票只是反映出概念設計還沒有準備好進行標準化。我認為問題要嚴重得多: 委員會想要概念, 但委員們對他們想要什麼樣的概念沒有達成一致。委員會沒有一套共同的設計目標。這仍然是一個問題, 也不僅僅出現在概念上。委員之間存在着深刻的“哲學上”的分歧, 特別是: 

- **顯式還是隱式**: 為了安全和避免意外, 程式員是否應該顯式地說明如何從潛在可選方案中做決策? 該討論最終涉及有關重載決策、作用域決策、類型與概念的匹配、概念之間的關係, 等等。
- **專家與普通人**: 關鍵語言和標準程式庫工具是否應該設計為供專家使用? 如果是這樣, 是否應該鼓勵“普通程式員”只使用有限的語言子集, 是否應該為“普通程式員”設計單獨的庫? 這個討論出現在類、類層次結構、異常、模板等的設計和使用的場景中。

這兩種情況下, 回答“是”都會使功能的設計偏向于複雜的特性, 這樣就需要大量的專業知識和頻繁使用特殊寫法才能保證正確。從系統的角度, 我傾向于站在這類論點的另一端, 更多地信任普通程式員, 並依靠常規語言規則, 通過編譯器和其他工具進行檢查以避免令人討厭的意外。對於棘手的問題, 採用顯式決策的方式比起依靠 (隱式) 的語言規則, 程式員犯錯的機會只多不少。

不同的人從 C++0x 概念的失敗中得出了不同的結論, 我得出三點主要的: 

- 我們過分重視早期實現。我們原本應該花更多的精力來確定需求、約束、期望的使用模式, 以及相對簡單的實現模型。此後, 我們可以依靠使用反饋來讓我們的實現逐步增強。
- 有些分歧是根本的 (哲學上的) , 無法通過折中解決, 我們必須儘早發現並闡明此類問題。
- 沒有一套功能集合能做到既滿足一個大型專家委員會的所有不同願望, 又不會變得過分龐大, 這種膨脹會成為實現者的難題和使用者的障礙。我們必須確定核心需求, 並用簡單的寫法來滿足; 對於更複雜的用法和罕見的用例, 則可以用對使用者的專業知識要求更高的功能和寫法。

這些結論與概念沒有什麼特別的關係。它們是對大團體內的設計目標和決策過程的一般觀察。

## 6.3 Concepts TS

2009 年, 几乎是在概念剛從 C++0x 移除之後, Gabriel Dos Reis、Andrew Sutton 和我開始重新設計概念。這次設計是根據我們最初的想法、從 C++0x 語言設計中得到的經驗、使用 C++0x 概念的經驗, 以及標準委員會的反饋。我們的結論是

- 概念必須有語義上的意義
- 概念數量應該相對較少
- 概念應該基本, 而非最小

我們認為 C++ 標準程式庫中包含的大部分單獨使用的概念是沒有意義的 [Sutton and Stroustrup 2011]。“對於任何合理的‘概念’定義, STL 都用不了 103 個‘概念’! ”我在和 Andrew Sutton 的討論中大聲嚷道, “基礎代數都沒有超過十幾個概念! ”語言設計的討論可以變得相當熱烈。

2011年, 在 Andrew Lumsdaine 的敦促下, Alex Stepanov 在 Palo Alto 召集了為期一周的會議。一個相當大的團隊, 包含了大多數與 C++0x 概念工作密切相關的人, 加上 Sean Parent 和 Alex Stepanov, 一起討論從使用者的角度來解決這個問題: 理想情況下, 一個被適度約束的 STL 演演算法集應當是什麼樣子? 然後, 我們回家記錄我們以使用者為導向的設計, 並發明語言機制以接近這個理想設計 [Stroustrup and Sutton 2012]。這一努力重新啟動了標準工作, 而且使用的是一種全新的、與 C++0x 工作完全不同且更好的方法。2016 年 ISO 出版的概念的 TS (技術規範) [Sutton 2017] 和 C++20 概念 ([§6.4](#64-c20-概念)) 就是該會議的直接結果。Andrew Sutton 的實現從 2012 年開始就被用於實驗, 並作為 GCC 6.0 或更高版本的一部分發佈。

在 Concepts TS 中 [Sutton 2017]

- 概念基于編譯期謂詞 (包括多參數謂詞和值參數) 。
- 以使用模式來描述原始要求 [Dos Reis 和 Stroustrup 2006] (`requires` 表達式) 。
- 概念可以用在一般的 `requires` 子句中, 當作模板形參定義中 `typename` 的替代, 也可以當作函數形參定義中類型名的替代。
- 從類型到概念的匹配是隱式的 (沒有 `concept_map`) 。
- 重載中概念間是隱式的關係 (通過計算得出, 而不需要為概念進行顯式細化) 。
- 沒有定義檢查 (至少目前還沒有, 所以也沒有 `late_check`) 。
- 沒有 `axiom`, 但這只是因為我們不想因為一個潛在有爭議的特性而讓設計更加複雜、產生拖延。C++0x 的 `axiom` 也可以是一個好起點。

與 C++0x 的概念相比, 這裡非常強調簡化概念的使用, 其中的一個主要部分是不要求程式員做顯式表達, 而讓編譯器根據明確規定的、簡單的演演算法來解決問題。

支援由使用者顯式決策的人認為以上的方案重語義而輕語法, 並警告會有“意外匹配”和“驚嚇”。最常見的例子是 `Forward_iterator` 與 `Input_iterator` 的區別僅在於語義: `Forward_iterator` 允許在其序列中做多遍掃瞄。沒有人否認這種例子的存在, 但圍繞這些例子的重要性以及如何解決它們的爭論卻沒斷過 (仍然很起勁) 。我認為讓幾個罕見的複雜例子主導設計是大錯特錯。

Concepts TS 設計是基于這樣的看法 (有大量經驗支援) , 即上面這樣的例子非常罕見 (特別是在精心設計的概念中 [Stroustrup 2017]) , 通常被概念編寫者很好地理解, 而且常常可以通過在最受約束的概念上添加操作以反映語義上的差異來解決。例如, `Forward_iterator`/`Input_iterator` 問題的一個簡單解決方案是要求 `Forward_iterator` 提供一個 `can_multipass()` 操作。此操作甚至不需要做任何事情; 它存在只是為了讓概念決策機制能夠檢查它的存在。因此, 不需要專門添加新的語言特性來解決可能出現的意外歧義。

因為這一點經常被忽視, 我必須強調, 概念是謂詞, 它們不是類或類層次結構。根本上, 我們只是問某個類型一些簡單的問題, 如“你是迭代器嗎? ”並問類型的集合關於它們的互操作的問題, 如“你們之間能用 `==` 來相互比較嗎? ” ([§6.3.2](#632-概念使用)) 。使用概念時, 我們只問那些可以在編譯期回答的問題, 不涉及運行期求值。潛在的歧義是通過比較類型 (或類型集合) 所涉及的謂詞來檢測的, 而不是讓程式員寫決策規則 ([§6.3.2](#632-概念使用)) 。

出於對 C++0x 概念 ([§6.2.6](#626-哪裡出錯了)) 中所發生問題的敏感, 我們小心翼翼地設計概念, 以求使用它們不會隱含顯著的編譯期開銷。即使是 Andrew Sutton 的編譯器的早期版本, 編譯使用了概念的模板的速度也比編譯使用變通方案 (例如 `enable_if` ([§4.5.1](04.md#451-實現技巧)) ) 的程式要**快**。

### 6.3.1 定義檢查

在 Palo Alto 會議後幾個月之內的某個時間點, Andrew Sutton、Gabriel Dos Reis 和我做出決定, 分階段着手設計和實現概念的語言特性。這樣, 我們可以從實現的經驗中學習, 並在“設計凍結”之前獲得早期的反饋。特別是, 我們決定推遲實現**定義檢查** ([§6.2.4](#624-定義檢查)) ; 也就是說, 檢查並確保模板沒有使用並未為其參數指定的功能。考慮 `std::advance()` 的一個簡化版本, 它將迭代器在序列中向前移動 `n` 個位置: 

```cpp
template<Forward_iterator Iter>
void advance(Iter p, int n)
{
    p+=n;  // p 前進 n 個位置
}
```

`Forward_iterator` 不提供 `+=`, 只提供 `++`, 所以定義檢查會把它當作錯誤抓出來。如果不單獨 (在使用前) 檢查 `advance()` 的函數體, 我們將只會從 `+=` 的 (錯誤) 使用中得到糟糕的實例化時的錯誤訊息, 請注意, 模板實例化生成的程式碼總會經過類型檢查, 所以不做定義檢查不會導致運行期錯誤。

我們認為, 概念帶來的約 90% 的好處會從使用點檢查中收穫, 而對於那些相對專家級的受約束模板作者來說, 沒有定義檢查也能將就一段時間。這裡 90% 顯然是基于有限訊息的臨時估計, 但得益於十年間在概念上的工作, 我認為這是一個不錯的猜測。作為語言特性和庫的設計者, 對我們來說, 更重要的是從使用中獲得經驗, 這一經驗獲得的過程始於 Palo Alto 技術備忘錄 [Stroustrup and Sutton 2012] 中的 STL 演演算法範例。我們重視反饋勝於重視理論完整性。這種看法曾是激進的。回顧一下關於概念的文件 (在 C++ 和其他語言中) , 之所以將概唸作為語言特性提供, 定義檢查總是被強調成一個主要原因 [Gregor et al. 2006; Stroustrup and Dos Reis 2003b]。

這種新設計一度被稱為**輕量概念** (Concepts Lite) , 許多人認為它不完整, 甚至沒用。但是, 我們很快發現, **不**進行定義檢查會帶來真正的好處 [Sutton and Stroustrup 2011]。

- 有了定義檢查, 我們在開發過程中就沒辦法使用部分概念檢查。在構建一個大程式的初始階段中, 不知道全部的需求是非常常見的。部分檢查可以讓很多錯誤在早期被發現, 並有助于根據早期使用的反饋逐步改進設計。
- 定義檢查使得設計難以擁有穩定的介面。特別是, 要往類或者函數中增加除錯語句、統計收集、追蹤或者“遙測”之類的支援, 就不能不改變類或函數的介面來包含相應功能。這些功能對於類或函數來說很少是根本的, 而且往往會隨着時間的推移而改變。
- 當我們不使用定義檢查時, 現有的模板可以逐漸轉換為使用概念。但是, 如果我們有定義檢查, 一個受約束的模板就不能使用一個無約束的模板, 因為我們一般沒法知道無約束的模板使用了哪些功能。另外, 不管做不做定義檢查, 一個無約束的模板使用一個有約束的模板都意味着後期 (實例化時) 檢查。

從 2014 年起擔任 EWG 主席的 Ville Voutilainen 更為堅定地表示: 

> 我不能支援任何包含定義檢查的概念提案。

我們最終可能會得到一種定義檢查的形式, 但前提是我們能夠設計一種機制來避開它, 以滿足過渡和資料收集的需要。這需要仔細考慮, 需要進行實驗。C++0x 的 `late_check` 是不夠的。

定義檢查的問題是使用的問題, 而不是實現的問題。Gabriel Dos Reis 設計並實現了一種名為 Liz 的實驗語言, 用來測試 Concepts TS 設計中的功能 [Dos Reis 2012], 包括定義檢查。如果我們找到一種可接受的定義檢查形式, 我們就可以實現它。

### 6.3.2 概念使用

簡單的範例看起來很像 C++0x 及更早的版本中的樣子: 

```cpp
template<Sequence Seq, Number Num>
Num sum(Seq s, Num v)
{
    for (const auto& x : s)
        v += x;
    return v;
}
```

這裡 `Sequence` 和 `Number` 是概念。使用概念而不是 `typename` 來引入類型的名稱, 意味着使用的類型必須滿足概念的要求。需要注意的是, 由於 Concepts TS 不提供定義檢查, 所以使用 `+=` 不會被概念所檢查, 而只會在後期、在實例化時檢查。以上是最初的開發階段中可能的做法, 稍後我們很可能會更為明確: 

```cpp
template<typename T>
using Value_type = typename T::value_type;  // 簡化的別名

template<Sequence Seq, typename Num>
    requires Arithmetic<Value_type<Seq>,Num>
Num sum(Seq s, Num v)
{
    for (const auto& x : s)
        v += x;
    return v;
}
```

也就是說, 我們必須有算數運算符, 包括 `+=`, 以供 `Sequence` 的值類型和我們用作累加器的類型的組合使用。我們不再需要說明 `Num` 為 `Number`, `Arithmetic` 會檢查 `Num` 具有所需的一切屬性。在這裡, `Arithmetic` 被顯式地用作 (C++0x 風格的) `requires` 子句中的謂詞。

重載是通過挑選具有最嚴格要求的函數來處理。考慮標準程式庫中的經典函數 `advance` 的一個簡單版本: 

```cpp
template<Forward_iterator Iter>
void advance(Iter p, int n)  // 將 p 向前移動 n 個元素
{
    while (--n)
        ++p;  // 前向迭代器有 ++, 但沒有 + 或者 +=
}

template<Random_access_iterator Iter>
void advance(Iter p, int n)  // 將 p 向前移動 n 個元素
{
    p += n;  // 隨機迭代器有 +=
}
```

也就是說, 我們應該對提供隨機訪問的序列使用第二個版本, 對只提供前向迭代的序列使用第一個版本。

```cpp
void user(vector<int>::iterator vip, list<string>::iterator lsp)
{
    advance(vip, 10);  // 使用較快的 advance()
    advance(lsp, 10);  // 使用較慢的 advance()
}
```

編譯器將這兩個函數的概念分解為原始 (“原子”) 要求, 由於前向迭代的要求是隨機訪問迭代要求的嚴格子集, 所以這個例子可以被解決。

當一個參數類型同時匹配到互相之間不是嚴格子集的重疊要求時, 會產生歧義 (編譯期錯誤) 。例如: 

```cpp
template<typename T>
    requires Copyable<T> && Integral<T>
T fct(T x);

template<typename T>
    requires Copyable<T> && Swappable<T>
T fct(T x );

int x = fct(2);  // 有歧義: int 滿足 Copyable、Integral 和 Swappable
auto y = fct(complex<double>{1,2});  // OK: complex 不滿足 integral
```

程式員唯一能利用的控制機制是在定義概念時為其增加操作。不過對於現實世界的例子來說, 這似乎已經足夠了。當然, 你可以定義一些只在語義上有差異的概念, 這樣就沒有辦法根據我們的純語法概念來區分它們。然而, 要避免這樣做並不困難。

### 6.3.3 概念的定義

通過 `requires` 表達式的使用模式可指定概念的原始要求: 

```cpp
template<typename T, typename U =T>
concept Equality_comparable =
    requires (T a, U b) {
        { a == b } -> bool ; // 使用 == 比較 T 和 U 得到一個 bool 值
        { a != b } -> bool ; // 使用 != 比較 T 和 U 得到一個 bool 值
     };
```

`requires` 表達式是 Andrew Sutton 發明的, 作為他實現 Concepts TS 的一部分。事實證明它們非常有用, 以至于使用者堅持認為它們應該成為標準的一部分。

`=T` 為第二個類型參數提供預設值, 因此概念 `Equality_comparable` 可以用於單個類型。

使用模式的寫法是 Bjarne Stroustrup 基于 2003 年的想法在 Palo Alto 的現場會議上發明的 [Stroustrup and Dos Reis 2003b]。這種寫法及其思想並不涉及函數簽名或函數表的實現。

不存在特定的機制來表達類型與概念相匹配, 但如果有人要這麼做, 可以使用 C++11 中普通的 `static_assert`: 

```cpp
static_assert(Equality_comparable<int>);       // 成功
static_assert(Equality_comparable<int,long>);  // 成功
struct S { int a; };
static_assert(Equality_comparable<S>);    // 失敗了, 因為結構體不會
                                          // 自動生成 == 和 != 操作
```
來自 C++0x (及更早的 [Stroustrup 2003]) 中的關聯類型表示法也得到了支援: 

```cpp
template<typename S>
concept Sequence = requires(S a) {
  typename Value_type<S>;             // S 必須具有值類型。
  typename Iterator_type<S>;          // S 必須具有迭代器類型。

  { begin(a) } -> Iterator_type<S>;   // begin(a) 必須返回一個迭代器。
  { end(a) } -> Iterator_type<S>;     // end(a) 必須返回一個迭代器。
  { a.begin() } -> Iterator_type<S>;  // a.begin() 必須返回一個迭代器。
  { a.end() } -> Iterator_type<S>;    // a.end() 必須返回一個迭代器。

  requires Same_type<Value_type<S>,Value_type<Iterator_type<S>>>;
  requires Input_iterator<Iterator_type<S>>;
};
```
注意上面的程式碼有重複, 這是為了可以同時接受 `a.begin()` 和 `begin(a)`。缺少統一函數呼叫讓人頭疼 ([§6.1](#61-概念的早期歷史)) 、 ([§8.8.3](08.md#883-統一呼叫語法)) 。

### 6.3.4 概念名稱引導器

從使用中我們學到的一件事情是, 基礎概念的使用有很多重複。我們在 `requires` 語句中直接使用了太多的 `requires` 表達式, 並且使用了太多“小”概念。我們的概念要求看起來像新手程式員編寫的程式碼: 很少的函數, 很少的抽象, 很少的符號名。

考慮標準的 `merge` 家族函數。這些函數都接受三個序列的輸入並需要指明這些序列之間的關係。因此就有了對序列類型的三個要求和描述序列元素之間關係的三個要求。第一次嘗試: 

```cpp
template<Input_iterator In1, Input_iterator In2, Output_iterator Out>
    requires Comparable<Value_type<In1>,Value_type<In2>>
    && Assignable<Value_type<In1>, Value_type<Out>
    && Assignable<Value_type<In2>, Value_type<Out>
Out merge(In1, In1, In2, In2, Out);
```

這種形式太乏味了; 而且, 這種引入類型名稱的模式非常常見。例如, STL 中至少有四個 `merge` 函數。乏味且重複的程式碼非常容易出錯, 也難以維護。我們很快學會了更多使用多參數概念來定義類型間要求的共同模式: 

```cpp
template<Input_iterator In1, Input_iterator In2, Output_iterator Out>
    requires Mergeable<In1,In2,Out>
Out merge(In1, In1, In2, In2, Out);
```

對於 Andrew Sutton 來說, 這還是太混亂了。他在 2012 年使用概念編寫的程式碼量可能超過任何其他人。他提出了一種機制來表達“為滿足一個概念的多個類型引入一個類型名集合”。這樣將 `merge` 的範例減少到了邏輯上的最少限度: 

```cpp
Mergeable{In1,In2,Out} // 概念名稱引導器
Out merge(In1, In1, In2, In2, Out);
```

僅僅通過嘗試, 你就能學到很多東西, 這真是令人驚嘆! 同樣令人驚嘆的是, 對於那些尚未經歷過這些問題的人, 新穎的表示法和解決方案在他們那裡也會遭遇巨大的阻力。

### 6.3.5 概念和類型

許多人仍然將概念視為 (無論過去和現在) 類型的類型這個想法的變體。是的, 只有一個類型參數的概念可以看作是一個類型的類型, 但只有最簡單的用法才適合該模式。

大多數泛型函數 (演演算法) 都需要不止一個模板參數, 要讓這樣的函數有意義, 這些參數類型必須以某種方式關聯起來。因此, 我們必須使用多參數概念。例如: 

```cpp
template<Forward_iterator Iter, typename Val>
    requires Equality_comparable<Value_type<Iter>,Val>
Forward_iterator find(Iter first, Iter last, Val v)
{
    while (first!=last && *first!=v)
        ++first;
    return first;
}
```

至關重要的是, 多參數概念直接解決了處理隱式轉換和混合類型操作的需求。早在 2003 年, 我就和 Gabriel Dos Reis 一起考慮過將每個參數的所有約束條件與其他參數隔離開來說明的可能性 [Stroustrup 2003; Stroustrup and Dos Reis 2003b]。這將涉及

- 參數化 (例如, 用值類型來參數化的 `Iterator`) 
- 某種形式的繼承 (例如, `Random_access_iterator` 是一個 `Forward_iterator`) 
- 能對一個模板參數應用多個概念的能力 (例如, 一個 `Container` 的元素必須滿足 `Value_type` 和 `Comparable`) 
- 這三種技術的組合。

結果是非常複雜的模板參數類型約束。我們認為這種複雜性是不必要的, 也無法進行管理。譬如 `x+y` 和 `y+x`, 其中 `x` 和 `y` 具有不同的模板參數類型, `X` 和 `Y`。在處理各自的模板參數時, 我們必須將 `X` 和 `Y` 以及 `Y` 和 `X` 進行參數化。在純物件導向語言中, 這看起來很自然。畢竟, 有兩種方法可以進行 `+` 運算, 一種在 `X` 的層次結構中, 一種在 `Y` 的層次結構中。然而, 我早在 1982 年就拒絶了 C++ 的這個解決方案。要完成這一圖景, 我們必須添加隱式類型轉換 (例如, 處理 `x+2` 和 `2+x`) 。而多參數概念與 C++ 解決此類場景的方式完全吻合, 並避免了大部分的複雜性。

這個決定經過多年的反覆審查並得到確認。在設計 C++0x 概念的努力中, 人們嘗試應用了標準的學術系統, 正如在 Haskell 類型類 (typeclass) 和 Java 約束中可見的。但是, 這些做法最終不能提供在大規模使用中所需要的實現和使用上的簡單性。

當一個泛型用法符合類型的類型這一模式時, 概念能非常優雅地支援它。

- **類型**指定了一組可以 (隱式和顯式) 應用於對象的操作, 依賴于函數聲明和語言規則, 並會指定對象在記憶體中如何佈局。
- **概念**指定了一組可以 (隱式和顯式) 應用於對象的操作, 依賴于可以反映函數聲明和語言規則的使用模式, 並且不涉及對象的佈局。因此, 概念是一種介面。

我的理想是, 能用類型的地方就能用概念, 並且使用方式相同。除了定義佈局外, 它們非常相似。概念甚至可以用來約束由其初始化器來確定其類型的變數類型 (受約束的 `auto` 變數 ([§4.2.1](04.md#421-auto-和-decltype)) ) 。例如: 

```cpp
template<typename T>
concept Integer = Same<T,short> || Same<T,int> || Same<T,long>;

Integer x1 = 7;
int x2 = 9;

Integer y1 = x1+x2;
int y2 = x2+x1;

void f(int&);      // 一個函數
void f(Integer&);  // 一個函數模板

void ff()
{
    f(x1);
    f(x2);
}
```

C++20 離實現這一理想接近了。為了使該例子能在 C++20 中工作, 我們必須在每個 `Integer` ([§6.4](#64-c20-概念)) 概念後添加一個邏輯上冗餘的 `auto`。另一方面, 在 C++20 中, 我們可以使用標準程式庫裡的 `integral` 概念來替換明顯不完整的 `Integer`。

### 6.3.6 改進

在 Concepts TS 工作的初期, 一個 `concept` 是一個返回 `bool` 值的 `constexpr` 函數 ([§4.2.7](04.md#427-constexpr-函數)) 。這很合理, 因為我們把概念看作是編譯期的謂詞。然後 Gabriel Dos Reis 將變數模板引入到 C++14 ([§5.2](05.md#52-變數模板)) 中。現在, 我們有了選擇: 

```cpp
// 函數風格: 
template<typename T>
concept bool Sequence() { return Has_begin<T>() && Has_end<T>(); }

// 表達式風格: 
template<typename T>
concept bool Sequence = Has_begin<T> && Has_end<T>;
```

我們可以愉快地使用任何一種風格, 但是如果兩種風格都允許的話, 使用概念的使用者就必須知道概念定義中使用了哪種風格, 否則無法正確使用括號。很快這就成了一個大麻煩。

函數式風格允許概念重載, 但是我們只有很少的概念重載例子; 於是我們決定沒有概念重載也可以。因此, 我們進行了簡化, 只使用變數模板來表達概念。Andrew Sutton 率先全面使用了概念的表達式形式。

我們 (Andrew Sutton、Gabriel Dos Reis 和我) 始終知道, 顯式寫出 `concept` 返回 `bool` 是多餘的。畢竟, 概念從定義上來看就是一個謂詞。然而, 我們決定不去搞亂語法而專注于語義上的重要話題。後來, 人們總是將冗餘的 `bool` 作為一個反對概念設計的論點, 因此我們對其進行了修正, 不再提到 `bool`。

刪除 `bool` 是 Richard Smith 提出的一系列改進建議的一部分, 其中還包括更精確地描述什麼是原子謂詞, 以及對匹配規則的簡化 [Smith and Sutton 2017]。現在, 我們使用表達式風格: 

```cpp
// 表達式風格: 
template<typename T>
concept Sequence = Has_begin<T> && Has_end<T>;
```

### 6.3.7 等效語法

Concepts TS 支援在函數聲明中使用概念的三種表示法: 

- 為通用起見, 顯式使用 `requires` 語句
- 簡寫表示法, 用於表示類型的類型
- 自然表示法 (也稱為簡短表示法、常規表示法等) 

基本思想是, 讓程式員使用與特定聲明的需求緊密匹配的表示法, 而不會因使用更複雜聲明所需的表示法而淹沒該定義。為了使程式員可以自由選擇表示法, 尤其是允許在項目開發初期或維護階段隨着功能的變化而調整, 這些風格的表示法被定義為等效的: 

```cpp
void sort(Sortable &); // 自然表示法
```

等同於

```cpp
template<Sortable S> void sort(S&); // 簡寫表示法
```

等同於

```cpp
template<typename S> requires Sortable<S> void sort(S&);
```

使用者對此感到非常滿意, 並且傾向于在大多數聲明中使用自然和簡寫表示法。但是, 有些委員會成員對自然表示法感到恐懼 (“我看不出它是一個模板! ”) , 而喜歡使用最顯式的 `requires` 表示法, 因為它甚至可以表達最複雜的範例 (“為什麼你還要比那更複雜的東西? ”) 。我的解釋是, 我們對什麼是簡單有兩種看法: 

- 我可以用最簡單、最快捷的方式編寫程式碼
- 我只需要學習一種表示法

我贊成前一種觀點, 認為這是洋蔥原則 ([§4.2](04.md#42-c11簡化使用)) 的一個很好的例子。

自然表示法成為強烈反對概念的焦點。我——還有其他人——堅持這種優雅的表達

```cpp
void sort(Sortable&); // 自然表示法
```

我們看到 (過去和現在) 這是有用而優雅的一步, 可以使泛型編程逐漸變成一種普通的編程方式, 而不是一種具有不同語法、不同原始碼組織偏好 (“僅頭檔案”) 和不同編碼風格 (例如模板元編程 ([§10.5.2](10.md#1052-元編程)) ) 的暗黑藝術。模組解決了原始碼組織問題 ([§9.3.1](09.md#931-模組)) 。另外, 更“自然”的語法解決了人們總是抱怨的關於模板語法過于冗長和笨拙的問題, 我同意這些抱怨。在設計模板時, `template<…>` 首碼語法不是我的首選。由於人們總是擔心能力不強的程式員濫用模板而引起混淆和錯誤, 我被迫接受了這種寫法。繁重的異常處理語法 (`try { … } catch ( … ) { … }`) 也是類似的故事 [Stroustrup 2007]。似乎對於每個新特性, 許多人都要求有**醒目**的語法來防止實際和想象中的潛在問題。然後過一段時間後, 他們又抱怨太囉嗦了。

無論如何, 有為數不少的委員會成員堅持認為自然表示法會導致混亂和誤用, 因為人們 (尤其是經驗不足的程式員) 不會意識到以這種方式定義的函數是模板, 和其他函數並不相同。我在使用和教授概念的多年裡並沒有觀察到這些問題, 因此我並不特別擔心這樣的假設性問題, 但反對意見仍然非常強烈。人們就是**知道**這樣的程式碼很危險。主要的例子是

```cpp
void f(C&&); // 危險: C 是一個概念還是類型? 
```

`C&&` 的含義因 `f` 是函數模板還是“普通的”函數而有所不同。在我看來, `C&&` 語義上的這種差異是 C++11 中最不幸的設計錯誤, 我們應該嘗試糾正這一錯誤, 而不是讓它影響概念的定義。毫無疑問, 誤解的可能性是真實存在的, 並且一旦該機制被很多人使用時, 肯定會發生。但是, 我在現實中沒有看到過這種問題, 而且我懷疑經驗相對豐富的程式員如果遇到這種差異真正會產生影響時, 真的會遇到麻煩。換句話說, 我認為這是“尾巴搖狗”的一個範例; 也就是說, 一個不起眼的例子阻止了一個可以使大量使用者受益的特性。

我也很確定, 我的目標是使泛型編程儘可能地像“普通”編程, 但這不是普遍共識。仍然有人認為, 泛型編程超出了絶大部分程式員的能力。但我沒有看到任何證據。

### 6.3.8 為什麼在 C++17 中沒有概念? 

我曾希望並期望在 C++17 看到概念。在我認為在 2017 年時間窗口可行的擴展 ([§9.2](09.md#92-我的-c17-清單)) 中, 我把概念看作是對 C++ 程式員的基本詞彙的最重大改進。它可以消除很多對醜陋且易出錯的模板元編程 ([§10.5.2](10.md#1052-元編程)) 的需求, 可以簡化庫的精確規範定義, 並顯著改善庫的設計。恐怕這就是問題的一部分: 概念會直接影響所有投票成員。有些人對舊的方式比較滿意, 有些人沒有概念方面的經驗, 而有些人則認為它們是未被嘗試過的 (“學院派”/“理論派”) 想法。

C++0x 概念 ([§6.2](#62-c0x-概念)) 的慘敗加劇了這種擔憂, 這導致我們首先有了技術規範 (TS) [Sutton 2017]。我們沒有語言特性方面的技術規範經驗, 但是這似乎值得嘗試: Andrew Sutton 在 GCC 中的概念實現仍然比較新, 需要謹慎評估。在 (2013 年的) Bristol 標準會議上, Herb Sutter 強烈主張採用 TS 路線, 而我和 J-Daniel Garcia 警告說可能會有延期。我還指出了將概念與通用 lambda 表達式 ([§4.3.1](04.md#431-lambda-表達式)) 分開考慮的危險性, 但是“謹慎”和“我們需要更多經驗”在標準委員會裡是很有力的理由。最終, 我投票贊成了 Concepts TS。現在我把這看作是一個錯誤。

2013 年, 我們有了一個概念的實現和一個相當不錯的規範 (主要感謝 Andrew Sutton) , 但是完成 Concepts TS 還是花了三年的時間。我無法識別出完善 TS 和納入 ISO 標準在嚴格程度有什麼區別。但是, 在 2016 年 Jacksonville 會議上, 當對 TS 中描述的概念進行投票以將其納入標準時, 所有先前的反對意見又出現了。反對者似乎只是忽略了概念三年。我甚至聽到了只對 C++0x 中的概念設計有效、而與 TS 概念設計無關的反對意見。人們再次主張“謹慎”和“我們需要更多的經驗”。據我所知, 由於委員會人數增長的部分原因, 在 Jacksonville 會議上還沒有嘗試過概念的人比在 Bristol 時更多。除了我在過去十年中聽到的所有反對意見之外, 有人提出了全新的反對意見, 有人在全體委員會上提出了未經嘗試的設計建議, 還被認真考慮了。

在 2016 年 2 月的 Jacksonville 會議上, Ville Voutilainen (EWG 主席) 提議按照 Concepts TS [Voutilainen 2016c] 把概念放到標準中: 

> ......程式員們非常渴望能使用新的語言特性, 現在正是將其交付給他們的時候了。概念化標準程式庫需要花費時間, 相信在這個過程中不會發現概念設計有什麼大的問題。我們不應該讓程式員一直等待語言特性, 只是因為一些假想中的設計問題, 這些問題沒有證據, 甚至有一些反證, 很可能根本不存在。為了使世界各地的 C++ 使用者受益, 讓我們在 C++17 裡交付概念這一語言特性吧。

他得到了許多人的大力支援, 尤其是 Gabriel Dos Reis、Alisdair Meredith (之前是 LWG 主席) 和我, 但是 (儘管 EWG 在本週早些時候投了贊成票) 投票結果依然對我們不利: 25 票贊成, 31 票反對, 8 票棄權。我的解釋是, 使用者投了贊成票, 語言技術人員投了反對票, 但這可能會被認為是酸葡萄吧。

在這次會議上, 統一呼叫語法 ([§8.8.3](08.md#883-統一呼叫語法)) 被否決, 協程 ([§9.3.2](09.md#932-協程)) 被轉為 TS, 基本上確保了 C++17 只是標準的一個小版本 ([§8](08.md#8-c17大海迷航)) 。

## 6.4 C++20 概念

在 2017 年, 作為 C++20 的最早特性之一, WG21 將 Concepts TS [Sutton 2017] 中基礎部分和無爭議的部分通過投票進入了工作檔案 ([§6.3.2](#632-概念使用)) : 

- 為通用起見, 顯式使用 `requires` 語句; 例如 `requires Sortable<S>`
- 簡寫表示法, 用於表示類型的類型; 例如 `template<Sortable S>`

自然表示法 (例如 `void sort(Sortable&);` ([§6.3.7](#637-等效語法)) ) 因有爭議而被排除在外。被排除在外的原因有以下幾點: 

- `void sort(Sortable&);` 是一個模板, 但這不很明顯。
- `void f(C&&);` 的含義取決於 `C` 是概念還是類型。
- 在 `Iterator foo(Iterator,Iterator);` 中, 三個 Iterator 必須是相同類型, 還是可以分開約束的類型? 
- 自然語法令人困惑且難以教授。
- 我們如何約束 `template<auto N> void f();` 中的參數? 

這些異議並不新鮮, 但這次它們伴隨着許多使用全新語法的提案 [Honermann 2017; Keane et al. 2017; Köppe 2017a; Riedle 2017; Sutter 2018a]。這些提案各不相同, 和 Concepts TS 也不兼容。人們帶著熱情在會議上介紹這些提案, 而其中沒有一個有實際經驗的支援。相比之下, 我的立場是基于約四年的教學經驗、很多的實驗使用、一些業界應用, 以及在幾個標準程式庫提案組件中的使用 (如, 迭代器封裝 [Dawes et al. 2016]、元組實現 [Voutilainen 2016b]、範圍 [Niebler et al. 2014]) 。

在 Jacksonville 會議 (2018) 上, Tom Honerman 建議刪除自然語法, 並提出了另一種選擇 [Honermann 2017]。我捍衛了自己的立場和 Concepts TS 的設計 [Stroustrup 2017a,b]。我的辯護主要是

- 五年多來, 自然語法在實際教學和使用中未引起任何問題。
- 使用者喜歡它。
- 沒有技術上的歧義。
- 它簡化了常見用法。
- 這是使泛型編程更像普通編程的動力之一。

但這未能說服任何反對者, 因此自然語法沒有移到 C++20 的工作檔案中。

最後一個反對意見來自 C++17 的一個新的小特性, `auto` 值參數 [Touton and Spertus 2015], 並成為反對的焦點: 

```cpp
template<auto N> void f();
```

人們想在語法上區分值模板參數和類型模板參數。通常, 這意味着自 2002 年以來一直在提案裡被使用的簡寫語法將不再有效。

```cpp
template<Concept T> void f(T&); // 建議被廢止
```

在 2018 年中, 我提出了一個最小折中方案 [Stroustrup 2018b]: 

- 保留 `template<Concept T> void f(T&);` 的含義; 
- 使用首碼 `template` 來識別使用自然表示法的模板 (例如 `template void f(Concept&)`) 

提議成功了, 但是 Herb Sutter [Sutter 2018a] 提出的一個截然不同的建議也成功了 [Sutter 2018a]。我們當時處于一種非常特殊的境地, 同時有兩個截然不同且互不兼容的提案, 每個都得到了 EWG 的大多數人的支援。這種僵局為 Ville Voutilainen (EWG 主席) 提出一種變通方案打開了大門, 這一方案在 2018 年 11 月得到了廣泛的支援並被接受 [Voutilainen et al. 2018]: 

- 保留 `template<Concept T> void f(T&);` 的含義
- 使用 `auto` 來識別使用自然表達式的模板參數, 例如 `void f(Concept auto&);`

舉例來說: 

```cpp
// 几乎自然的表達式: 
void sort(Sortable auto& x);  // x 必須 Sortable
Integral auto ch = f(val);    // f(val) 的結果必須為 Integral
Integral auto add(Integral auto x, Integral auto x); // 能用一個寬類型
                                                     // 來防止溢出
```

“自然表達式”已重命名為“縮寫語法”, 雖然它不僅僅是一個縮寫。

儘管我認為在這種 `auto` 的使用有些多餘, 分散和損害了我想使泛型編程變成“普通編程”的目標, 但我還是支援這種折中方案。也許在將來的某個時候, 人們會 (正如當時 Herb Sutter 所暗示的那樣) 達成一致, 讓在概念名後的 `auto` 不再必要。不過, 我並沒有抱太大的希望; 很多人認為為技術實現而定義的語法標記很重要。或許 IDE 的自動完成功能可以使使用者免于手寫這多餘的 `auto`。

遺憾的是, 對於重新引入概念名稱引導器並沒有達成共識 ([§6.3.4](#634-概念名稱引導器)) 。缺乏足夠傳統的語法是一個主要的絆腳石。同樣, 仍然有很多人似乎不相信其有用。

延遲很多年才引入概念造成了長期的傷害。基于特徵 (traits) 和 `enable_if` 的臨時設計數量激增。一代程式員在低級的、無類型的元編程中成長起來。

## 6.5 概念的命名

在發佈 C++20 之前有關概念的最後討論中, 有一個是關於概念的命名約定。命名始終是一個棘手的話題。在我早期涉及概念的工作中, 我通常以非標準的命名類型的方式來命名概念: 像命名專有名詞一樣, 將第一個字母大寫, 並用下劃線來分隔單詞, 以保證可讀性 (例如 `Sortable` 和 `Forward_iterator`) 。其他人 (尤其是印第安納團隊) 則使用了駝峰式命名 (例如 `Sortable` 和 `ForwardIterator`) 。不幸的是, 這種命名約定悄悄進入了標準文本 [Carter 2018], 並由於與標準程式庫中的所有其他名稱不同而引起一些混亂。在那裡, 使用了下劃線, 不使用大寫字母 (除了一些macro 和三個晦澀難懂的範例) 。然後有人認為, 不同的命名約定旨在將“新穎且困難”的概念與“常規構造” (例如函數和類型) 區分開來。

當我注意到這種辯解時, 我非常不喜歡。在 C++ 中, 我們通常不會把類型編碼到實體名稱中, 但我認為更改命名風格為時已晚。在 2019 年, Herb Sutter 對我的抱怨做出了回應, 提議重命名所有標準程式庫中的概念, 以遵循常見的標準程式庫命名約定 [Sutter et al. 2019]。大部分概念設計者和範圍庫 ([§9.3.5](09.md#935-範圍)) 的設計者作為共同作者都簽了字。進行此更改的另一個原因是, 我們開始看到標準程式庫裡概念的駝峰式名稱與其他庫中的駝峰式名稱之間存在衝突。使用駝峰式命名 (或使用我的大寫類型約定) 的原因之一就是為了避免與標準程式庫衝突。因此, 我們現在有了 `sortable`、`forward_iterator` 等。

C++20 標準程式庫包含大約 70 個概念, 包括 `constructible_from`、`convertible_to`、`derived_from`、`equal_comparable`、`invocable`、`mergeable`、`range`、`regular`、`same_as`、`signed_integral`、`semiregular`、`sortable`、`swappable` 和 `totally_ordered`, 涵蓋了運算符呼叫、基本類型的使用、範圍和標準演演算法的需求。它們將指導許多 C++ 庫的設計。請注意, 這 70 個概念中很多並不是基本概念, 而只是為了方便表示或用作基本構建單元。
