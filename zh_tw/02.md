# 2. 背景: C++ 的 1979–2006

C++ 從 1979 年到 2006 年的歷史記錄在我的 HOPL 論文中 [Stroustrup 1993, 2007]。在那段時間裡, C++ 從一個單人的研究項目成長為大約有 300 萬程式員的社區。

## 2.1 第一個十年

後來成為了 C++ 的東西始於 1979 年 4 月, 名為**帶類的 C**。我的目標是設計一個工具, 它既擁有直接而高效的處理硬體的能力 (例如編寫記憶體管理器、進程調度器和設備驅動程式) , 又同時可以有類似 Simula 的功能來組織程式碼 (例如“強”靜態可擴展型別檢查、類、多級類和協程) 。我想用這個工具編寫一版 Unix 內核, 可以在通過區域網路或共享記憶體互聯的多個處理器上運行。

我選擇 C 作為我工作的基礎, 因為它足夠好, 並且在辦公室裡就能得到很好的支援: 我的辦公室就在 Dennis Ritchie 和 Brian Kernighan 走廊對面。然而, C 語言並不是我考慮的唯一語言。Algol68 當時深深吸引了我, 我還是 BCPL 和其他一些機器層面的語言的專家。C 後來的巨大成功在當時還完全不確定, 但是 Brian Kernighan 和 Dennis Ritchie 傑出的介紹和手冊 [Kernighan and Ritchie1978] 已經出現, Unix 也正開始它的勝利路程。

最初我實現的是一個預處理器, 它將“帶類的 C” 差不多逐行翻譯成 C。1982 年, 在“帶類的 C”的使用者數量增長到了幾十人的時候, 這種方法已經顯得無法把控了。所以我寫了一個傳統的編譯器, 叫作 **Cfront**, 1983 年 10 月第一次給別人使用。Cfront 是一個傳統的編譯器, 它有一個詞法分析器、一個構建抽象語法樹的語法分析器、一個用型別裝飾語法樹的型別檢查器, 以及一個重新排列 AST 以提高生成程式碼的運行期效率的高層次優化器。關於 Cfront 的本質有很多困惑, 因為當時它最終輸出的是 C (優化的, 不是特別可讀的 C) 。我生成了 C, 這樣我就不必直接處理當年正在使用的眾多的 (非標準化) 連結器和優化器。不過, Cfront 一點也不像傳統的預處理器。你可以在計算機歷史博物館的原始碼收藏 [McJones 2007–2020] 中找到一份帶有文件的 Cfront 原始碼。Cfront 從“帶類的 C”自舉為 C++, 所以第一個 C++ 編譯器是用 (簡單的) C++ 寫的, 適合非常小的計算機 (記憶體小於 1MB, 處理器速度小於 1MHz) 。

“帶類的 C” 添加到 C 上的第一個特性是類。我從早期在 Simula 中的使用中瞭解到它們的力量, 在 Simula 中, 類是嚴格靜態、但又可擴展的型別系統的關鍵。我立即添加了建構子和解構子。它們當時非常新穎, 但從我的計算機架構和作業系統背景來看, 我認為它們也不算很新奇, 因為我需要一個機制來建立一個工作環境 (建構子) 和一個逆操作來釋放運行期獲得的資源 (解構子) 。以下摘自我 1979 年的實驗記錄本: 

> - “new 函數”為成員函數創建運行的環境
> - “delete 函數”則執行相反的操作

“new 函數”和“delete 函數”這兩個術語是“建構子”和“解構子”的原始術語。直到今天, 我仍然認為建構子和解構子是 C++ 的真正核心。另見 ([§2.2.1](#221-語言特性)) 和 ([§10.6](10.md#106-編碼指南)) 。

當時, 除了 C 語言, 基本上所有語言都有適當的函數參數型別檢查。我認為沒有它我無法完成任何重要的事情。因此, 在我的部門主管 Alexander Fraser 的鼓勵下, 我立即添加了 (可選的) 函數參數聲明和參數檢查。這就是 C 語言中現在所說的函數原型。1982 年, 在看到讓函數參數檢查保持可選的效果後, 我將其設為強制的。這導致了十幾二十年裡關於與 C 不兼容的大聲抱怨。人們想要保留他們的型別錯誤, 或者至少許多人大聲說他們不想檢查, 並以此作為不使用 C++ 的藉口。這個小事實也許能讓人們認識到, 演化一門被大量使用的語言所涉及到的各種問題。

鑒於過于狹隘的 C 和 C++ 愛好者之間偶爾會惡語相向, 或許值得指出, 我一直是 Dennis Ritchie 和 Brian Kernighan 的朋友, 在 16 年裡几乎天天同他們一起吃午飯。我從他們那裡學到了很多, 現在還經常同 Brian 見面。我將一些對 C++ 語言的貢獻 [Stroustrup 1993] 歸功於他們兩位, 而我自己也是 C 的主要貢獻者 (例如函數定義語法、函數原型、`const`  和 `//` 註釋) 。

為了能夠理性思考 C++ 的成長, 我想出了一套設計規則。這些在 [Stroustrup 1993, 1994] 中有介紹, 所以這裡我只提一小部分: 

> - 不要陷入對完美的徒勞追求。
> - 始終提供過渡路徑。
> - 說出你的意圖 (即, 能夠直接表達高層次的思路) 。
> - 不要隱式地在靜態型別系統方面違規。
> - 為使用者定義型別提供和內置型別同樣好的支援。
> - 應取消預處理器的使用。
> - 不要給 C++ 以下的低級語言留有餘地 (組合語言語言除外) 。

這些並不是沒有雄心壯志的目標。其中某些目標, 現在 2020 年了我依然在為之努力工作。在 1980 年代早期到中期, 我給 C++ 添加了更多的語言功能: 

- **1981 年**: `const`——支援介面和符號常數的不變性。
- **1982 年**: 虛函數——提供運行期多態。
- **1984 年**: 引用——支援運算符重載和簡化參數傳遞。
- **1984 年**: 運算符和函數重載——除了演算法和邏輯運算符外, 還包括: 允許使用者定義 `=` (賦值) 、`()` (呼叫; 支援函數對象 ([§4.3.1](04.md#431-lambda-表達式)) ) 、`[]` (下標訪問) 和 `->` (智能指標) 。
- **1987 年**: 型別安全連結——消除許多來自不同翻譯單元中不一致聲明的錯誤。
- **1987 年**: 抽象類——提供純介面。

在 1980 年代後期, 隨着計算機能力的急劇增強, 我對大型軟體更感興趣, 並做了如下補充: 

- 模板——在經歷了多年使用macro 進行泛型編程的痛苦之後, 更好地支援泛型編程。
- 異常——試圖給混亂的錯誤處理帶來某種秩序; RAII ([§2.2.2](#222-標準庫組件)) 便是為此目標而設計的。

後面這些功能並沒有受到普遍歡迎 (例如, 見 ([§7](07.md#7-錯誤處理)) ) 。部分原因是社區已經變得龐大和難以管理。ANSI 標準化已經開始, 所以我不再能夠私下實現和實驗。人們堅持大規模的精心設計, 堅持在認真實施之前進行廣泛的辯論。我不能再在明知道不可能讓每個人都滿意的情況下, 從一個最小的提議開始, 把它發展成一個更完整的功能。例如, 人們堅持到處使用笨重的帶有 `template<class T>` 首碼的模板語法。

在 1980 年代末, “物件導向”的宣傳變得震耳欲聾, 淹沒了我對 C++ 傳達的訊息。我對 C++ 是什麼和應當成為什麼的看法被廣泛忽視了——很多人甚至從未聽說過。對於“物件導向”的某些定義來說, 所有新語言都應是“純物件導向的”。“不真正物件導向”被視為是糟糕的, 不容爭辯。

我從未使用過“C++ 是一種物件導向的編程語言”這種說法, 這件事很多人並不知道, 或者因為感到有些尷尬而有意忽略了。那時候, 我的標準描述是

> C++ 是一門偏向系統編程的通用編程語言, 它是
>
> - 更好的 C
> - 支援資料抽象
> - 支援物件導向編程
> - 支援泛型編程

這個說法過去和現在都是準確的, 但不如“萬物皆對象”這樣的口號令人興奮! 

## 2.2 第二個十年

ANSI C++ 委員會是 1989 年 12 月在華盛頓特區的一次會議上成立的, 距離第一次使用“帶類的 C”這個名稱僅僅 10 年多的時間。大約有 25 名 C++ 程式員出席了會議。我出席了會議, 還有另外一些近些年來依然活躍的 ISO C++ 標準委員會成員當時也在。

經過了慣例性的、大約十年的工作, 該委員會終於發佈了第一個標準: C++98。我和許多其他人自然更願意更快地輸出一個標準, 但是委員會規則、過度的雄心和各種各樣的延遲使我們在時間表方面與 Fortran、C 和其他正式標準化的語言站在了同一起跑線上。

形成 C++98 的工作是 HOPL3 論文的核心 [Stroustrup 2007], 所以這裡我只簡單總結一下。

### 2.2.1 語言特性

C++98 的主要語言特性是

- 模板——無約束的、圖靈完備的、對泛型編程的編譯期支援, 在我早期工作 ([§2.1](#21-第一個十年)) 的基礎上進行了許多細化和改進; 這項工作仍在繼續 ([§6](06.md#6-概念)) 。
- 異常——一套在單獨 (不可見的) 路徑上返回錯誤值的機制, 由呼叫方堆疊頂上的“在別處”的程式碼處理; 見 ([§7](07.md#7-錯誤處理)) 。
- `dynamic_cast` 和 `typeid`——一種非常簡單的運行期反射形式 (“運行期型別識別”, 又名 RTTI) 。
- `namespace`——允許程式員在編寫由幾個獨立部分組成的較大程式時避免名稱衝突。
- 條件語句內的聲明——讓寫法更緊湊和限制變數作用域。
- 具名型別轉換—— (`static_cast`、`reinterpret_cast` 和 `const_cast`) : 消除了 C 風格的型別轉換中的二義性, 並使顯式型別轉換更加顯眼。
- `bool`: 一種被證明非常有用和流行的布爾型別; C 和 C++ 曾經使用整數作為布爾變數和常數。

讓我們看一個簡單的 C++98 例子。`dynamic_cast` 是物件導向語言中常被稱為類似“是某種”的概念的 C++ 版本: 

```cpp
void do_something(Shape* p)
{
    if (Circle* pc = dynamic_cast<Circle*>(p)) { // p 是某種 Circle? 
        // ... 使用 pc 指向的 Circle ...
    }
    else {
        // ... 不是 Circle, 做其他事情 ...
    }
}
```

`dynamic_cast` 是一個運行期操作, 依賴于存儲在 Shape 的虛擬函數表中的資料。它通用、易用, 並且與其他語言類似的功能一樣高效。然而, `dynamic_cast` 變得非常不受歡迎, 因為它的實現往往是複雜的, 特殊情況下手動編碼可能更高效 (可以說這導致 `dynamic_cast` 違反了零開銷原則) 。在條件語句裡使用聲明很新穎, 不過當時我認為我只是沿用了 Algol68 裡的這個主意而已。

一種更簡單的變種是使用引用而不是指標: 

```cpp
void do_something2(Shape& r)
{
    Circle& rc = dynamic_cast<Circle&>(r);  // r 是某種 Circle! 
    // ... 使用 rc 引用的 Circle ...
}
```

這簡單地斷言 `r` 指代一個 `Circle`, 如果不是則拋出一個異常。思路就是, 錯誤能夠在本地被合理地處理時, 使用指標和測試, 如果不能則依賴引用和異常。

C++98 中最重要的技術之一是 RAII (Resource Acquisition Is Initialization, 資源獲取即初始化) 。那是我給它取的一個笨拙的名字, 想法就是每個資源都應該有一個所有者, 它由作用域對象表示: 建構子獲取資源、解構子隱式地釋放它。這個想法出現在早期的“帶類的 C ”中, 但直到十多年後才被命名。這裡有一個我經常使用的例子, 用來說明並非所有資源都是記憶體: 

```cpp
void my_fct(const char* name)  // C 風格的資源管理
{
    FILE* p = fopen(name, "r");  // 打開檔案 name 來讀取
    // ... 使用 p ...
    fclose(p);
}
```

問題是, 如果 (在 `fopen()` 和 `fclose()` 的呼叫之間) 我們從函數 `return` 了, 或者 `throw` 了一個異常, 或者使用了 C 的 `longjmp`, 那麼 `p` 指向的檔案句柄就泄漏了。檔案句柄泄漏會比記憶體泄漏更快地耗盡作業系統的資源。這個檔案句柄是**非記憶體資源**的一個例子。

解決方案是將檔案句柄表示為帶有建構子和解構子的類: 

```cpp
class File_handle {
    FILE* p;
public:
    File_handle(const char* name,const char* permissions);  // 打開檔案
    ~File_handle();  // 關閉檔案
    // ...
};
```

我們現在可以簡化我們的用法: 

```cpp
void my_fct2(const char* name)  // RAII 風格的資源管理
{
    File_handle p(name,"r");    // 打開檔案 name 來讀取
    // ... 使用 p ...
} // p 被隱式地關閉
```

隨着異常的引入, 這樣的資源句柄變得無處不在。特別的, 標準庫檔案流就是這樣一個資源句柄, 所以使用 C++98 標準庫, 這個例子變成: 

```cpp
void my_fct3(const string& name)
{
    ifstream p(name);    // 打開檔案 name 來讀取
    // ... 使用 p ...
} // p 被隱式的關閉
```

請注意, RAII 程式碼不同於傳統的函數使用, 它允許在庫中一勞永逸地定義“清理記憶體”, 而不是程式員每次使用資源時都必須記住並顯式編寫。至關重要的是, 正確和健壯的程式碼更簡單、更短, 並且至少與傳統風格一樣高效。在接下來的 20 年裡, RAII 已遍佈 C++ 庫。

擁有非記憶體資源意味着垃圾收集本身不足以進行資源管理。此外, RAII 加上智能指標 ([§4.2.4](04.md#424-資源管理指標)) 消除了對垃圾收集的需求。另見 ([§10.6](10.md#106-編碼指南)) 。

### 2.2.2 標準庫組件

C++98 標準庫提供了: 

- STL——創造性的、通用的、優雅的、高效的容器、迭代器和演算法框架, 由 Alexander Stepanov 設計。
- 特徵 (trait) ——對使用模板編程有用的編譯期屬性集 ([§4.5.1](04.md#451-實現技巧)) 。
- `string`——一種用於保存和操作字元序列的型別。字元型別是一個模板參數, 其預設值是 `char`。
- `iostream`——由 Jerry Schwartz 和標準委員會精心製作, 基於我 1984 年的簡單的資料流, 處理各種各樣的字元型別、區域設置和緩衝策略。
- `bitset`——一種用於保存和操作比特位集合的型別。
- `locale`——用來處理不同文化傳統的精緻框架, 主要與輸入輸出有關。
- `valarray`——一個數值陣列, 帶有可優化的向量運算, 但遺憾的是, 未見大量使用。
- `auto_ptr`——早期的代表獨占所有權的指標; 在 C++11 中, 它被 `shared_ptr` (共享所有權) 和 `unique_ptr` (獨占所有權)  ([§4.2.4](04.md#424-資源管理指標)) 替代。

毫無疑問, STL 框架是最為重要的標準庫組件。我認為可以說, STL 和它開創的泛型編程技術輓救了 C++, 使它成長為一種有活力的現代語言。像所有的 C++98 功能一樣, STL 在其他地方已經有了廣泛的描述 (例如 [Stroustrup 1997, 2007]) , 所以在這裡我只會給出一個簡單的例子: 

```cpp
void test(vector<string>& v, list<int>& lst)
{
    vector<string>::iterator p
        = find_if(v.begin(), v.end(), Less_than<string>("falcon"));
    if (p != v.end())  {  // p 指向 'falcon'
        // ... 使用 *p ...
    }
    else {                // 沒找到 'falcon'
        // ...
    }

    list<int>::iterator q
        = find_if(lst.begin(), lst.end(), Greater_than<int>(42));
    // ...
}
```

標準庫演算法 `find_if` 遍歷序列 (由 `begin`/`end` 定界) 尋找謂詞為真的元素。該演算法在三個維度上都是通用的: 

- 序列元素的存儲方式 (這裡是 `vector` 和 `list`) 
- 元素的型別 (這裡是 `string` 和 `int`) 
- 用於確定何時找到元素的謂詞 (此處為 `Less_than` 和 `Greater_than`) 

注意這裡沒有用到任何物件導向的方法。這是依賴模板的泛型編程, 有時也被稱為編譯期多態。

模板的寫法仍然很原始, 但是從 2017 年左右開始, 我可以使用 `auto` ([§4.2.1](04.md#421-auto-和-decltype)) 、範圍 ([§9.3.5](09.md#935-範圍)) 和 lambda 表達式 ([§4.3.1](04.md#431-lambda-表達式)) 來簡化程式碼: 

```cpp
void test2(vector<string>& v, list<int>& lst)
{
    auto p = find_if(v,[](const string& s) { return s<"falcon"; })
    if (p!=v.end()) {
        // ...
    }
    // ...
    auto q = find_if(lst,[](int x) { return x>42; })
    if (q!=lst.end()) {
        // ...
    }
    // ...
}
```

## 2.3 C++ 的 2006

2006 年, 我和 ISO C++ 委員會的大多數其他成員都對功能豐富的 C++0x 標準寄予厚望。計劃在 2007 進行特性凍結, 所以我們有一個合理的預期, C++0x 將是 C++08 或 C++09。事實上 C++0x 變成了 C++11, 引出了關於十六進制 C++0xB 的笑話。

在我 2006 年的 HOPL 論文 [Stroustrup 2007] 中, 我列出了 39 個提案, 並預測前 21 個會進入 C++0x。有趣的是, 我列表上的前 25 個建議中, 有 24 個進入了 C++11。我把提案 22–25 列為“正在制定中, 目標是在 2007 年 7 月進行投票”。令我驚喜的是, 它們全都成功了。而提案 26–39 則連 C++17 都沒有進入。這中間就留下了第 10 號提案“概念”, 它有一個自己的長長的悲傷故事, 不過最終還是以進入 C++20 而快樂收尾。

我和其他許多人對 C++0x 的延遲感到沮喪, 並擔心在面對來自更現代、資金更充足的替代品的競爭時, 一個未經改進的 C++ 可能無法作為一種活的語言生存下去。在 2006 年, Java 的使用仍在增加, 微軟的 C# 也有大量的支援和營銷。我在 2006 年的估計是 C++ 的使用在過去 4 年中首次略有下降。獲取真實的數字很難, 我的最佳估計 (下降 7%) 完全在誤差範圍內, 但確實有理由去擔心。類似 Java 和 C# 這樣的語言會作出這樣一種假設, 並常常大聲宣揚: C++ 沒有生態位: 

- “低級編程”可以由少量的 C 或組合語言程式碼處理。
- “高級編程”則可以使用一種帶有巨大的運行時支援系統的更安全、更小並使用垃圾收集的語言來做, 這樣可以更好、更便宜、更高效地完成。
- 像 Java 和 C# 這樣的託管語言使用垃圾收集和一致的運行期範圍檢查, 使得不太專業的程式員能更有生產力, 這樣可以減少對高技能的開發人員的需求。
- 編程語言與平台的深度整合, 並使用整合工具來進行支援, 這對生產力和大型系統的構建至關重要。

顯然, 我和許多其他人並不同意。但這些在過去和現在都是嚴肅的爭辯, 它們如果正確的話應該導致 C++ 被放棄使用。C++ 基于傳統的編程語言模型, 與底層作業系統分離, 並由眾多獨立的工具供應者提供支援。託管語言往往是專有的; 只有一個龐大而富有的組織才能開發所需的龐大基礎設施和庫。我和 C++ 社區中的其他許多人更喜歡不受公司控制的語言; 這是我參加 ISO 標準工作的一個原因。

回想起來, 2006 年可能是 C++ 的最低谷, 但重要的技術事件也恰好在此時發生了: 大約在 2005 年, 歷史上第一次單個處理器 (單核) 的性能停止提高, 能效 (“每瓦特的性能”) 成為一個關鍵指標 (尤其是對於伺服器集群和手持設備) 。計算經濟學轉而青睞更好的軟體。硬體的進步再也不能完全掩蓋語言或編程技術的低效。這樣, 執掌“利器”的高手跟差點的程式員或受工具鏈開銷束縛的程式員相比, 能贏得高一個數量級的經濟優勢, 而這種優勢十多年之後還依然存在。即使在今天, 這些事實還沒有被所有的教育和管理體制充分領會, 但是現在有許多重要的任務, 為它們花時間精心打造高性能的程式碼會獲得巨大的回報。

另一個轉折點來自供應商, 他們試圖通過定義標準介面 (比如圖形使用者界面) 將自己喜歡的語言強加給所有使用者, 而這只能通過使用他們喜歡的、通常是專有的語言來實現。比如谷歌對安卓系統使用 Java, 蘋果對 iOS 使用 Objective-C, 微軟對 Windows 使用 C#。應用程式供應商可以嘗試通過使用一些編程方言來避開鎖定, 例如 Objective C++ [Objective C++ Wikipedia 2020] 或 C++/CLI [ECMA International 2005], 但是這樣寫出的程式碼仍然不可移植。許多組織, 比如 Adobe、谷歌和微軟, 他們的響應方式是使用 C++ 編寫他們要求苛刻的應用程式的主要部分, 然後為各種平台 (如 Android、iOS 和 Windows) 使用薄介面層。2006 年時這一趨勢几乎不引人注目。

在攜帶型設備 (尤其是智能手機) 上, 對能效和平台獨立性的需求是彼此融合的。一個影響是, 據我在 2018 年的最佳估計, 自 2006 年以來 C++ 程式員的數量增長了約 50%, 達到約 450 萬名開發人員 [Kazakova 2015]。也就是說開發者每年增長 15 萬人, 十年來每年大約增長 4%。

2006 年, 很少有人注意到硬體趨勢對 C++ 固有優勢的滋養。而社區和標準委員會正在關注新的語言特性和庫, 以增加 C++ 的實用性並提高對它的熱情。包括我在內的一些委員感到迫切需要重大改進。其他人更關注于穩定語言和改進它的實現。一個標準委員會需要這兩個群體, 但創新和整頓之間不斷的拉鋸戰是緊張的來源。就像在任何大型組織中一樣, 維護現狀和服務當前使用者的人有組織上優勢。在《C++ 程式設計語言 (第三版) 》[Stroustrup 1997] 中, 我引用了尼科洛·馬基雅維利 (Niccolò Machiavelli) 的話: 

> 沒有什麼比開創一種新秩序更難於推行、更讓人懷疑能否成功、處理起來更加危險。因為改革者會與所有從舊秩序中獲利的人為敵, 而所有從新秩序中獲利的人卻只是冷淡的捍衛者。

我的觀點是 C++ 需要顯著的改進來更好地服務于它的使用者群體。C++ 應用程式被大規模部署, 但是新項目通常選擇更流行的語言, 一些成功的 C++ 項目被改寫成這樣的語言。舉例來說, 谷歌的許多大規模應用, 如搜索, 一直是基於他們的 map-reduce 框架 [Dean and Ghemawat 2004, 2008]。它就是 C++ 程式。然而, 由於它因為商業原因是專有的, 人們複製了它, 而開源的 map-reduce 框架 (Hadoop) 出於各種原因是用 Java 實現的。這對於 C++ 社區來說是一件憾事。

開發轉向其他語言的另一個重要原因是, 模板提供的介面的靈活性使得使用所有 C++ 特性並提供穩定的 ABI 變得極其困難: 可以靈活, 也可以提供穩定的二進制介面, 但大多數組織都做不到兩者兼顧。我認為人們之所以需要 C++ 編寫的程式提供 C、Java、C# 之類的介面, 這是個促成因素。C++ 的 ABI 穩定性是一個真正的技術難題, 尤其是因為 C++ 標準必須獨立於平台。

除了 C++ 社區的問題, 到 2006 年, 隨着紙質出版的減少以及記者們關注流行技術和廣告收入, 大多數涉及 C++ 的專業軟體雜誌已經死亡。Dr. Dobbs 期刊又持續了幾年 (2009 年 2 月停刊) 。C++ 會議被吸收到“物件導向”或一般軟體開發會議中, 剝奪了 C++ 社區展示新發展的場所。書籍仍在編寫中, 但程式員閲讀的書籍越來越少 (或至少購買的書越來越少, 因為盜版變得越來越容易, 因此統計資料變得越來越不可靠) , 在綫資源變得越來越受歡迎。

一個更嚴重的問題是 C++ 在教育中的作用正在急劇下降。C++ 不再是“新的、有趣的”, 而 Java 正作為一種更簡單、更強大的語言被直接推向大學。美國高中計算機科學考試突然從 C++ 變成了 Java。在大學裡, Java 作為入門語言的使用急劇增加。C++ 的教學質量也在下降, 大多數課程優先選擇 C 語言, 或者認為嚴重依賴類層次結構的物件導向編程是唯一正確的方法。這兩種方法都弱化了 C++ 的優勢, 並且需要大量使用macro 。標準庫 (依靠泛型編程;  ([§2.2](#22-第二個十年)) ) 和 RAII (依賴建構子/解構子對 ([§2.2.1](#221-語言特性)) ) 經常被完全排除在基礎課程之外, 或者被放在一個所謂的“高級特性”部分, 大多數學生要麼從未接觸過, 要麼認為它很可怕。教科書經常陷入晦澀難懂的細節。當然也有例外, 但平均來說, 呈現給學生的 C++ 遠不是最佳的工程實踐。在 2005 年, 我接受了挑戰, 給大學一年級的學生教編程。我調查了大約二十本最流行的 C++ 編程教材, 最後大聲抱怨: 

> 如果那就是 C++, 我也會不喜歡它! 

在用一本著名的教科書教了一年書後, 我開始只用自己的教案, 並且在 2008 年出版了《C++ 程式設計: 原理與實踐》 (*Programming: Principles and Practice Using C++*) [Stroustrup 2008a], 但直到今天, 許多 C++ 教學仍帶有 1980 年代的特色。

儘管如此, C++ 的使用又開始增加了。我認為這是因為根本的技術趨勢再次青睞 C++, 並且在二十一世紀的第一個十年結束的時候, C++11 的出現也有所幫助。

Boost 庫和 Boost 組織非常重要 [Boost 1998–2020]。1998 年, 經驗豐富的開發者及 WG21 的有影響力的成員 Beman Dawes 建立了一個“C++ 程式碼庫網站”[Dawes 1998], 其明確目標是開發 C++ 庫以確立現有實踐, 使得未來的標準化可以據此進行。在此之前, C++ 甚至從來沒有一個公共的程式碼庫。Boost 慢慢成長為一個活躍的組織, 有新庫的同行評審和一年一度的會議。Boost 庫被廣泛使用, 最流行的被吸收到標準中 (例如, `regex` ([§4.6](04.md#46-c11標準庫組件)) 、`thread` ([§4.1.2](04.md#412-執行緒和鎖)) 、`shared_ptr` ([§4.6](04.md#46-c11標準庫組件)) 、`variant` ([§8.3](08.md#83-variantoptional-和-any)) 和檔案系統 ([§8.6](08.md#86-檔案系統)) ) 。對於 C++ 社區來說重要的是, Boost 庫比它們的 ISO 標準版本早十多年, 但仍被當作某種“預備標準”來信任。有許多委員會成員都參與了 Boost, 特別是 Dave Abrahams、Doug Gregor、Jaakko Järvi、Andrew Sutton, 當然還有 Beman Dawes。

到 2006 年, C++ 在業界已經不再是新鮮刺激的東西, 但它遍佈很多行業。在 C++ 誕生的電信行業, 它一直被大量使用。從電信領域出發, 它已經擴展到遊戲 (如 Unreal、PlayStation、Xbox 和 Douglas Adams 的《宇宙飛船泰坦》) 、金融 (如摩根士丹利和 Renaissance Technologies) 、微電子 (如英特爾和 Mentor Graphics) 、電影 (如皮克斯和 Maya) 、航空航天 (如洛克希德·馬丁和美國國家航空航天局) 和許多其他行業。

就我個人而言, 我特別喜歡 C++ 在科學和工程中的廣泛使用, 比如高能物理 (例如 CERN 歐洲核子研究中心、SLAC 國家加速器實驗室、費米實驗室) 、生物學 (例如人類基因組項目) 、空間探索 (例如火星漫遊車和深空通信網路) 、醫學和生物學 (例如斷層掃瞄、常規成像、人類基因組項目和監控設備) 等等。

## 2.4 其他語言

人們常常會尋找其他編程語言對 C++ 的直接技術影響。其實非常之少。典型情況是, 影響湧現自共同的前代語言和共同思想 (而非特定的現有語言) 。擴展 C++ 的決定性理由往往與 C++ 社區中已經發現的問題有關。直接從流行語言中借鑒的情況並不常見, 而且比人們想象的要困難得多。大多數標準委員會成員都掌握多種語言, 並密切留意 (其他語言中) 有用的功能、庫和技巧。

下面是其他語言在二十一世紀對 C++ 的某些真實或假想的影響: 

- `auto`——從初始化器推斷型別的能力。它在現代語言中很流行, 但也已由來已久。我不知它的最早起源, 但我在 1983 年實現這個功能的時候, 也並不認為它很新穎 ([§4.2.1](04.md#421-auto-和-decltype)) 。
- `tuple`——許多語言, 特別是源自函數式編程傳統的語言, 都有元組, 它通常是一個內置型別。C++ 標準庫 `tuple` 及其許多用法都從中受到啟發。`std::tuple` 派生自 `boost::tuple` [Boost 1998–2020] ([§4.3.4](04.md#434-tuple)) 。
- `regex`——加入 C++11 的標準庫 `regex` 是 (經由 Boost; 已致謝) 從 Unix 和 JavaScript 的功能中拷貝來的 ([§4.6](04.md#46-c11標準庫組件)) 。
- 函數式編程——函數式編程特性和 C++ 構造之間有許多明顯的相似之處。大多數不是簡單的語言特性, 而是編程技巧。STL 受到函數式編程的啟發, 並首先在 Scheme [Stepanov 1986] 和 Ada [Musser and Stepanov 1987] 中進行了嘗試 (未成功) 。
- `future` 和 `promise`——源自 Multilisp, 經由其他 Lisp 方言 ([§4.1.3](04.md#413-期值future)) 。
- 範圍 `for`——許多語言中都有對應物, 但直接啟發來自 STL 序列 ([§4.2.2](04.md#422-範圍-for)) 。
- `variant`、`any` 和 `optional`——顯然受到多種語言的啟發 ([§8.3](08.md#83-variantoptional-和-any)) 。
-  lambda 表達式——顯然, 部分靈感來自于函數式語言中 lambda 表達式的應用。但是, 在 C++ 中, lambda 表達式的根源還可以上溯到 BCPL 語言中用作表達式的程式碼塊、局部函數 (多次被 C 和 C++ 拒絶, 因其容易出錯且增加了複雜性) 和 (最重要的) 函數對象 ([§4.3.1](04.md#431-lambda-表達式)) 。
- `final` 和 `override`——用於更明確地管理類層次結構, 並且在許多物件導向的語言中都可以使用。在早期的 C++ 中已經考慮過它們了, 但當時被認為是不必要的。
- 三向比較運算符 `<=>`, 受 C 的 `strcmp` 及 PERL、PHP、Python 和 Ruby 語言的運算符的啟發 ([§9.3.4](09.md#934-)) 。
- `await`——C++ 裡最早的協程 ([§1.1](01.md#11-年表)) 受 Simula 啟發, 但是作為庫提供, 而不是作為語言特性, 這是為了給其他替代的並發技術留出空間。C++20 中的無堆疊協程的思想主要來自 F# ([§9.3.2](09.md#932-協程)) 。

即使以非常直接的方式從另一種語言借用了某個特性, 該特性也會發生變化。通常, 為了適合 C++ 語法會發生很大變化。當從支援垃圾收集的語言借鑒時, 生命周期問題必須得到解決。而 C++ 區分對象和對象的引用, 這通常使得 C++ 需要以和原始語言不同的方式來解決。在“翻譯”成 C++ 的過程中, 經常會發現全新的用法。在把 lambda 引入 C++ 的過程中, 出現了大量的此類現象的事例 ([§4.3.1](04.md#431-lambda-表達式)) 。

在很多人的想象中, 我 (和其他參與 C++ 的人) 整日無所事事, 滿腦子想的是在流行語言中如何佔據主導地位, 為這個複雜的語言戰爭制定戰略。實際上, 我並沒有在那上面花時間。大多數日子裡, 我不會去思考其他的語言, 除非我碰巧出於一般的技術興趣去學習一門其他語言或要使用它來完成一些工作。我要做的是與軟體開發人員交談, 考慮人們在使用 C++ 時遇到的問題, 還要考慮潮水般湧入標準委員會的改進建議。當然, 我也編寫程式碼來體驗問題並測試改進思路。問題在於要能抽出時間冷靜地考慮, 什麼是根本的, 什麼只是一時流行, 以及什麼會造成危害。

同樣, C++ 對其他語言的貢獻也難以估量。通常, 類似的特性是平行演化的, 或有着共同的根源。例如: 

- Java 和 C# 中的泛型——他們採用了其他語言的泛型模式, 但採用了 C++ 語法, 並且是在 C++ 大規模展示了泛型編程的用途之後, 才添加泛型。
- Java、Python 等的資源棄置慣用法 (dispose idiom) ——這大致是在垃圾收集語言中最能接近解構子的做法了。
- D 編程語言進行編譯期求值——我向 Walter Bright 解釋了早期的 constexpr 設計。
- C++ 基于建構子和解構子的對象生存期模型是 Rust 靈感的一部分。好笑的是, 最近 C++ 經常被指責從 Rust 那裡借用了這種想法。
- C 採用了 C++11 的記憶體模型、函數聲明和定義語法、以聲明為語句、`const`、`//` 註釋、`inline` 以及 `for` 循環中的初始化表達式。

C++ 與其他語言之間的許多差異源於 C++ 對解構子的使用。這使得垃圾收集的語言很難直接從 C++ 借用。
