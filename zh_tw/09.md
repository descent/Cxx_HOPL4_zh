# 9. C++20: 方向之爭

由超過 350 名成員組成的委員會進行設計, 不太可能產生一個連貫一致的結果。大家都有截然不同的背景 (包括不同的教育背景) , 也在各自的“日常工作”中承受不同的壓力, 自然會在方向上、優先順序上和委員會程式上有不同的見解。粗略估算一下, 對於每個提案, 大概都有十多位成員會強烈反對其中部分內容。考慮到 WG21 希望同意人數達到 80% 或 90% 才宣告達成共識, C++ 到目前為止的成功令人驚訝。

## 9.1 設計原則

C++ 想發展成為什麼樣? 或者說, WG21 對於它在努力做什麼有一個清晰的觀點麼? 我認為答案是否定的。每位具體成員對於這個問題都有其個人想法, 但沒有一個想法是被廣泛接受的並且足夠具體到可以指導個人的討論和決策。

ISO C++ 標準委員會既沒有一組得到廣泛認可的設計標準, 也沒有一組得到廣泛認可的採納某個特性的標準。有這個問題的存在, 並不是因為沒有做過這方面的嘗試。我曾經反覆不斷地明確強調以下設計標準: 

- 在《C++ 語言的設計和演化》[Stroustrup 1994] ([§2.1](02.md#21-第一個十年)) 中提出的“經驗法則”包括有 RAII ([§2.2.1](02.md#221-語言特性)) 、物件導向編程、泛型編程、靜態類型安全。
- 簡單的事情簡單做!  ([§4.2](04.md#42-c11簡化使用)) 則引出洋蔥原則 ([§4.2](04.md#42-c11簡化使用)) 。
- 直接映射到硬體和零開銷抽象 ([§1](01.md#1-前言))  ([§11.2](11.md#112-技術上的成功)) 。
- 基于意見反饋來發展 C++, 以解決現實世界的實際問題 ([§11.2](11.md#112-技術上的成功)) 。
- 保持穩定性和兼容性 [Koenig and Stroustrup 1991b; Stroustrup 1994]。
- 直接和硬體打交道的能力, 強有力的可組合的抽象機制, 以及最小化的運行時系統 (參見我在 HOPL3 的論文 [Stroustrup 2007] 中的回顧) 。

問題在於, 人們發現要在解釋上達成一致太難, 而要忽視他們所不喜歡的又太容易。這種傾向, 使得“什麼才是重要的”這個問題上的根本分歧得以發酵。大家基於他們所受的教育和他們的日常工作中所獲得的理解, 來做出設計決策。問題之一是這種背景上的多樣性, 再加上標準委員 ([§3.3](03.md#33-對設計的影響)) 內部對於 C++ 廣泛應用領域的不均衡覆蓋。許多人只是對於自己的觀點 [Stroustrup 2019b] 過于確定無疑。而要分辨清楚到底什麼只是一時的流行, 什麼才長遠來看對 C++ 社區有幫助, 確實很困難。通常來說, 第一個提出的解決方案往往不是最好的那個。

人們很容易在細節中迷失而忽略了大局。人們很容易關注當前的問題而忘記長期目標 (以十年計) 。相反, 委員會成員是如此專注于通用的原則和遙遠的未來, 以至于對迫在眉睫的實際問題視而不見。

在 2017 年, 一群國家標準機構代表團 [van Winkel et al. 2017] 的領導人要求對 C++ 的方向性問題予以正式嚴肅的考量, 在他們的敦促之下, WG21 建立了**方向組** (Direction Group, 通常稱之為 DG) 以試圖解決設計目標和方向的問題 ([§3.2](03.md#32-組織)) 。DG 在 2018 年 發佈了它的第一個廣泛而詳盡的聲明 [Dawes et al. 2018], 強調了要遵守明確清晰的原則、一致性, 並鼓勵用流程來確保這些。比如說: 

> 我們從根本上需要: 
>
> - 穩定性: 有用的程式碼“存活”達數十年。
> - 不斷演進: 世界在不斷變化, 而 C++ 也需要不斷改變以面對新的挑戰。
>
> 這裡有一種內在的張力。

DG 強調一致性有必要貫穿整個標準: 

> 現如今, 某些最為強大的設計技術融合了傳統的物件導向編程方面、泛型編程方面、函數式編程方面以及一些傳統的命令式編程技術。這種組合, 而不是理論上的純粹, 才是理想的。
>
> - 提供在風格 (語法和語義) 和使用風格上一致的特性。
>
> 該要求適用於庫、語言特性, 以及這兩者的組合

當然了, 還有靜態類型: 

> C++ 極其依賴于靜態類型安全, 以達成其表達能力、性能和安全性。理想的情況下應有
>
> - 完全的類型安全和資源安全 (沒有記憶體損壞和記憶體泄漏) 
>
> 該要求可以在不增加額外開銷的情況下達成, 尤其是, 不需要添加垃圾收集器, 也不需要限製表達能力。

國家機構領導的要求 [van Winkel et al. 2017] 和 DG 的文件 [Dawes et al. 2018] 都強調了委員會成員需要瞭解 C++ 的歷史, 以確保一定程度的連續性。一個缺乏歷史的組織無法對他們的設計內容保持一致性的觀點。因此, HOPL 論文 [Stroustrup 1993, 2007] 和《C++ 語言的設計和演化》[Stroustrup 1994] 扮演了基石角色。

傳統上, 為符合 WG21 在 ISO 的章程, C++ 演化方面的工作主要都聚焦于語言和庫的課題。然而, 開發者不僅僅需要考慮語言: 程式是工具鏈 ([§1](01.md#1-前言)) 的產物。令人震驚的是, C++ 並沒有關於動態連結庫的標準, 也沒有標準化的構建系統。工具研究小組 SG15 在 2018 年成立, 以嘗試應對工具方面的形形色色的問題 ([§3.2](03.md#32-組織)) 。

## 9.2 我的 C++17 清單

我一直努力鼓勵委員會關注重要的改進——而不只去做那些容易完成和容易達成一致的事情——作為這個努力的一部分, 我制定了一個清單, 包含了我認為重要且適合引入 C++17 的內容及其理由: 

- 概念——它讓我們可以精確描述泛型程式, 並解決對於錯誤訊息質量的廣泛抱怨。
- 模組——只要它可以顯著地提高與macro 的隔離並大大優化編譯時間。
- 範圍庫和其他關鍵 STL 組件對概念的使用——為主流使用者改進錯誤訊息質量和提高庫規範 (“STL2”) 的精確性。
- 統一呼叫語法——簡化模板庫的規範和使用。
- 協程——應該非常快速而簡單。
- 網路庫支援——基于 asio 庫, 如相應 TS 所描述。
- 契約——不一定需要在 C++17 的庫規範中使用。
- SIMD 向量和並行演演算法。
- 標準庫詞彙類型, 比如 `optional`、`variant`、`string_view` 和 `array_view`。
- 一種在堆疊上提供陣列 (`stack_array`) 的“魔法類型”, 合理支援安全、便捷的使用。

在 2015 年 4 月份, 在 Kansas 州 Lenexa 的 WG21 會議中, 我在晚間會議上向一些有共鳴的觀眾展示了這個清單。然而, 几乎沒有人感受到足夠的動力去根據這個清單調整工作焦點。這個清單後來“泄露”了出去, 並且在網上引起了混亂的討論, 因此我不得不把它正式寫出來 [Stroustrup 2015a]。

如果是在一個團結的委員會中, 該清單上的每一項都應該已經準備好進入 C++17 了。實際上我認為, 如果我們專注于這個列表, 完成其中的大約一半提案還是可行的。然而我還是過于樂觀 了。我們唯一達成共識的也就只有關於標準庫詞彙類型的那一項。其中 `array_view` 被重命名為 `span`, 成了 C++20 ([§9.3.8](#938-跨度)) 的一部分。

幸運的是, 列表上的大部分條目進入了 C++20。除了

- 網路庫 ([§8.8.1](08.md#881-網路庫)) ——現在是個 TS [Wakely 2018]
- 契約 ([§9.6.1](#961-契約)) ——差一點進入 C++20
- 統一函數呼叫 ([§8.8.3](08.md#883-統一呼叫語法)) 
- SIMD 向量——目前在一個 TS 中 [Hoberock 2019]
- `stack_array`

這份列錶帶來了日程安排上的爭論。鑒於概念的提案 ([§6.3.8](06.md#638-為什麼在-c17-中沒有概念)) 在 2016 年的失敗看起來是不可避免了, 我被詢問——由整個委員會——是否我打算提議推遲標準的發佈一到兩年, 來把概念加入到標準中, 讓標準變成 C++18 或者 C++19。我拒絶了, 因為我認為可預見的發佈周期對於整個社區而言更為重要, 其重要性要超過某個單項的改進。而且, 當時也無法確保一定會就該提案形成共識, 再說一次日程延誤很可能會造成多次延誤。如果一份提案被認為值得推遲標準發佈, 那麼就會有人主張也有其他的提案同樣值得標準發佈的推遲。這樣的邏輯使得 C++0x 變成了 C++11, 哪怕當時曾有人希望是 C++06。

## 9.3 C++20 特性

WG21 將針對 C++20 的新提案的截止日期定為 2018 年 11 月, 並在 2019 年 2 月會議之後宣佈“特性凍結”。2020 年 2 月, 在捷克共和國布拉格舉行的一次會議上, 技術投票結果為 79 比 0, 一票棄權 [Smith 2020]。所有 15 個國家成員體的代表團團長均投了贊成票。官方標准將由 ISO 在 2020 年末發佈。C++20 特性包括: 

- [§6.4](06.md#64-c20-概念): **概念**——對泛型程式碼的要求進行明確規定
- [§9.3.1](#931-模組): **模組**——支援程式碼的模組化, 使程式碼更衛生並改善編譯時間
- [§9.3.2](#932-協程): **協程**——無堆疊協程
- [§9.3.3](#933-編譯期計算支援): **編譯期**計算支援
- [§9.3.4](#934-): **&lt;=>**——三向比較運算符
- [§9.3.5](#935-範圍): **範圍**——提供靈活的範圍抽象的庫
- [§9.3.6](#936-日期和時區): **日期**——提供日期類型、日曆和時區的庫
- [§9.3.8](#938-跨度): **跨度**——提供對陣列進行高效和安全訪問的庫
- [§9.3.7](#937-格式化): **格式化**——提供類型安全的類似於 printf 的輸出的庫
- [§9.4](#94-並發): **並發改進**——例如作用域綫程和停止令牌
- [§9.5](#95-次要特性): **很多次要特性**——例如 C99 風格的指派初始化器和使用字元串字面量作為模板參數

以下內容在 C++20 時尚未準備就緒, 但可能會成為 C++23 的主要特性: 

- [§8.8.1](08.md#881-網路庫): **網路**——網路庫 (sockets 等) 
- [§9.6.2](#962-靜態反射): **靜態反射**——根據周圍程式生成程式碼的功能
- **模式匹配**——根據類型和對象值選擇要執行的程式碼 [Murzin et al. 2019]

C++20 提供了一組反映 C++ 長期目標的特性, 並解決了一些根本問題。例如, 從 1994 年《C++ 語言的設計和演化》[Stroustrup 1994] 書中就提到了模組和概念, 而協程在整個 1980 年代都是“帶類的 C”和 C++ 的一部分。C++20 對 C++ 的影響將與 C++11 一樣大。

不幸的是, C++20 沒有對模組和協程提供標準庫支援。這可能會成為一個嚴重的問題, 但當時實在沒有時間來準備並趕上 C++20 的時間要求。C++23 應該會提供所需的支援 ([§4.1.3](04.md#413-期值future)) 。

### 9.3.1 模組

在 C++ 程式中改進模組化是一個顯然的需求。從 C 語言中, C++ 繼承了 `#include` 機制, 依賴從頭檔案使用文本形式包含 C++ 原始碼, 這些頭檔案中包含了介面的文本定義。一個流行的頭檔案可以在大型程式的各個單獨編譯的部分中被 `#include` 數百次。基本問題是: 

- **不夠衛生**: 一個頭檔案中的程式碼可能會影響同一翻譯單元中包含的另一個 `#include` 中的程式碼的含義, 因此 `#include` 並非順序無關。macro 是這裡的一個主要問題, 儘管不是唯一的問題。
- **分離編譯的不一致性**: 兩個翻譯單元中同一實體的聲明可能不一致, 但並非所有此類錯誤都被編譯器或連結器捕獲。
- **編譯次數過多**: 從原始碼文本編譯介面比較慢。從原始碼文本反覆地編譯同一份介面非常慢。

自“開闢鴻蒙”而始, 這已經眾所周知 (例如, 參見《C++ 語言的設計和演化》[Stroustrup 1994] 第 18 章) , 但隨着越來越多的訊息被放入頭檔案 (`inline` 函數、`constexpr` 函數, 還有尤其是模板) , 這些問題在這些年裡變得越來越嚴重。在 C++ 的早期, 通常 10% 的文本來自頭檔案, 但現在它更可能是 90% 甚至 99%。考慮下面的程式碼: 

```cpp
#include<iostream>

int main()
{
    std::cout << "Hello, World\n";
}
```

這段標準程式碼有 70 個字元, 但是在 `#include` 之後, 它會產生 419909 個字元需要編譯器來消化。儘管現代 C++ 編譯器已有驕人的處理速度, 但模組化問題已經迫在眉睫。

在委員會的鼓勵下 (並得到了我的支援) , David Vandevoorde 在二十一世紀產出了一系列模組設計 [Vandevoorde 2007, 2012], 但進展非常緩慢。委員會的首要任務是完成 C++0x, 而不是在模組上取得進展。David 主要靠自己奮鬥, 此外基本就只得到一些精神支援了。在 2012 年, Doug Gregor 從蘋果提交了一個完全不同的模組系統設計 [Gregor 2012]。在 Clang 編譯器基礎設施中, 這一設計已經針對 C 和 Objective C 實現 [Clang 2014]。它依賴于語言之外的檔案映射指令, 而不是 C++ 語言裡的構造。該設計還強調了不需要對頭檔案進行修改。

在 2014 年, 由 Gabriel Dos Reis 領導的微軟團隊成員根據他們的工作提出了一項提案 [Dos Reis et al. 2014]。從精神層面上講, 它更接近於 David Vandevoorde 的設計, 而不是 Clang/蘋果的提議, 並且很大程度上是基于 Gabriel Dos Reis 和 Bjarne Stroustrup 在得州農工大學所做的關於 C++ 原始碼的最優圖表示的研究 (于 2007 年發佈並開源 [Dos Reis 2009; Dos Reis and Stroustrup 2009, 2011]) 。

這為在模組方面取得重大進展奠定了基礎, 但同時也為蘋果/谷歌/Clang 方式 (和實現) 及微軟方式 (和實現) 之間的一系列衝突埋下了伏筆。

為此一個模組研究小組被創建。3 年後, 該小組主要基于 Gabriel Dos Reis 的設計 [Dos Reis 2018] 制訂了 TS。

在 2017 年, 然後在 2018 年又發生了一次, 將 Modules TS 納入 C++20 標準的建議受阻, 就因為谷歌提出了不同的設計 [Smith 2018a,b]。爭論的主要焦點是在 Gabriel Dos Reis 的設計中macro 無法導出。谷歌的人認為這是一個致命缺陷, 而 Gabriel Dos Reis (和我) 認為這對於模組化至關重要 [Stroustrup 2018c]: 

> 模組化是什麼意思? 順序獨立性: `import X; import Y;` 應該與 `import Y; import X;` 相同。換句話說, 任何東西都不能隱式地從一個模組“泄漏”到另一個模組。這是 `#include` 檔案的一個關鍵問題。`#include` 中的任何內容都會影響所有後續的 `#include`。

我認為順序獨立性是“程式碼衛生”和性能的關鍵。通過堅持這種做法, Gabriel Dos Reis 的模組實現也比使用頭檔案在編譯時間上得到了 10 倍量級的性能提升——即使在舊式編譯中使用了預編譯頭檔案也是如此。迎合傳統頭檔案和macro 的常規使用的方式很難做到這一點, 因為需要將模組單元保持為允許macro 替換 (“標記湯”) 的形式, 而不是 C++ 邏輯實體的圖。

經過精心設計的一系列折中, 我們最終達成了一個被廣泛接受的解決方案。這一多年努力的關鍵人物有 Richard Smith (谷歌) 和 Gabriel Dos Reis (微軟) , 以及 GCC 的模組實現者 Nathan Sidwell (Facebook) , 還有其他貢獻者 [Dos Reis and Smith 2018a,b; Smith and Dos Reis 2018]。從 2018 年年中開始, 大多數討論都集中在需要精確規範的技術細節上, 以確保實現之間的可移植性 [Sidwell 2018; Sidwell and Herring 2019]。

考慮如下程式碼所示的 C++20 模組的簡單範例: 

```cpp
export module map_printer;  // 定義一個模組

import iostream;       // 使用 iostream
import containers;     // 使用我自己的 containers
using namespace std;

export                 // 讓 print_map() 對 map_printer 的使用者可用
template<Sequence S>
    requires Printable<Key_type<S>> && Printable<Value_type<S>>
void print_map(const S& m) {
    for (const auto& [key,val] : m)  // 分離“鍵”和“值”
        cout << key << " -> " << val << '\n';
}
```

這段程式碼定義了一個模組 `map_printer`, 該模組提供函數 `print_map` 作為其使用者介面, 並使用了從模組 `iostream` 和 `containers` 導入的功能來實現該函數。為了強調與舊的 C++ 風格的區別, 我使用了概念 ([§6](06.md#6-概念)) 和結構化綁定 ([§8.2](08.md#82-結構化綁定)) 。

關鍵思想: 

- `export` 指令使實體可以被 `import` 到另一個模組中。
- `import` 指令使從另一個模組 `export` 出來的的實體能夠被使用。
- `import` 的實體不會被隱式地再 `export` 出去。
- `import` 不會將實體添加到上下文中; 它只會使實體能被使用 (因此, 未使用的 `import` 基本上是無開銷的) 。

最後兩點不同於 `#include`, 並且它們對於模組化和編譯期性能至關重要。

這個簡單的例子純粹是基于模組的; 這是理想情況。但是, 已經部署的 C++ 程式碼也許有五千億行, 而頭檔案和 `#include` 並不會在一夜之間被淘汰, 可能再過幾十年都不會。好幾個人和組織指出, 我們需要一些過渡機制, 使得頭檔案和模組可以在程式中共存, 並讓庫為不同程式碼成熟度的使用者同時提供頭檔案和模組的介面。請記住, 在任何給定的時刻, 都有使用者依賴 10 年前的編譯器。

考慮在無法修改 `iostream` 和 `container` 頭檔案的約束下實現 `map_printer`: 

```cpp
export module map_printer;  // 定義一個模組

import <iostream>      // 使用 iostream 頭檔案
import "containers"    // 使用我自己的 containers 頭檔案
using namespace std;

export                 // 讓 print_map() 對 map_printer 的使用者可用
template<Sequence S>
    requires Printable<Key_type<S>> && Printable<Value_type<S>>
void print_map(const S& m) {
    for (const auto& [key,val] : m)  // 分離“鍵”和“值”
        cout << key << " -> " << val << '\n';
}
```

指名某個頭檔案的 `import` 指令工作起來几乎與 `#include` 完全一樣——macro 、實現細節以及遞迴地 `#include` 到的頭檔案。但是, 編譯器確保 `import` 導入的“舊頭檔案”不具有相互依賴關係。也就是說, 頭檔案的 `import` 是順序無關的, 因此提供了部分、但並非全部的模組化的好處。例如, 像 `import <iostream>` 這樣導入單個頭檔案, 程式員就需要去決定該導入哪些頭檔案, 也因為與檔案系統進行不必要的多次交互而降低編譯速度, 還限制了來自不同頭檔案的標準庫組件的預編譯。我個人希望看到顆粒度更粗的模組, 例如, 標準的 `import std` 表示讓整個標準庫都可用。然而, 更有雄心的標準庫重構 [Clow et al. 2018] 必須要推遲到 C++23 ([§11.5](11.md#115-未來)) 了。

像 `import` 頭檔案這樣的功能是谷歌/Clang 提案的重要組成部分。這樣做的一個原因是有些庫的主要介面就是一堆macro 。

在設計/實現/標準化工作的後期, 反對意見集中在模組對構建系統的可能影響上。當前 C 和 C++ 的構建系統對處理頭檔案已經做了大量優化。數十年的工作已經花費在優化這一點上, 一些與傳統構建系統相關的人表示懷疑, 是否可以不經 (負擔不起的) 重大重新設計就順利引入模組, 而使用模組的構建會不允許並行編譯 (因為當前要導入的模組依賴于某個先前已導入模組的編譯結果) [Bindels et al. 2018; Lopes et al. 2019; Rivera 2019a]。幸運的是, 早期印象過于悲觀了 [Rivera 2019b], build2 系統已經為處理模組進行了修改, 微軟和谷歌報告說他們的構建系統在處理模組方面顯示出良好的效果, 最後 Nathan Sidwell 報告說他在僅兩周的業餘時間裡修改了 GNU 的構建系統來處理模組 [Sidwell 2019]。這些經驗的最終演示及關鍵模組實現者 (Gabriel Dos Reis、Nathan Sidwell、Richard Smith 和 David Vandevoorde) 的聯署論文打動了几乎所有反對者 [Dos Reis et al. 2019]。

在 2019 年 2 月, 模組得到了 46 比 6 的多數票, 進入了 C++20; 投票者中包含了所有的實現者 [Smith 2019]。在那時, 主要的 C++ 實現已經接近 C++20 標準。模組有望成為 C++20 提供的最重要的單項改進。

### 9.3.2 協程

協程提供了一種協作式多任務模型, 比使用綫程或進程要高效得多。協程曾是早期 C++ 的重要組成部分。如果沒有提供協程的任務庫, C++ 將胎死腹中, 但是由於多種原因, 協程並沒有進入 C++98 標準 ([§1.1](01.md#11-年表)) 。

C++20 協程的歷史始於 Niklas Gustafsson (微軟) 關於“可恢復函數”的提案 [Gustafsson 2012]。其主要目的是支援非同步 I/O; “能夠處理成千上萬或以百萬計客戶的伺服器應用程式”[Kohlhoff 2013]。它相當於當時引入到 C# (2015 年的 6.0 版) 的 async/await 功能。類似的功能已經存在於 Python、JavaScript 和其他語言裡。Niklas 的提案引發了來自 Oliver Kowalke 和 Nat Goodspeed [Kowalke and Goodspeed 2013] 的基于 Boost.Coroutine 的競爭提案, 並引起了人們的濃厚興趣。`await` 設計無堆疊、不對稱且需要語言支援, 而源自 Boost 的設計則使用堆疊、具有對稱控制原語且基于庫。無堆疊協程只能在其自身函數體中掛起, 而不能從其呼叫的函數中掛起。這樣, 掛起僅涉及保存單個堆疊幀 (“協程狀態”) , 而不是保存整個堆疊。對於性能而言, 這是一個巨大的優勢。

協程的設計空間很大, 因此很難達成共識。委員會中的許多人 (包括我在內) 都希望能夠綜合考慮這兩種方式的優點, 因此一群感興趣的成員對可選方案進行了分析 [Goodspeed 2014]。結論是, 有可能同時利用這兩種方式的優點, 但這需要認真研究。這項研究花了數年時間, 但沒有得出明確的結果。與此同時, 出現了更多的提案。

至于密切相關的並發主題 ([§8.4](08.md#84-並發)) , 對所編寫、演示和討論的提案的完整解釋超出了本文的範圍。在這裡, 我只描述一個概況。因為複雜的細節簡直太多, 在此也只能簡而言之; 僅論文就有數百頁, 許多討論都取決於高級用例的 (有時是假設的) 高度優化實現的性能。討論發生在 SG1 (並發) 、EWG (演化) 、LEWG (庫演化) 、CWG (核心語言) 、LWG (庫) , 甚至在晚間會議和全體會議上。

在這些討論和提案中, 三種想法反覆出現: 

- 將協程的狀態及其操作表示為 lambda 表達式, 從而使協程優雅地適配 C++ 類型系統, 而不需要 `await` 式協程 [Kohlhoff 2013] 所使用的某些“編譯器魔法”。
- 為無堆疊和有堆疊協程提供通用介面——也可能為其他類型的並發機制, 例如綫程和纖程, 提供通用介面。[Kowalke 2015; Riegel 2015]。
- 為了在最簡單和最關鍵的用途 (生成器和管道) 上獲得最佳性能 (運行時間和空間) , 無堆疊協程需要編譯器支援, 並且一定不能為了支援更高級的用例而在介面上作妥協 [Nishanov 2018, 2019b]。

你不可能同時滿足這三者。我非常喜歡通用介面的想法, 因為這樣可以最大限度地減少學習需要的努力, 並使得實驗大為便捷。類似地, 使用完全普通的對象來表示協程將開放整個語言來支援協程。然而, 最終性能論勝出。

在 2017 年, Gor Nishanov 基于 `await` 無堆疊方式的提案被接受為 TS [Nishanov 2017]。這一提案 (不可避免地被戲稱為“Gor-routines”) 獲得批准的原因是, 它的實現在其關鍵用例 (管道和生成器) 中表現出了卓越的性能 [Jonathan et al. 2018; Psaropoulos et al. 2017]。之所以把它寫成 TS, 而不是放到標準中, 是因為許多人喜歡更通用 (但速度較慢) 的有堆疊協程, 有些人仍然希望這兩種方式的零開銷統一。我當時 (今天仍沒有變) 的觀點是, 在合理的時間段裡, 統一並不可能。我已經等了近 30 年的時間讓協程重新回到 C++ 中, 我可不想等待一個可能永遠不會到來的突破: “最好是好的敵人。”

和往常一樣, 命名是一個有爭議的問題。特別是, TS 草案使用了關鍵字 `yield`, 這很快被判定為一個流行的標識符 (例如, 在金融和農業領域) 。而且, 協程產生的結果需要被包到一個呼叫者可以等待的結構中 (例如, `future` ([§4.1.3](04.md#413-期值future)) ) , 因此, 協程 `return` 語句的語義與普通 `return` 語句的語義不是完全一樣。所以, 有些人就反對 `return` 的“復用”。作為回應, 演化工作組引入了關鍵字 `co_return`、`co_yield` 和 `co_await`, 用於協程中的三個關鍵操作。使用下劃線是為了防止母語為英語的人將 `coreturn`、`coyield` 和 `coawait` 誤讀為 `core-turn`、`coy-ield` 和 `coa-wait`。人們也探索了使 `yield` 和 `await` 成為上下文敏感的關鍵詞的可能性, 但沒有達成共識。這些新的關鍵詞並不漂亮, 它們很快就成為了那些出於任何原因不喜歡 TS 協程的人們的靶子。

在 2018 年, TS 協程被提議納入 C++20 標準, 但在最後那一刻, 來自谷歌的 Geoff Romer、James Dennett 和 Chandler Carruth 提出了一個對新手頗不友好的提案 [Romer et al. 2018]。谷歌的提案名為“核心協程” (Core Coroutines) , 它和 Gor 的提案一樣, 需要庫支援來使基本機制對非專家使用者變得友好。所需要的庫當時還沒有設計好。核心協程被宣稱比 TS 協程更高效, 並且解決了谷歌的一個用例, 用於不基于異常的錯誤傳播。其思想基于將協程的狀態表示為 lambda 表達式。為了避免人們普遍鄙視的關鍵詞 `co_return`、`co_yield` 和 `co_await`, 核心協程提供了據稱更友好的運算符 `[->]` 和 `[<-]`。令人驚訝的是, 作為運算符, `[->]` 有四個字元長, 並且有四個操作數, “`[`”和“`]`”是標記的一部分。不幸的是, 核心協程沒有實現, 因此可用性和效率的主張無法得到驗證。這推遲了關於協程的進一步決定。

TS 協程的一個重要且可能致命的問題是, 它依賴于自由存儲區 (動態記憶體、堆) 上的分配。在某些應用程式中, 這是很大的開銷。更糟糕的是, 對於許多關鍵的實時和嵌入式應用程式, 自由存儲區的使用是不允許的, 因為它可能導致不可預測的響應時間和記憶體碎片的可能性。核心協程沒有這個問題。然而, Gor Nishanov 和 Richard Smith 論證了, TS 協程可以通過多種方式之一保證几乎所有用途都沒有 (並檢測和防止其他用途) 自由存儲區的使用 [Smith and Nishanov 2018]。特別是, 對於几乎所有的關鍵用例, 都可以將自由存儲區使用優化為堆疊分配 (所謂的“Halo 優化”[^1]) 。

隨着時間的推移, 核心協程不断發展和完善 [Romer et al. 2019a], 但完整的實現一直沒有出現。在 2018 年, 保加利亞國家標準機構反對 TS 協程設計 [Mihaylov and Vassilev 2018], 並提出了另一種設計 [Mihaylov and Vassilev 2019]。又一次, 提案宣稱具有優雅、通用性和高性能, 但同樣地, 沒有任何實現存在。

這時候, 演化小組的負責人 Ville Voutilainen 要求這三個仍然活躍的提案的作者撰寫兩份評估和比較論文: 

- *Coroutines: Use-cases and Trade-offs* (《協程: 用例與取捨》) [Romer et al. 2019b]
- *Coroutines: Language and Implementation Impact* (《協程: 語言與實現影響》) [Smith et al. 2019]

這三個提案 (Gor、谷歌和保加利亞) 都是無堆疊的, 需要堆疊的用例被留給未來的提案。所有這些提案都有數量驚人的定製點 [Nishanov 2018], 它們的實現者和專家使用者都認為這些是必不可少的。結果表明, 在不同的提案中, 關鍵用例的表達並沒有顯著不同。因此, 這些差異可以認為很大程度上只是表面文章, 不用多理會。例如, `co_await` 比 `[<-]` 更醜嗎? 

這就只留下性能問題有待討論。Gor 的提案, 因為有着四年的生產環境使用, 並在微軟和 Clang 編譯器中都有實現, 而具有明顯的優勢。在 C++20 的關鍵投票之前的最後幾次會議上, 委員會聽取了來自 Sandia [Hollman 2019]、微軟 [Jonathan et al. 2018] 和 Facebook [Howes et al. 2018] 的人的體驗報告, 並考慮了一些關於基于使用體驗的改進和簡化的建議 [Baker 2019]。然而,  (據我判斷) 打動委員會、使其以 48 比 4 的絶對優勢投票支援 Gor-routine 的要點是, 在使用“普通的 lambda 表達式”來代表協程狀態的策略中發現了一個根本性的缺陷。為了使表示協程狀態的 lambda 表達式與其他 lambda 表達式一樣, 必須在編譯的第一階段就知道其大小。只有這樣, 我們才能在堆疊上分配協程狀態、複製它們、移動它們, 並以語言允許的各種方式使用它們。但是, 在優化器運行之前, 堆疊幀 (根本上, 這就是無堆疊協程的狀態) 的大小是未知的。沒有從優化器返回到編譯器早期階段的訊息路徑。優化器可能會通過消除變數來減小幀的大小, 也可能會通過添加有用的臨時變數來增加幀的大小。因此, 用來代表某個協程狀態的 lambda 表達式不能是“普通的”。

最後, 考慮一個 C++20 協程的簡單例子: 

```cpp
generator<int> fibonacci()  // 生成 0,1,1,2,3,5,8,13 ...
{
    int a = 0;    // 初值
    int b = 1;

    while (true) {
        int next = a+b;
        co_yield a;    // 返回下一個斐波那契數
        a = b;         // 更新值
        b = next;
    }
}

int main()
{
    for (auto v : fibonacci())
        cout << v << '\n';
}
```

使用 `co_yield` 使 `fibonacci()` 成為一個協程。`generator<int>` 返回值將保存生成的下一個 `int` 和 `fibonacci()` 等待下一個呼叫所需的最小狀態。對於非同步使用, 我們將用 `future<int>` 而不是 `generator<int>`。對協程返回類型的標準庫支援仍然不完整, 不過庫就應該在生產環境的使用中成熟。

委員會本來可以更好地處理協程提案嗎? 也許可以吧; C++20 協程與 Niklas Gustafsson 2012 年的提案非常相似。我們探索了替代方案固然很好, 但我們真的需要 7 年時間嗎? 許多有能力的人所做的大量努力是否可以更多協作、更少競爭? 我覺得更好的學術知識在早期階段會有所幫助。畢竟, 協程有約 60 年的歷史, 例如 [Conway 1963]。人們是知道 C++ 和相關語言中的現代方法的, 但我們的理解既未共享, 也不繫統。如果我們當初花上幾個月或一年的時間對基本設計選擇、實現技術、關鍵用例和文獻進行徹底審核, 我懷疑我們早在 2014 年就可以得出 2019 年 2 月得出的結論。之後的幾年本可以花在對我們所選擇的基本方法進行增量改進和功能添加上。

我們取得的進展和最後的成功很大程度上歸功于 Gor Nishanov。要不是有他的堅韌不拔和紮實實現 (他完成了微軟和 Clang 兩種編譯器裡的實現) , 我們在 C++20 也不會有協程。鍥而不捨是在委員會成功的關鍵要素。

### 9.3.3 編譯期計算支援

多年以來, 在 C++ 中編譯期求值的重要性一直在穩步提高。STL 嚴重依賴于編譯期分發 [Stroustrup 2007], 而模板元編程主要旨在將計算從運行期轉移到編譯期 ([§10.5.2](10.md#1052-元編程)) 。甚至在早期的 C++ 中, 對重載的依賴以及虛函數表的使用都可以看作是通過將計算從運行期轉移到編譯期來獲得性能。因此, 編譯期計算一直是 C++ 的關鍵部分。

C++ 從 C 繼承了只限于整型且不能呼叫函數的常數表達式。曾有一段時間, macro 對於任何稍微複雜點的事情都必不可少。但這些都不好規模化。一旦引入模板並發現了模板元編程, 模板元編程就被廣泛用於在編譯期計算值和類型上 ([§10.5.2](10.md#1052-元編程)) 。在 2010 年, Gabriel Dos Reis 和 Bjarne Stroustrup 發表了一篇論文, 指出編譯期的值計算可以 (也應該) 像其他計算一樣表達, 一樣地依賴于表達式和函數的常規規則, 包括使用使用者定義的類型 [Dos Reis and Stroustrup 2010]。這成為 C++11 ([§4.2.7](04.md#427-constexpr-函數)) 裡的 `constexpr` 函數, 它是現代編譯期編程的基礎。C++14 推廣了 `constexpr` 函數 ([§5.5](05.md#55-constexpr-函數中的局部變數)) , 而 C++20 增加了好幾個相關的特性: 

- `consteval`——保證在編譯期進行求值的 `constexpr` 函數 [Smith et al. 2018a]
- `constinit`——保證在編譯期初始化的聲明修飾符 [Fiselier 2019]
- 允許在 `constexpr` 函數中使用成對的 `new` 和 `delete` [Dimov et al. 2019]
- `constexpr string` 和 `constexpr vector` [Dionne 2018]
- 使用 `virtual` 函數 [Dimov and Vassilev 2018]
- 使用 `unions`、異常、`dynamic_cast` 和 `typeid` [Dionne and Vandevoorde 2018]
- 使用使用者定義類型作為值模板參數——最終允許在任何可以用內置類型的地方使用使用者定義類型 [Maurer 2012]
- `is_constant_evaluated()` 謂詞——使庫實現者能夠在優化程式碼時大大減少平台相關的內部函數的使用 [Smith et al. 2018b]

隨着這一努力, 標準庫正在變得對編譯期求值更加友好。

這一努力的最終目的是為了讓 C++23 或更高版本支援靜態反射 ([§9.6.2](#962-靜態反射)) 。在我最初設計模板時, 曾期望使用使用者自定義類型作為模板參數類型, 使用字元串作為模板參數, 但以我當時的能力無法恰當地設計和實現出這一功能。

有些人希望**每一個** C++ 構造在編譯期都能可用。特別是, 他們希望能夠在 `constexpr` 函數中使用完整的標準庫。那可能就好過頭了。比如, 你真的需要在編譯期使用綫程嗎? 是的, 這可行。沒有使所有函數在編譯期都可用, 這就給我們留下了一個問題: 哪些應該可用, 哪些不應該可用。到目前為止, 答案有點臨場發揮而並不連貫。這需要進一步完善。

要讓一個語言的構造或庫組件成為 `constexpr`, 我們必須非常精確地進行描述, 並消除未定義行為的可能性。因此, 推動編譯期求值已經成為更精確的規範說明、平台依賴性分析和未定義行為根源分析的主要驅動力。

顯然, 這種對編譯期計算的推動為編譯器帶來了更多的工作。介面裡需要增加更多的訊息, 來允許編譯器完成所有的工作, 這個問題正在通過模組來解決 ([§9.3.1](#931-模組)) 。編譯器還通過緩存結果進行補償, 依賴並行構建的系統也很常見。然而, C++ 程式員必須學會限制編譯期計算和元編程的使用, 只有在值得為了程式碼緊湊性和運行期性能而引入它們的地方纔使用。

### 9.3.4 &lt;=>

參見 ([§8.8.4](08.md#884-預設比較)) 。緊接在“飛船運算符” (`<=>`) 投票進入 C++20 之後, 很明顯, 在語言規則及其與標準庫的整合方面都需要進一步的認真工作。出於對解決跟比較有關的棘手問題的過度熱情和渴望, 委員會成了意外後果定律的受害者。一些委員 (包括我在內) 擔心引入 `<=>` 過于倉促。然而, 在我們的擔憂坐實的時候, 早已經有很多工作在假設 `<=>` 可用的前提下完成了。此外, 三向比較可能帶來的性能優勢讓許多委員會成員和其他更廣泛的 C++ 社區成員感到興奮。因此, 當發現 `<=>` 在重要用例中導致了顯著的低效時, 那就是一個相當令人不快的意外了。類型有了 `<=>` 之後, `==` 是從 `<=>` 生成的。對於字元串, `==` 通常通過首先比較大小來優化: 如果字元數不同, 則字元串不相等。從 `<=>` 生成的 `==` 則必須讀取足夠的字元串以確定它們的詞典順序, 那開銷就會大得多了。經過長時間的討論, 我們決定不從 `<=>` 生成 `==`。這一點和其他一些修正 [Crowl 2018; Revzin 2018, 2019; Smith 2018c] 解決了手頭的問題, 但損害了 `<=>` 的根本承諾: 所有的比較運算符都可以從一行簡單的程式碼中生成。此外, 由於 `<=>` 的引入, `==` 和 `<` 現在有了許多不同於其他運算符的規則 (例如, `==` 被假定為對稱的) 。無論好壞, 大多數與運算符重載相關的規則都將 `<=>` 作為特例來對待。

### 9.3.5 範圍

**範圍庫**始於 Eric Niebler 對 STL 序列觀念的推廣和現代化的工作 [Niebler et al. 2014]。它提供了更易於使用、更通用及性能更好的標準庫演演算法。例如, C++20 標準庫為整個容器的操作提供了期待已久的更簡單的表示方法: 

```cpp
void test(vector<string>& vs)
{
    sort(vs);   // 而不是 sort(vs.begin(),vs.end())
}
```

C++98 [Stroustrup 1993] 改採用的原始 STL 將序列定義為一對迭代器。這遺漏了指定序列的兩種重要方式。範圍庫提供了三種主要的替代方法 (現在稱為 `ranges`) : 

- `(首項,尾項過一)` 用於當我們知道序列的開始和結束位置時 (例如“對 vector 的開始到結束位置進行排序”) 。
- `(首項,元素個數)` 用於當我們實際上不需要計算序列的結尾時 (例如“查看列表的前 10 個元素”) 。
- `(首項,結束判據)` 用於當我們使用謂詞 (例如, 一個哨位) 來定義序列的結尾時 (例如“讀取到輸入結束”) 。

`range` 本身是一種 `concept` ([§6](06.md#6-概念)) 。所有 C++20 標準庫演演算法現在都使用概念進行了精確規定。這本身就是一個重大的改進, 並使得我們在演演算法裡可以推廣到使用範圍, 而不僅僅是迭代器。這種推廣允許我們把演演算法如管道般連接起來: 

```cpp
vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

auto even = [](int i){ return i%2 == 0; }

for (int i : vec | view::filter(even)
                 | view::transform( [](int i) { return i*i; } )
                 | view::take(5))
    cout << i << '\n';    // 打印前 5 個偶整數的平方
```

像在 Unix 中一樣, 管道運算符 `|` 將其左操作數的輸出作為輸入傳遞到其右操作數 (例如 `A|B` 表示 `B(A)`) 。一旦人們開始使用協程 ([§9.3.2](#932-協程)) 來編寫管道過濾器, 這就會變得有趣得多。

在 2017 年, 範圍庫成為了 TS [Niebler and Carter 2017]; 在 2019 年 2 月, 它被投進了 C++20 [Niebler et al. 2018]。

### 9.3.6 日期和時區

日期庫是 Howard Hinnant (現在任職于 Ripple, 之前任職于蘋果) 的作品, 為 C++ 提供標準的日曆和時區支援 [Hinnant and Kamiński 2018]。它基于 `chrono` 標準庫的時間支援。Howard 也是 `chrono` 標準庫 ([§4.6](04.md#46-c11標準庫組件)) 背後的主要人物。日期庫是多年工作和實際使用的結果。在 2018 年, 它通過投票進入了 C++20, 並和舊的時間工具一起放在 `<chrono>` 中。

考慮如何表達時間點 (`time_point`) : 

```cpp
constexpr auto tp = 2016y/May/29d + 7h + 30min + 6s + 153ms;
cout << tp << '\n';    // 2016-05-29 07:30:06.153
```

該表示法很傳統 (使用使用者定義的字面量[§4.2.8](04.md#428-使用者定義字面量)) ) , 日期表示為 `年,月,日` 結構。但是, 當需要時, 日期會在編譯期映射到標準時間綫 (`system_time`) 上的某個點 (使用 `constexpr` 函數 ([§4.2.7](04.md#427-constexpr-函數)) ) , 因此它極其快速, 也可以在常數表達式中使用。例如: 

```cpp
static_assert(2016y/May/29==Thursday);  // 編譯期檢查
```

預設情況下, 時區是 UTC (又稱 Unix 時間) , 但轉換為不同的時區很容易: 

```cpp
zoned_time zt = {"Asia/Tokyo", tp};
cout << zt << '\n';          // 2016-05-29 16:30:06.153 JST
```

日期庫還可以處理星期幾 (例如, `Monday` 和 `Friday`) 、多個日曆 (例如, 格里曆和儒略曆) , 以及更深奧 (但必要) 的概念, 比如閏秒。

除了有用和快速之外, 日期庫還有趣在它提供了非常細粒度的靜態類型檢查。常見錯誤會在編譯期捕獲。例如: 

```cpp
auto d1 = 2019y/5/4;    // 錯誤: 是 5 月 4 日還是 4 月 5 日? 
auto d2 = 2019y/May/4;  // 正確
auto d2 = May/4/2019;   // 正確 (日跟在月後面) 
auto d3 = d2+10;        // 錯誤: 是加 10 天、10 個月還是 10 年? 
```

日期庫是標準庫組件中的一個少見的例子, 它直接服務于某應用領域, 而非“僅僅”提供支援性的“計算機科學”抽象。我希望在將來的標準中能看到更多這樣的例子。

### 9.3.7 格式化

iostream 庫提供了類型安全的 I/O 的擴展, 但是它的格式化工具比較弱。另外, 還有的人不喜歡使用 `<<` 分隔輸出值的方式。格式化庫提供了一種類 `printf` 的方式去組裝字元串和格式化輸出值, 同時這種方法類型安全、快捷, 並能和 iostream 協同工作。這項工作主要是由 Victor Zverovich [Zverovich 2019] 完成的。

類型中帶有 `<<` 運算符的可以在一個格式化的字元串中輸出: 

```cpp
string s = "foo";
cout << format("The string '{}' has {} characters",s,s.size());
```

輸出結果是 `The string 'foo' has 3 characters`。

這是“類型安全的 `printf`”變參模板思想的一個變體 ([§4.3.2](04.md#432-變參模板)) 。大括號 `{}` 簡單地表示了插入參數值的預設表示形式。

參數值可以按照任意順序被使用: 

```cpp
// s 在 s.size() 前: 
cout << format("The string '{0}' has {1} characters",s,s.size());
// s.size() 在 s 前: 
cout << format("The string '{1}' has {0} characters",s.size(),s);
```

像 `printf()` 一樣, `format()` 為展現格式化細節提供了一門小而完整的編程語言, 比如欄位寬度、浮點數精度、整數基和欄位內對齊。不同於 `printf()`, `format()` 是可擴展的, 可以處理使用者定義類型。下面是 `<chrono>` 庫中 ([§9.3.6](#936-日期和時區)) 一個打印日期的例子 [Zverovich et al. 2019]: 

```cpp
string s1 = format("{}", birthday);
string s2 = format("{0:>15%Y-%m-%d}", birthday);
```

“年-月-日”是預設格式。`>15` 意味着使用 15 個字元和右對齊文本。日期庫中還包含了另一門小的格式化語言可以同 `format()` 一起用。它甚至可以用來處理時區和區域: 

```cpp
std::format(std::locale{"fi_FI"}, "{}", zt);
```

這段程式碼將會給出芬蘭的當地時間。預設情況下, 格式化不依賴于區域, 但是你可以選擇是否根據區域來格式化。相比于傳統的 iostream, 預設區域無關的格式化大大提升了性能, 尤其是當你不需要區域訊息的時候。

輸入 (`istream`) 沒有等價的 `format` 支援。

### 9.3.8 跨度

越界訪問, 有時也稱為緩衝區溢出, 從 C 的時代以來就一直是一個嚴重的問題。考慮下面的例子: 

```cpp
void f(int* p, int n)  // n 是什麼? 
{
    for (int i=0; i<n; ++i)
        p[i] = 7;  // 可以嗎? 
}
```

試問一個工具, 比如編譯器要如何知道 `n` 代表着所指向的陣列中元素的個數? 一個程式開發人員如何要能夠在一個大型程式中對此始終保持正確? 

```cpp
int x = 100;
int a[100];
f(a,x);    // 可以
f(a,x/2);  // 可以: a 的前半部分
f(a,x+1);  // 災難! 
```

幾十年來, 像“災難”這樣的評論一向是準確的, 範圍錯誤也一直是大多數重大安全問題的根因。編譯器不能夠捕獲範圍錯誤, 而運行期檢查所有的下標則普遍被認為對於生產程式碼來說代價過于高昂。

顯而易見的解決方案就是提供一種抽象機制, 帶有一個指標再加上一個大小。舉例來說, 1990 年, Dennis Ritchie 向 C 標準委員會提議: “‘胖指標’, 它的表示中包括了記憶體空間以存放運行期可調整的邊界。”[Ritchie 1990]。由於各種原因, C 標準委員會沒有通過這個提案。在當時, 我聽到一條極可笑的評論: “Dennis 不是 C 的專家; 他從不來參加會議。”我沒記住這到底是誰說的, 也許這是件好事。

2015 年, Neil MacIntosh (那個時候他還在微軟) 在 C++ 核心指南 ([§10.6](10.md#106-編碼指南)) 裡恢復了這一想法, 那裡我們需要一種機制來鼓勵和選擇性地強制使用高效編程風格。`span<T>` 類模板就這樣被放到 C++ 核心指南的支援庫中, 並立即被移植到微軟、Clang 和 GCC 的 C++ 編譯器裡。2018 年, 它投票進入了 C++20。

使用 `span` 的一個例子如下: 

```cpp
void f(span<int> a)  // span 包含一根指標和一條大小訊息
{
    for (int& x : a)
        x = 7;  // 可以
}
```

範圍 `for` 從跨度中提取範圍, 並準確地遍歷正確數量的元素 (無需代價高昂的範圍檢查) 。這個例子說明了一個適當的抽象可以同時簡化寫法並提升性能。對於演演算法來說, 相較于挨個檢查每一個訪問的元素, 明確地使用一個範圍 (比如 `span`) 要容易得多, 開銷也更低。

如果有必要的話, 你可以顯式地指定一個大小 (比如操作一個子範圍) 。但這樣的話, 你需要承擔風險, 並且這種寫法比較扎眼, 也易於讓人警覺: 

```cpp
int x = 100;
int a[100];
f(a);        // 模板參數推導: f(span<int>{a, 100})
f({a,x/2});  // 可以: a 的前半部分
f({a,x+1});  // 災難
```

自然、簡單的元素訪問也辦得到, 比如 `a[7]=9`, 同時運行期也能進行檢查。`span` 的範圍檢查是 C++ 核心指南支援庫 (GSL) 的預設行為。

事實證明, 將 `span` 納入 C++20 的最具爭議的部分在於下標和大小的類型。C++ 核心指南中 `span::size()` 被定義返回一個有符號整數, 而不是標準庫容器所使用的無符號整數。下標的情況也類似。像在陣列中, 下標一向是有符號的整數, 而在標準庫容器中下標卻是無符號整數。這導致了一個古老爭議的重演: 

- 一組人認為顯然下標作為非負數應該使用無符號整數。
- 一組人認為與標準庫容器保持一致性更重要, 這點使得使用無符號整數是不是一個過去的失誤變得無關緊要。
- 一組人認為使用無符號整數去表示一個非負數是一種誤導 (給人一種虛假的安全感) , 並且是錯誤的主要來源之一。

不顧 `span` 最初的設計者 (包括我在內) 和實現者的強烈反對, 第二組贏得了投票, 並受到第一組熱情地支援。就這樣, `std::span` 擁有無符號的範圍大小和下標。我個人認為那是一個令人悲傷的失敗, 即未能利用一個難得的機會來彌補一個令人討厭的老錯誤 [Stroustrup 2018e]。C++ 委員會選擇了與問題兼容而不是消除一個重大的錯誤來源, 這在某種程度上是可以預見的, 也算不無道理吧。

但是用無符號整數作為下標會出什麼問題呢? 這似乎是一個相當情緒化的話題。我曾收到很多封與之相關的仇恨郵件。存在兩個基本問題: 

- 無符號數並不以自然數為模型: 無符號數使用模算數, 包括減法。比如, 如果 `ch` 是個 `unsigned char`, `ch+100` 將永遠不會溢出。
- 整數和無符號數彼此相互轉換, 稍不留意負數值就會變成巨大的無符號數值, 反之亦然。比如, `-2<2u` 為假; `2u` 是 `unsigned`, 因此 `-2` 在比較前會被轉換為一個巨大的正整數。

這是一個在真實環境下偶爾可見的無限循環的例子: 

```cpp
for (size_t i = n-1; i >= 0; --i) { /* ... */ }  // “反向循環”
```

不幸的是, 標準庫中的類型 `size_t` 是無符號類型, 然後很明顯結果永遠 `>=0`。

總的來說, 作為 C++ 繼承自 C 的特性, 有符號和無符號類型之間的轉換規則幾十年來都是那種難以發現的錯誤的一個主要來源。但說服委員會去解決那些老問題總是很難的。

## 9.4 並發

儘管做出了英勇的努力, 並正在形成廣泛的共識, 但是人們所期望的通用並發模型 (“執行器”) 在 C++20 中還沒有準備好 ([§8.8.1](08.md#881-網路庫)) 。這並非是因為缺乏努力, 我們的努力中包括了 2018 年 9 月在華盛頓州貝爾維爾舉行的為期兩天的特別會議, 約有 25 人出席, 其中有來自英偉達、Facebook 和美國國家實驗室的代表。不過, 有幾個不那麼劇烈的有用改進還是及時完成了, 其中包括: 

- `jthread` 和停止令牌 [Josuttis et al. 2019a]
- `atomic<shared_ptr<T>>` [Sutter 2017b]
- 經典的信號量 [Lelbach et al. 2019]
- 屏障和鎖存器 [Lelbach et al. 2019]
- 小的記憶體模型的修復和改進 [Meredith and Sutter 2017]

`jthread` (“joining thread”的縮寫) 是一個遵守 RAII 的綫程; 也就是說, 如果 `jthread` 超出作用域了, 它的解構子將合併綫程而不是終止程式: 

```cpp
void some_fct()
{
    thread t1;
    jthread t2;
    // ...
}
```

在作用域的最後, `t1` 的解構子會終止程式, 除非 `t1` 的任務已經完成, 已經 `join` 或 `detach`, 而 `t2` 的解構子將會等待其任務完成。

一開始的時候 (C++11 之前) , 很多人 (包括我在內) 都希望 `thread` 可以擁有如今 `jthread` 的行為, 但是根植于傳統作業系統綫程的人堅持認為終止一個程式要遠比造成死鎖好得多。2012 年和 2013 年, Herb Sutter 曾經提出過合併綫程 [Sutter 2012, 2013a]。這引發了一系列討論, 但最終卻沒有作出任何決定。2016 年, Ville Voutilainen 總結了這些問題, 併為將合併綫程納入 C++17 發起了投票 [Voutilainen 2016a]。投票支援者眾多以至於我 (只是半開玩笑地) 建議我們甚至可以把合併綫程作為一個錯誤修復提交給 C++14。但是不知何故, 進展又再次停滯。到了 2017 年, Nico Josuttis 又一次提出了這個問題。最終, 在八次修訂和加入了停止令牌之後, 這個提案才成功進入了 C++20 [Josuttis et al. 2019a]。

“停止令牌”解決了一個老問題, 即如何在我們對綫程的結果不再感興趣後停止它。基本思想是使用協作式的綫程取消方式 ([§4.1.2](04.md#412-綫程和鎖)) 。假如我想要一個  `jthread` 停止, 我就設置它的停止令牌。綫程有義務不時地去檢查停止令牌是否被設置了, 並在設置時進行清理和退出。這個技巧由來已久, 對於几乎每一個有主循環的綫程都能完好高效地工作, 在這個主循環裡就可以對停止令牌進行檢查。

像往常一樣, 命名成了問題: `safe_thread`、`ithread` (`i` 代表可中斷) 、`raii_thread`、`joining_thread`, 最終成了 `jthread`。C++ 核心指南支援庫 (GSL) 中稱其為 `gsl::thread`。說真的, 最合適的名字就是 `thread`, 但是很不幸, 那個名字已經被一類不太有用的綫程占用了。

## 9.5 次要特性

C++20 提供了許多次要的新特性, 包括: 

- C99 風格的指派初始化器 [Shen et al. 2016]
- 對 lambda 捕獲的改進 [Köppe 2017b]
- 泛型 lambda 表達式的模板參數列表 [Dionne 2017]
- 範圍 `for` 中初始化一個額外的變數 ([§8.7](08.md#87-條件的顯式測試)) 
- 不求值語境中的 lambda 表達式 [Dionne 2016]
- lambda 捕獲中的包展開 [Revzin 2017]
- 在一些情況下移除對 `typename` 的需要 [Vandevoorde 2017]
- 更多屬性: `[[likely]]` 和 `[[unlikely]]` [Trychta 2016]
- 在不使用macro 的情況下, `source_location` 給出一段程式碼中的原始碼位置 [Douglas and Jabot 2019]
- 功能測試macro  [Voutilainen and Wakely 2018]
- 條件 `explicit` [Revzin and Lavavej 2018]
- 有符號整數保證是 2 的補碼 [Bastien 2018]
- 數學上的常數, 比如 `pi` 和 `sqrt2` [Minkovsky and McFarlane 2019]
- 位的操作, 比如輪轉和統計 1 的個數 [Maurer 2019]

其中有些屬於改進, 但是我擔心的是晦澀難懂的新特性的數量之大會造成危害 [Stroustrup 2018d]。對於非專家來說, 它們使得語言變得更加難以學習, 程式碼更加難以理解。我反對一些利弊參半的特性 (比如, 使用指派初始化器的地方原本可以使用建構子, 那會產生更易於維護的程式碼) 。很多特性具有特殊用途, 有些是“專家專用”。不過, 有的人總是領會不到, 一個對某些人有某種好處的特性, 對於 C++ 整體可能是個淨負債。當然, 那些增加寫法和語義上的通用性和一致性的小特性, 則總是受歡迎的。

從標準化的角度來看, 即使最小的特性也需要花時間去處理、記錄和實現。這些時間是省不掉的。

## 9.6 進行中的工作

當然, 很多目標放在 C++20 之後版本的工作還在進行中, 而另一些原本目標在 C++20 發佈的工作則沒能及時完成, 尤其是: 

- [§8.8.1](08.md#881-網路庫): 網路和執行器——再度延遲。
- [§9.6.1](#961-契約): 契約——斷言、前置條件和後置條件; 原本目標是 C++20, 但延遲了。
- [§9.6.2](#962-靜態反射): 反射——基于當前編譯的程式碼將程式碼注入程式; 目標是 C++23。

另外, 工作組和研究組也仍有工作正在進行中 ([§3.2](03.md#32-組織)) [Stroustrup 2018d]。

### 9.6.1 契約

契約的特殊之處在於, 不但很多人希望它可以進入 C++20, 而且契約是被投票寫入 C++20 的工作檔案中的, 只是在最後一刻被從中移除。一個由 John Spicer 主持的新的研究組 SG21 已經成立, 試圖為 C++23 或者 C++26 提供某種形式的契約。契約于 C++20 的遭遇是令人惋惜的, 但可能也能給人以啟發。

各種形式的契約在 C++ 和其他語言中都有着悠久的歷史。我記得在 1970 年代初, 當我第一次遇到 Peter Naur 的不變數 [Naur 1966] 的時候, 我一度被它深深吸引。在 1990 年代早期, 一個被稱為 A++ 的斷言系統被考慮用於 C++, 但卻被認為涉及面太廣而不現實。在 1980 年代晚期, Bertrand Meyer 曾推廣過 Eiffel 裡“契約”的概念 [Meyer 1994]。作為 C++0x 努力的一部分, 一些提案 [Crowl and Ottosen 2006] 在 C++ 委員會受到了高度重視, 但最終卻失敗了, 主要原因在於被認為過于複雜, 寫法也不優雅。

多年來, Bloomberg (那家紐約市的金融訊息公司) 一直使用一個名為“契約”的實時斷言系統去捕獲程式碼中的問題。2013 年, 來自 Bloomberg 的 John Lakos 提議標準化該系統 [Lakos and Zakharov 2013]。這個提案受到了好評, 但它遇到兩個問題: 

- 它基于macro 
- 它嚴格來說是程式碼實現中的斷言, 而不是可以增強介面的東西

修訂接踵而至, 但是共識卻沒有出現。為了打破僵局, 一群來自微軟、Facebook、谷歌和馬德里的卡洛斯三世大學的人提出一個“簡單契約”的系統, 該系統不使用macro , 並且對前置條件和後置條件提供支援 (正如 C++0x 所嘗試的) [Garcia et al. 2015]。和 Bloomberg 的提案一樣, 這一提案得到了多年大規模工業應用的背書, 但它的重點是在靜態分析中使用契約。J. Daniel Garcia (卡洛斯三世大學) 努力工作以求做出滿足各方面需求的設計, 但該提案也遭到了反對。

經過了無數次的會議、多篇論文和 (偶爾激烈的) 討論之後, 妥協顯然是難以達成了。兩個小組請求我來進行協調。我之前宣稱, 討論太專注在細枝末節上了, 而我們需要一個最小提案, 包含兩個小組的核心訴求, 而不是有爭議的細節。他們要我來證明我的推斷, 拿一個這樣的最小提案出來。在我和兩個小組的代表輪番討論、工作了相當一段時間之後, 我們最終聯合各方共同起草了聯合提案 [Dos Reis et al. 2016a]。我認為這個設計技術上是相當充分的, 並非一個政治上的妥協。它旨在滿足三方面的需求 (按重要性排序) : 

- 系統和可控的運行期測試
- 為靜態分析器提供訊息
- 為優化器提供訊息

在 J. Daniel Garcia 領導的進一步工作之後, 該提案最終在 2018 年 6 月正式被 C++20 採納 [Dos Reis et al. 2018]。

為避免引入新的關鍵字, 我們使用屬性語法。例如, `[[assert: x+y>0]]`。一個契約對一個有效的程式不起任何作用, 因此這種方式滿足屬性的原來概念 ([§4.2.10](04.md#4210-屬性)) 。

有三種契約: 

- `assert`——可執行程式碼中的斷言
- `expects`——函數聲明中的前置條件
- `ensure`——函數聲明中的後置條件

有三種不同等級的契約檢查: 

- `audit`——“代價高昂的”謂詞, 僅在某些“除錯模式”檢查
- `default`——“代價低廉的”謂詞, 即使在生產程式碼中檢查也是可行的
- `axiom`——主要給靜態分析器看的謂詞, 在運行期從不檢查

在違反契約時, 將執行 (可能是使用者安裝的) 契約違反處理程式。預設行為是程式立即終止。

我發現一個有意思的事: 有一種構建模式允許程式在契約失敗後繼續執行。我的第一反應是“瘋了吧! 契約旨在防止違反契約的程式運行”。那算是最最常見的反應了。不論如何, John Lakos 堅信, 基于 Bloomberg 程式碼的相關經驗, 當你把契約加入一個大型的古老程式碼倉庫, 契約總是會被違反: 

- 某些程式碼會違反契約, 而實際上並沒有做任何該契約所要防止的事情。
- 某些新契約本身就包含錯誤。
- 某些新契約具有意料之外的效果。

有了繼續的選項, 你可以使用契約違反處理程式去記錄日誌並繼續運行。這樣的話, 你既可以在單次運行中檢測到多次違規, 也可以讓契約在假定正確的老程式碼中啟用。人們相信這是逐步採用契約的關鍵。

我們並沒有找到充足的理由去添加類不變數, 或允許在覆蓋函數中削弱前置條件, 或允許在覆蓋函數中增強後置條件。要點是簡單。理想情況是先為 C++20 提供一個最小的初始設計, 然後如有需要再在之上添磚加瓦。

這個設計由 J. Daniel Garcia 實現, 並于 2018 年 6 月投票通過進入 C++ 委員會的 C++20 的工作檔案中。像往常一樣, 雖然規範還有一些問題, 但我們相信能夠趕在最終標準發佈前的兩年內修復所有的問題。例如, 人們發現工作檔案文本中允許編譯器基于所有契約 (無論檢查與否) 進行優化。那並非有意而為之。從所有的契約在正確的程式中都有效的角度看, 這是合理的, 但是這麼做, 對於那些帶有特別為捕獲“不可能的錯誤”而寫的契約的程式來說卻是災難性的。考慮下面的例子: 

```cpp
[[assert: p!=nullptr]]
p->m = 7;
```

假如 `p==nullptr`, 那麼 `p->m` 將是未定義行為。編譯器被允許假設未定義行為不會發生; 由此編譯器優化掉那些導致未定義行為的程式碼。這樣做的結果可能讓人大吃一驚。在這樣的情況下, 如果違反契約之後程式能夠繼續執行, 編譯器將被允許假定 `p->m` 是有效的, 因此 `p!=nullptr`; 然後編譯器會消除契約關於 `p==nullptr` 的檢查。這種被稱為“時間旅行優化”的做法當然是與契約的初衷大相逕庭, 還好若干補救方案被及時提出 [Garcia 2018; Stroustrup 2019c; Voutilainen 2019a]。

2018 年 8 月, 在 C++20 新提案的最後期限過後, 由 John Lakos 領導的 Bloomberg 的一個小組, 包括 Hyman Rosen 和 Joshua Berne 在內, 提出了一系列重新設計的提案 [Berne et al. 2018; Berne and Lakos 2018a,b; Lakos 2018]。特性凍結的日期 (審議新提案的最後一天) 是由委員會全體投票表決確定的。這些提案則是基于在契約自身中規定契約行為的方案。例如, `[[assert check_maybe_continue: x>0]]` 和 `[[assert assume: p!=nullptr]]`。

與其使用構建模式去控制所有契約 (比如, 激活所有預設契約或關閉所有基于契約的運行期檢查) 的行為, 你不如直接修改單個契約的程式碼。在這方面, 這些新方案與工作檔案中決議通過的設計大相逕庭。考慮下面的例子: 

```cpp
[[assert assume: p!=nullptr]]
```

這將使得 2014 年被否決的基于macro 的方案捲土重來, 因為管理程式碼變化的顯然方式是用macro , 例如: 

```cpp
[[assert MODE1: p!=nullptr]]
```

這裡的 `MODE1` 可以被 `#define` 成所支援的若干選項之一, 如 `assume` 和 `default`。或者, 大致等效地, 通過命令行上的參數 (類似於命令行macro ) 來定義諸如 `assume` 之類的限定符的含義。

本質上, 契約違約後繼續執行的可能性與程式員對契約含義的控制的兩者的結合, 將把契約機制從斷言系統轉變為一種新的控制流機制。

一些提案甚至建議放棄對靜態分析的支援。類似這樣的提案有幾十個變種, 全都來得太晚, 沒一個能增進共識。

大量湧入的新奇提案 (來自 Bloomberg 團隊和其他團隊, 比如, [Berne 2019; Berne and Lakos 2019; Khlebnikov and Lakos 2019; Lakos 2019; Rosen et al. 2019]) 和成百上千討論這些提案的電子郵件阻礙了真正必需的討論, 即對工作檔案中的設計現狀進行問題修復。正如我曾不斷警告的那樣 (比如 [Stroustrup 2019c]) , 這些企圖重新設計契約的提案的結果是, 在 Nico Josuttis 的提議下, 契約被從 C++20 中移除 [Josuttis et al. 2019b]。我認為去年關於契約的討論是一個典型的例子, 誰都得不到任何東西, 因為有人只想要按他們的方式來。時間會給出答案, 是否新的研究組 SG21 能夠為 C++23 或 C++26 交付某種能夠被更廣泛接受的東西。

### 9.6.2 靜態反射

2013 年, 一個研究“反射”的研究組 (SG7) 成立了, 並發出了徵集意見的呼籲 [Snyder and Carruth 2013]。有一個廣泛的共識, 那就是 C++ 需要靜態反射機制。更確切地說, 我們需要一種方法來寫出能檢查它自己是屬於哪個程式的一部分的程式碼, 並基于此往該程式中注入程式碼。那樣, 我們就可以使用簡潔的程式碼替換冗長而棘手的樣板程式碼、macro 和語言外的生成器。比如, 我們可以為下面的場景自動生成函數, 如: I/O 流、日誌記錄、比較、用於存儲和網路的封送處理 (marshaling) 、構造和使用對象映射、列舉的“字元串化”、測試支援, 及其他的更多可能 [Chochlík et al. 2017; Stroustrup 2018g]。反射研究組的目標是為 C++20 或 C++23 做好準備; 我們認為 C++17 並不是一個現實的目標。

大家普遍認同, 依賴在運行期遍歷一個始終存在的資料結構的反射/內省方式不適合 C++, 因為這種資料的大小、語言構造的完整表示的複雜性和運行期遍歷的成本都會是問題。

很快出現了一些提案 [Chochlík 2014; Silva and Auresco 2014; Tomazos and Spertus 2014], 並且, 在接下來的數年裡, 由 Chandler Carruth 主持的研究組召開了多次會議試圖決定其範圍和方向。選定的方式基于類型, 這些類型以經典的物件導向的類層次結構來組織, 需要泛型的地方由概念 ([§6](06.md#6-概念)) 支援 [Chochlík 2015; Chochlík and Naumann 2016; Chochlík et al. 2017]。該方式主要由 Matóš Chochlík、Axel Naumann 和 David Sankel 發展和實現。結果作為一項技術規範在 2019 得以批准 [Sankel 2018]。

在靜態反射 (預期的) 長時間的醞釀期內, 基于 constexpr 函數 ([§9.3.3](#933-編譯期計算支援)) 的編譯期計算穩步發展, 最終出現了基于函數而不是類層次結構的靜態反射的提案。主要的擁護者是 Andrew Sutton、Daveed Vandevoorde、Herb Sutter 和 Faisal Vali [Sutton and Sutter 2018; Sutton et al. 2018]。設計焦點轉移的主要論據, 一部分是由於分析和生成程式碼這些事天生就是函數式的, 而且基于 constexpr 函數的編譯期計算已經發展到元編程和反射相結合的地步。這種方法的另一個優點 (最先由 Daveed Vandevoorde 提出) 是從編譯器的內部的資料結構看, 為函數服務的天生就比為類型層次結構服務的更小、生命周期更短暫, 因此它們使用的記憶體明顯更少, 編譯速度也明顯更快。

2019 年 2 月在科隆召開的標準會議上, David Sankel 和 Michael Park 展示了一個結合了這兩個方法優點的設計 [Sankel and Vandevoorde 2019]。在最根本的層面上僅有一個單一的類型存在。這達到了最大的靈活性, 並且編譯器開銷也最小。

最重要的是, 靜態類型的介面可以通過一種類型安全的轉換來實現 (從底層的單一類型 `meta::info` 到更具體的類型, 如 `meta::type_` 和 `meta::class_`) 。這裡有一個基于 [Sankel and Vandevoorde 2019] 的例子。通過概念重載 ([§6.3.2](06.md#632-概念使用)) , 它實現了從 `meta::info` 到更具體類型的轉換。考慮下面的例子: 

```cpp
namespace meta {
    consteval std::span<type_> get_member_types(class_ c) const;
}

struct baz {
    enum E { /*...*/ };
    class Buz{ /*...*/ };
    using Biz = int;
};

void print(meta::enum_);    // 打印一個列舉類型
void print(meta::class_);   // 打印一個類類型
void print(meta::type_);    // 打印任何類型

void f()
{
    constexpr meta::class_ metaBaz = reflexpr(baz);
    template for (constexpr meta::type_ member : get_member_types(metaBaz))
        print(meta::most_derived(member));
}
```

這裡關鍵的新語言特性是 `reflexpr` 運算符, 它返回一個 (元) 對象, 該對象描述了它的參數, 還有 `template for` [Sutton et al. 2019], 根據一個異質結構中的元素的類型擴展每個元素, 從而遍歷該結構的各元素。

此外, 我們也有機制可以將程式碼注入正在編譯的程式中。

類似這樣的東西很可能會在 C++23 或 C++26 中成為標準。

作為一個副作用, 在反射方案上的雄心勃勃的工作也刺激了編譯期求值功能的改進: 

- 標準中的類型特徵集 ([§4.5.1](04.md#451-實現技巧)) 
- 原始碼位置的macro  (如 `__FILE__` 和 `__LINE__`) 被內在機制所替代 [Douglas and Jabot 2019]
- 編譯期計算的功能 (例如, 用於確保編譯期求值的 `consteval`) 
- 展開語句 (`template for`——到 C++23 就可以用來遍歷元組中的元素 [Sutton et al. 2019]) 。

[^1]: 譯註: Heap Allocation eLision Optimization
