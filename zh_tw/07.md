# 7. 錯誤處理

錯誤處理作為一種備受爭議的話題, 我認為將長期存在下去。許多人在這個問題上有強烈的固有認知, 其中一些是基于各種應用領域中紮實的經驗——過去 50 多年已經有了很多相關的技術積累。在錯誤處理領域, 性能、通用性、可靠性的需求往往發生衝突。

與 C++ 一樣, 問題不是我們沒有解決方案, 而是有太多解決方案。從根本上講, 很難通過單一的機制來滿足 C++ 社區的多樣化需求, 但是人們往往只看到問題的一部分, 就以為他們掌握瞭解決問題的**終極方案** [Stroustrup 2019a]。

## 7.1 背景

C++ 從 C 語言中繼承了各種基于錯誤返回碼的機制, 錯誤可以用特殊值、全局狀態、局部狀態和回調等多種方式表達。例如: 

```cpp
double sqrt(double d);  // 當 d 為負數時, 設置 errno 為 33
int getchar();          // 遇到檔案結尾返回 -1
char* malloc(int);      // 如果分配出錯, 返回 0
```

C++ 的早期使用者 (1980 年代) 發現這些技術令人困惑, 也不足以解決所有問題。返回 (值,錯誤碼) 對變得流行, 但這更增加了混亂和變化。例如: 

```cpp
Result r = make_window(arguments); // Result 是 (值,錯誤碼) 對
if (r.error) {
    // ... 錯誤處理 ...
}
Shape* p = r.value;
```

繁瑣的重複錯誤檢查使程式碼變得混亂。使用錯誤碼時, 很難將程式的主要邏輯與錯誤處理區分開。程式的主綫 (業務邏輯) 與大量奇怪和模糊的錯誤處理程式碼緊密耦合在一起。對於那些錯誤處理本身就是主要的複雜邏輯而言, 這種基于錯誤返回碼的處理方式可能會帶來嚴重的問題。

使用包含 (值,錯誤碼) 對的類會帶來巨大的成本。除了檢測錯誤碼的成本外, 許多 ABI (應用程式二進制介面) 甚至不使用暫存器來傳遞小的結構體, 所以 (值,錯誤碼) 對不僅傳遞了更多的訊息 (是通常數量的兩倍) , 而且也使傳遞的性能有數量級的降低。可悲的是, 在許多 ABI 中, 尤其那些針對嵌入式系統的 ABI (專為 C 程式碼設計) , 這個問題直到今天 (2020 年) 依然存在。

此外, 在出錯的建構子中沒有真正好的方法來使用錯誤碼來處理故障 (建構子沒有返回值) , 還有那些過去流行的具有複雜類層次結構的系統, 子對象創建中各種潛在錯誤也很難通過錯誤碼的方式處理。

還有, 對於所有傳統的錯誤處理技術, 最令人頭疼的是人們會忘記檢查錯誤。這一直是錯誤的主要根源, 並且在 2020 年的今天依舊如此。C++ 異常機制的主要目標是使不完整或複雜的錯誤處理中的錯誤最小化。

C++ 異常是在 1988–89 年設計的, 旨在解決當時普遍存在的複雜且容易出錯的錯誤處理技術。它們記錄在 ARM (*The Annotated C++ Reference Manual*) [Ellis and Stroustrup 1990] 中, 並作為標準基礎文件 [Stroustrup 1993] 的一部分被 ANSI C++ 改採用。

與其他語言的異常設計相比, 用於 C++ 的異常設計由於需要結合使用 C++ 程式碼和其他語言 (尤其是 C) 的程式碼而變得複雜。考慮一個 C++ 函數 `f()` 呼叫一個 C 函數 `g()`, 該函數又呼叫一個 C++ 函數 `h()`。現在 `h()` 拋出異常由 `f()` 捕獲。通常, C++ 函數不知道被呼叫函數的實現語言。這樣的場景使我們不能通過修改函數簽名以添加“異常傳播參數”, 或隱式地向返回類型添加返回碼的方法做錯誤處理。

與使用其他技術相比, 異常與 RAII ([§2.2](02.md#22-第二個十年)) 一起解決了許多棘手的錯誤處理問題 (例如, 如何處理建構子中的錯誤以及那些遠離錯誤處理程式碼的錯誤) , 而且所需的時間成本要小得多 (與 1990 年代中期所用的技術相比通常不到 3％, 甚至更便宜) 。雖然異常從來沒有引起爭議, 但我還是低估了它們引起爭議的可能性。

## 7.2 現實中的問題

當然總有一些應用不適合使用異常, 例如: 

- 記憶體嚴重受限系統, 異常處理所需的運行期支援記憶體會占用應用程式功能所需要的記憶體。
- 工具鏈不能保證異常拋出後能夠迅速做出響應的硬實時系統 (例如 [Lockheed Martin Corporation 2005]) 。
- 系統依賴于多台不可靠的計算機, 因此立即崩潰並重新啟動是對付那些無法在本地處理的錯誤的合理 (且几乎是必要的) 方式。

因此, 大多數 C++ 實現仍然保留了非異常機制的錯誤處理方式。另一方面, 也存在一些通過錯誤碼無法提供良好解決方案的場景: 

- **建構子失敗**——由於建構子沒有返回值 (不算被構造對象本身) , 單純依賴 RAII 的方式必須替換為通過對對象狀態的顯式檢查來處理錯誤。
- **運算符**——沒有辦法從 `++`、`*`、`->` 中返回錯誤碼。你將不得不使用非本地錯誤指示或使用繁瑣的運算符名稱, 例如 `multiply(add(a,b),c)` 而不是 `(a+b)*c`。[^1]
- **回調**——使用回調的函數應該能夠呼叫具有多種可能錯誤的函數 (通常, 回調是 lambda 表達式 ([§4.3.1](04.md#431-lambda-表達式)) ) 。
- **非 C++ 程式碼**——我們無法通過那些沒有專門做錯誤碼處理的非 C++ 函數傳遞錯誤。
- **呼叫鏈深處新的錯誤類型**——必須準備呼叫鏈上的每個函數來處理或傳播一種新的錯誤 (例如, 程式中的網路錯誤, 而它並不是專門為通過網路訪問資料而預先設計的) 。
- **忘記處理返回碼**——有一些精巧的方案來試圖確保統一檢查錯誤碼, 但是它們要麼不完整, 要麼依賴于在遺漏檢查時使用異常或程式終止 (例如 [Botet and Bastien 2018]) 。

此外, 還有一些與使用異常有關的現實問題: 

- 有些人不願意引入異常機制, 是因為他們的程式碼由於無原則使用指標而形成了一團亂麻。通常, 這些人將他們的批評指向異常, 而不是他們的陳舊程式碼。
- 有些人 (很多) 根本不理解甚至不知道 RAII ([§2.2](02.md#22-第二個十年)) , 而只是把異常當作返回錯誤碼的一種替代機制來用。通常, 把 try-catch 當作 if-then 的一種形式來用的話, 程式碼比正確使用錯誤碼或 RAII 要更醜陋、更繁瑣、更緩慢。
- 異常的許多實現速度很慢, 是因為實現者把 C++ 的異常與其他類型的異常 (例如微軟的結構異常) 統一處理, 優先考慮除錯 (例如 GCC 在 `throw` 後兩次遍歷堆疊來保存回溯) , 使用單一機製為各種語言服務 (每一種都很糟糕) , 或者只是沒有在異常處理優化上花費很多開發精力。
- 這些年來, 異常處理的性能**相對**較慢, 是因為我們在優化非異常方面花費了大量精力。我懷疑還有很大的優化機會。例如, Gor Nishanov 報告說, 通過一些與 Windows 和 Linux 上的協程實現相關的簡單優化, 使速度提高了 1000 倍 [Nishanov 2019a]。不過, 大幅改善空間占用可能會更難實現。一些最近的實驗看起來還比較不錯 [Renwick et al. 2019]。
- 為了使異常被接受, 我們不得不添加了異常規約 [Stroustrup 2007]。但異常規約從來沒有提供支援者們所聲稱的更好的可維護性, 而確實提供了反對者 (包括我) 所詬病的冗長和開銷。一旦異常規約出現在語言中, 許多人就覺得使用它們是受到鼓勵的, 並將由此產生的問題歸咎于異常機制本身。具有諷刺意味的是, 那些堅定支援異常規約的人轉而去幫助設計 Java 了。異常規約在 2010 年被宣佈廢棄, 並最終在 2017 年被移除 ([§4.5.3](04.md#453-noexcept-規約)) 。作為部分替代方案, C++11 引入了 `noexcept` 作為一種更簡單、更有效的控制異常的機制 ([§4.5.3](04.md#453-noexcept-規約)) 。
- 通過指定要捕獲的異常類型來捕獲異常往往使 `throw` 和 `catch` 的實現與運行期類型識別 (RTTI [Stroustrup 2007]) 糾纏在一起, 這導致了效率低下和複雜性。特別是, 它會導致記憶體被消耗 (被 RTTI 所需的資料消耗) , 即使應用程式從不依賴 RTTI 來區分異常, 對於簡單的場景也很難做優化。而且, 依賴 RTTI 使得使用動態連結匹配很難優化。基本上, 異常處理實現是針對罕見的最複雜的情況進行優化的。當一個具有嵌套異常的類被添加到標準程式庫中, 人們甚至被鼓勵在最簡單的情況下使用它時, 情況就更糟了。對於可以靜態分析的類層次結構 (在許多嵌入式系統中) , 以常數時間進行快速類型匹配是可能的 [Gibbs and Stroustrup 2006]。由於異常是平台 ABI 的一部分, 這就使得要改變早期的過度設計非常之困難。
- 有人堅持只使用一種錯誤處理方法, 並且通常得出這樣的結論: 由於異常不適用於每種情況, 因此該方法必須是錯誤碼。那些由錯誤碼所帶來的問題也就僅僅是“不方便而已”。
- 一些人相信那些關於異常機制的基于最壞情況和/或不切實際的比較的低效傳聞, 例如在添加異常後保留錯誤碼處理方式, 將不完整的錯誤處理與基于異常的處理進行比較, 或者使用異常來做簡單的錯誤處理, 而不是把異常用於無法在本地處理的錯誤。很少有關於異常及其替代方案成本的認真調查。我懷疑關於異常的虛假傳說比任何事實都具有更大的影響力。

最終結果是 C++ 社區分裂為異常和非異常陣營。事實上, “不要異常”是一種方言, 而方言是標準要避免的事情之一 ([§3.1](03.md#31-標準)) 。對於個人組織或社區而言, 方言可能有一些優勢, 但它使程式碼和技能的共享變得複雜, 因此損害了整個 C++ 社區。

有人聲稱, 異常機制的問題在於它違反了零開銷原則 (例如 [Sutter 2018b]) 。對比通過終止應用來響應錯誤的處理方案, 任何錯誤處理機制顯然都是開銷, 也都違反了零開銷原則 (除非考慮到處理終止的成本, 例如在另一個處理器中) 。在我們設計異常時, 我們考慮了這些, 並認為開銷是可接受的。理由是: 異常情況很少見; 除非拋出異常, 否則沒有運行期開銷; 並且用於實現異常的表可以保存在虛擬記憶體中 [Koenig and Stroustrup 1989]。在虛擬記憶體不可用或記憶體不足的情況下, 使用表來實現異常可能成為一個嚴重問題。我們當時設計異常時主要關注的是, 需要某種形式的錯誤傳播和錯誤處理的系統。在這種情況下, 零開銷可以解釋為“異常與以在同樣嚴格程度的錯誤處理下的錯誤碼使用相比沒有額外開銷”。

如今, 錯誤處理的混亂比以往任何時候都嚴重, 處理錯誤的替代技術比以往任何時候都多, 從而造成很大的混亂和危害。假設有 N 種錯誤處理方式, 又有人提出了一個新的解決方案, 只要舊的解決方案不被拋棄, 現在我們就必須應對 N+1 種方式 (“N+1 問題”) 。如果一個組織有 M 個程式, 使用了 N 個庫, 我們甚至可能有 N\*M 個需要處理的問題。異常的引入可以看作是將處理錯誤的常用方法從 7 種增加到了 8 種。2015 年, Lawrence Crowl 撰寫了一份問題分析報告 [Crowl2015a] 對這個問題進行了分析。

基礎庫的作者對多種錯誤處理方案的問題感受最為深刻。他們不知道他們的使用者喜歡什麼, 他們的使用者可能有很多不同的偏好。C++17 檔案系統庫 ([§8.6](08.md#86-檔案系統)) 的作者們選擇了把介面重複一遍: 對於每個操作, 他們提供兩個函數, 一個在錯誤的情況下拋出異常, 另一個函數則通過設置標準程式庫的 `error_code` 參數將錯誤碼通過參數傳遞出來: 

```cpp
bool create_directory(const filesystem::path& p); // 出現錯誤時拋異常
bool create_directory(const filesystem::path& p, error_code& ec) noexcept;
```

當然, 這有點冗長, 只會取悅那些僅喜歡異常或 `error_code` 的人。也要注意作者提供了 `bool` 返回值, 這樣人們就不必一直使用 `try` 或直接測試 `error_code` 了。事實上, 檔案系統 (在我看來相當正確) 使用異常來處理罕見的錯誤並不能讓那些認為異常有根本缺陷的人滿意, 特別是, 它仍要求存在異常支援。

## 7.3 `noexcept` 規約

使用 `noexcept` ([§4.5.3](04.md#453-noexcept-規約)) , 人們可以抑制所有從函數拋出的異常, 並允許呼叫者忽略拋出異常的可能性。

使用 `noexcept` 可以使擔心性能問題 (或真或假) 的人們放心。它也可以通過減少控制路徑的數量來改善優化效果, 但前提是程式員不要通過測試返回碼將這些路徑添加回去。許多低級函數, 例如大多數 C 函數, 都不存在異常。

使用 `noexcept` 可以簡化錯誤處理 (如果一個函數不拋出異常, 我們就不需要捕獲任何異常) , 也可以使其複雜化 (如果一個函數不能拋出異常, 但又可能會失敗, 我們必須使用其他錯誤處理機制) 。特別是, 在異常拋出與其處理程式之間的路徑上的 `noexcept`, 會把一個異常變成程式終止運行。因此, 對於一個處于維護期的程式, 在函數中使用使用 `noexcept`, 可能會導致先前正確的程式失敗。

請注意, 異常被添加到 C++ 中的一個重要原因是為了支援那些在發生錯誤時也決不可以無條件中止的應用。異常僅表示發生了故障, 並且從 `main()` 到拋出點的路徑上的任何程式碼都可以對其進行處理。特別是, 這樣可以支援一個重要場景: 在終止之前進行一些本地清理 (例如, 刷新輸出緩衝區, 或嚮日志檔案添加錯誤報告) 。

## 7.4 類型系統的支援

解決 C++ 中的邏輯和性能問題的傳統方法是將計算從運行期挪到編譯期。顯然, 將異常與靜態類型系統整合的可能性在 1980 年代被認真考慮過, 後來又反覆被重新考慮。如果異常是函數類型的一部分, 那麼程式就會有更好的類型檢查, 函數就更能自我描述, 異常處理也更容易優化。

不將異常作為類型系統的一部分的一個主要原因是, 如果異常是函數類型的一部分, 那麼對該函數可能拋出的異常集的更改將要求所有呼叫該函數的函數重新編譯。在一個大多數主要程式都由許多單獨開發的庫組成的世界裡, 這將導致災難性的脆弱, 及無法管理的相互依賴 [Stroustrup 1994]。

函數指標方面也有相關的明顯問題。在大多數主要的 C++ 程式中都有很多 C 風格的程式碼, 現在仍然如此。C 風格的泛型程式碼 (例如, `qsort` 的比較函數參數) 和回調 (例如, 在 GUI 中) 的主要參數化機制均會用到函數指標。

如果我需要一個指向函數的指標, 並且異常是類型系統的一部分, 那麼, 我要麼決定始終從所指向的函數中獲取異常, 要麼不接受異常, 要麼以某種方式處理這兩種選擇。除非將對類型查詢的支援或基于異常的重載添加到語言中, 否則都很難兩者兼顧。確定了要接受哪種類型函數指標參數後, 我現在必須調整呼叫函數中的錯誤檢查方式以匹配所接受的函數指標類型。即使這些可以在 C++ 語言中處理, 也將影響與 C 的交互: 這時如何將指向 C++ 函數的指標傳遞給 C? 例如, 如何處理從 C 中回調依賴異常的 C++ 的函數? 顯然, C++ 函數中的異常不會消失, 因此我們將有四種選擇: 錯誤碼、編譯期檢查的異常 (例如 [Sutter 2018b]) 、當前異常和 `noexcept`。只有當前的異常和非本地錯誤碼不會影響類型系統或呼叫約定 (ABI 介面) 。幸運的是, 很少有函數需要兩個指標指向函數, 否則我們將面臨選擇 16 種方案的風險。因此, 如果接受異常類型系統 (就當前的異常而言) , 混亂將是全方面的。

在現代 C++ 中, 此類問題將以其他回調機制的不同形式繼續存在, 例如具有要被呼叫的成員函數的對象、函數對象和 lambda 表達式。

我的結論 (得到 WG21 的認可) 過去和現在都是, 在 C++ 的靜態類型系統中添加異常會導致系統脆弱、程式碼複雜性顯著增加、嚴重的不兼容性以及與 C 程式碼交互的問題。這一點在 1989 年就得到了重視。

## 7.5 回歸基礎

從根本上講, 我認為 C++ 需要兩種錯誤處理機制: 

- **異常**——罕見的錯誤或直接呼叫者無法處理的錯誤。
- **錯誤碼**——錯誤碼表示可以由直接呼叫者處理的錯誤 (通常隱藏在易於使用的檢測操作中或作為 (值,錯誤碼) 對從函數返回) 。

考慮程式碼: 
```cpp
void user()
{
    vector<string> v{"hello!"};
    for (string s; cin>>s; )
        v.push_back(s);
    auto ps = make_unique<Shape>(read_shape(cin));
    Smiley_face face{Point{0,0},20};
    // ...
}
```

這個例子人造的, 但其編程風格並非不典型。我們可以從中看出, `user()` 函數里有很多發生不太可能的錯誤的可能性: 記憶體耗盡、讀取錯誤、構造失敗 (例如, 在 `Smile_face` 的多層次結構中出現錯誤等) 。另外, 使用 `unique_ptr<Shape>` 可以防止記憶體泄漏。如果我們使用顯式錯誤碼而不是異常, 那麼這個函數中至少需要進行五次錯誤檢查, 原始碼數量將翻倍, 並需要在各個建構子中進行更多檢查。沒有 RAII (及其與異常的整合) , 程式碼將進一步膨脹。一般來說, 更多的程式碼意味着更多的錯誤。當添加的程式碼使控制流程複雜時, 尤其如此。這一點經常被那些通過小例子論證的人所忽視。對於小例子來說, “就一項測試”關係不大, 相對也很難漏掉。

另一方面, 有些錯誤是預料得到的, 我們更願意使用某種形式的錯誤碼來對其進行檢查: 

```cpp
ifstream f {"Myfile"};
if (!f) {
    // ... 處理錯誤 ...
}
// ... 使用 f ...
```

在這裡, 為方便起見, 錯誤碼隱藏在輸入流的狀態裡。

因此, 在理想情況下, 應該只有兩種錯誤處理的方法, 但是我真的不知道如何達到這樣一種理想狀態。僅僅 (值,錯誤碼) 對就有十幾種變體被廣泛使用 (例如 `std::map::insert()`) , 並且還有一些新的變體也在 2011 年的 WG21 中被討論 (如 [Botet and Bastien 2018; Sutter 2018b]) 。即使委員會能就其中一個方案達成一致, 也仍然會有至少十幾個廣泛使用的錯誤處理方案, 每個方案都有一大群忠實的追隨者支援, 許多方案都有數百萬行難以更動的程式碼。

很少有關於異常的性能和 C++ 中返回碼可靠性的認真研究 ([Renwick et al. 2019] 是一個例外) 。但是, 有許多不科學的小研究和許多大聲表達的意見——常常聲稱異常天生就比各種形式的錯誤碼檢查慢。這與我的經驗不符。就我所知, 還沒有任何嚴謹的研究發現在現實的例子中錯誤碼能勝出“很多”, 或者異常能勝出“很多”。在這一討論場景下, “很多”表示整數倍的差異, 而不是幾個百分點。

運行一個簡單的性能測試: 進行一個 N 層深度的呼叫序列, 然後報告錯誤。如果錯誤很少見, 例如 1:1000 或 1:10000 的錯誤率, 並且呼叫嵌套很深, 例如 100 或 1000, 則異常處理要比明確的錯誤碼判斷方式快得多。如果呼叫深度為 1, 並且錯誤發生的概率為 50％, 則顯式判斷錯誤碼測試將大獲全勝。呼叫深度和錯誤概率決定了這些測試之間的差異。我要問一個簡單而潛在有用的問題: “一個錯誤要多罕見才被看作是異常情況”? 不幸的是, 答案是“這要看情況”。這取決於程式碼、硬體、優化器、異常處理的實現, 等等等等。C++ 異常的設計假設答案至少在 1:100 的範圍。換句話說, 錯誤指示的傳播要遠比顯式的處理更為常見。

空間占用問題可能比運行期問題更難解決。對於那些遇到不能在本地處理的錯誤就可以立即終止的系統, 我可以想象這樣一個實現, 在遇到 `throw` 時立即終止程式。但是如果要傳播和處理錯誤, 那麼就不可避免, 需要面對選擇各種困難的折中。

對於錯誤處理這團亂碼, 任何解決方案都很可能遇到 N+1 問題 ([§4.2.5](04.md#425-統一初始化)) [Stroustrup 2018a]。

奇怪的是, 當初 C++ 引入異常時, 人們擔心的問題之一就是異常不夠通用。許多人認為恢復 (resumption) 語義必不可少 [Stroustrup 1993]。當時我的猜測是, 允許恢復將使異常處理的速度至少再降低兩倍。

[^1]: 譯註: 原文如此。實際上 Bjarne 的這個寫法仍然是返回對象而不是錯誤碼, 因此仍需使用異常。不用異常的寫法還要囉嗦得多。
