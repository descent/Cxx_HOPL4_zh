# 1. 前言

最初, 我設計 C++ 是為了回答這樣的一個問題: 如何直接操作硬體, 同時又支援高效、高級的抽象? C++ 在 1980 年代僅僅是一個基于 C 和 Simula 語言功能的組合, 在當時的計算機上作為系統編程的相對簡單的解決方案, 經過多年的發展, 已經成長為一個遠比當年更複雜和有效的工具, 應用極其廣泛。它保持了如下兩方面的關註: 

- **語言結構到硬體設備的直接映射**
- **零開銷抽象**

這種組合是 C++ 區別于大多數語言的決定性特徵。“零開銷”是這樣解釋的 [Stroustrup 1994]: 

- 你不用的東西, 你就不需要付出代價 (“沒有散落在各處的贅肉”) 。
- 你使用的東西, 你手工寫程式碼也不會更好。

抽象在程式碼中體現為函數、類、模板、概念和別名。

C++ 是一種活的語言, 因此它會不斷變化以應對新出現的挑戰和演變中的使用風格。2006 年至 2020 年期間的這些挑戰和變化是本文的重點。當然, 一門語言本身不會改變; 是人們改變了它。所以這也是參與 C++ 演化的人們的故事, 他們識別出面臨的挑戰, 詮釋解決方案的侷限, 組織他們的工作成果, 並解決他們之間必然出現的分歧。當我呈現一種語言或標準庫特性時, 其背景是 C++ 的一般發展和當時參與者的關切。對於在早期被接受的許多特性, 我們現在從大量的工業使用中獲得了後見之明。

C++ 主要是一種工業語言, 一種構建系統的工具。對於使用者來說, C++ 不僅僅是一種由規範定義的語言; 它是由許多部分組成的工具集的一部分: 

- 語言
- 標準庫
- 許多的其他庫
- 龐大的——常常是舊的——程式碼庫
- 工具 (包括其他語言) 
- 教學和培訓
- 社區支援

只要有可能, 只要合適, 我就會考慮這些組成部分之間的相互作用。

有一種流傳廣泛的謬見, 就是程式員希望他們的語言是簡單的。當你不得不學習一門新的語言、不得不設計一門編程課程、或是在學術論文中描述一門語言時, 追求簡單顯然是實情。對於這樣的用途, 讓語言乾淨地體現一些明確的原則是一個明顯的優勢, 也是理想情況。當開發人員的焦點從學習轉移到交付和維護重要的應用程式時, 他們的需求從簡單轉移到全面的支援、穩定性 (兼容性) 和熟悉度。人們總是混淆熟悉度和簡單, 如果可以選擇的話, 他們更傾向于熟悉度而不是簡單。

看待 C++ 的一種方式是, 把它看成幾十年來三種相互矛盾的要求的結果: 

- **讓語言更簡單! **
- **立即添加這兩個必要特性! ! **
- **不要搞砸我的 (任何) 程式碼! ! ! **

我添加了感嘆號, 因為這些觀點的表達常常帶著不小的情緒。

我想讓簡單的事情簡單做, 並確保複雜的事情並非不可能或沒有必要地難。前者對於不是語言律師的開發者來說是必不可少的; 後者對於基礎性程式碼的實現者是必要的。穩定是所有意圖持續運行幾十年的系統的基本屬性, 然而一種活的語言必須適應不斷變化的世界。

C++ 有一些總體構想。我闡述了一些 (如《C++ 語言的設計和演化》 (*The Design and Evolution of C++*) [Stroustrup 1994] ([§2](02.md#2-背景c-的-19792006)) 、設計原則 ([§9.1](09.md#91-設計原則)) , 以及 C++ 模型 ([§11.1](11.md#111-c-模型)) ) 並試圖讓語言在演化時遵循它們。然而, C++ 的開發由 ISO 標準委員會控制, 它主要關注的是長長的新特性列表, 以及對實際細節的關心。這是社區裡最能表達和最有影響力的人所堅持的東西, 僅僅基于哲學或理論觀點就否認他們的關切和意見的話, 恐怕就失之魯莽了。

## 1.1 年表

為了給出一個快速的概述, 這裡有一個粗略的年表。如果你不熟悉 C++, 很多術語、構造、庫都會晦澀難懂; 大多數在以前的 HOPL 論文 [Stroustrup 1993, 2007] 或本文中有詳細解釋。

- 1979 年: 工作始於“帶類的 C”, 它變成了 C++; 擁有了第一個非研究性的使用者; 
  - 語言: `class`、建構子/解構子、`public`/`private`、簡單繼承、函數參數類型檢查
  - 庫: `task` (協程和仿真支援) 、用macro 參數化的 `vector`
- 1985 年: C++ 的首次商業發行; TC++PL1 [Stroustrup 1985b]
  - 語言: `virtual` 函數、運算符重載、引用、常數
  - 庫: `complex` 演演算法, 流輸入輸出
- 1989–91 年: ANSI 和 ISO 標準化開始; TC++PL2 [Stroustrup 1991]
  - 語言: 抽象類、多重繼承、異常、模板
  - 庫: 輸入輸出流 (但沒有 `task`) 
- 1998 年: C++98、第一個 ISO C++ 標準 [Koenig1998]、TC++PL3 [Stroustrup 1997]
  - 語言: `namespace`、具名類型轉換[^1]、`bool`、`dynamic_cast`
  - 庫: STL (容器和演演算法) 、`string`、`bitset`
- 2011 年: C++11 [Becker 2011], TC++PL4 [Stroustrup 2013]
  - 語言: 記憶體模型、`auto`、範圍 `for`、`constexpr`、lambda 表達式、使用者定義字面量......
  - 庫: `thread` 和鎖、`future`、`unique_ptr`、`shared_ptr`、`array`、時間和時鐘、隨機數、無序容器 (哈希表) ......
- 2014 年: C++14 [du Toit 2014]
  - 語言: 泛型 lambda 表達式、`constexpr` 函數中的局部變數、數字分隔符......
  - 庫: 使用者定義字面量......
- 2017 年: C++17 [Smith 2017]
  - 語言: 結構化綁定、變數模板、模板參數的建構子推導......
  - 庫: 檔案系統、`scoped_lock`、`shared_mutex` (讀寫鎖) 、`any`、`variant`、`optional`、`string_view`、並行演演算法......
- 2020 年: C++20 [Smith 2020]
  - 語言: `concept`、`module`、協程、三路比較、改進對編譯期計算的支援......
  - 庫: 概念、範圍、日期和時區、`span`、格式、改進的並發和並行支援......

請注意, 早年 C++ 的庫是很匱乏的。事實上, 當時還是存在大量各種各樣的庫 (包括圖形使用者界面庫) , 但很少被廣泛使用, 並且很多庫是專有軟體。這是在開源開發普及之前的事。這造成了 C++ 社區沒有一個重要的共享基礎庫。在我的 HOPL2 論文 [Stroustrup 1993] 的回顧中, 我認為那是早期 C++ 最糟糕的錯誤。

任務庫 [Stroustrup 1985a,c] 是一個基于協程的庫, 支援事件驅動的仿真 (例如隨機數生成) , 與替代方案相比是非常高效的, 甚至可以運行在很小的計算機上。例如, 我在 256KB 的記憶體中運行了 700 個任務的仿真。任務庫在 C++ 早期非常重要, 是貝爾實驗室和其他地方許多重要應用的基礎。然而, 它有點醜陋, 並且不容易移植到 Sun 的 SPARC 體繫結構, 因此大多數 1989 年以後的實現都不支援它。2020 年, 協程才剛剛回歸 ([§9.3.2](09.md#932-協程)) 。

總的來說, C++ 的特性不斷增多。ISO 委員會也廢除了一些特性, 對語言進行了稍許清理, 但是考慮到 C++ 的大量使用 (數十億行程式碼) , 重要的特性是永遠不會被移除的。穩定性也是 C++ 的關鍵特性。要解決跟語言不斷增長的規模和複雜性相關的問題, 辦法之一是通過編碼指南 ([§10.6](10.md#106-編碼指南)) 。

## 1.2 概述

這篇論文是按照 ISO 標準發佈的大致時間順序組織的。

- [§1](#1-前言): 前言
- [§2](02.md#2-背景c-的-19792006): 背景: C++ 的 1979–2006
- [§3](03.md#3-c-標準委員會): C++ 標準委員會
- [§4](04.md#4-c11感覺像是門新語言): C++11: 感覺像是門新語言
- [§5](05.md#5-c14完成-c11): C++14: 完成 C++11
- [§6](06.md#6-概念): 概念
- [§7](07.md#7-錯誤處理): 錯誤處理
- [§8](08.md#8-c17大海迷航): C++17: 大海迷航
- [§9](09.md#9-c20方向之爭): C++20: 方向之爭
- [§10](10.md#10-2020-年的-c): 2020 年的 C++
- [§11](11.md#11-回顧): 回顧

如果一個主題跨越了一段較長的時間, 比如“概念”和標準化流程, 我會把它放在一個地方, 讓內容優先於時間順序。

這篇論文特別長, 真是一篇專題論文了。但是從 2006 年到 2020 年, C++ 經歷了兩次主要修訂: C++11 和 C++20; 而論文的早期讀者們也都要求獲得更多的訊息。結果就是論文的頁數几乎翻倍。即使以目前的篇幅, 讀者也會發現某些重要的主題沒有得到充分的展現, 如並發和標準庫。

[^1]: 譯註: 即新的、非 C 風格的類型轉換
